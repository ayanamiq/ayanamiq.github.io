---
title: JAVA概念
tags: java
date: 2018-12-06 18:18:52
---

this 表示当前函数，所属对象的引用
super用于调用父类方法

# 1.static
static可修饰属性、方法和代码块
static 修饰属性：是一个类的共享变量，属于整个类，在不实例化对象的情况下就能访问。
static 修饰方法：不需要实例化对象，可以使用类名调用，静态方法不能访问非静态成员，包括成员的方法和变量。因为此时用类调用，没有对象的概念，this是不可用的。
static 修饰代码块：一般静态代码块用来初始化静态成员。
因为静态优先于对象存在，静态方法不可以出现this.
非静态函数中可以访问静态成员变量

“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。
公有puclic:公有变量，外部也可以调用的变量
私有private：私有变量,只能在对象内部调用，外部调用需要设置get(),set()方法，get用于获取对象的属性，set用于设置对象的属性

# 2.final
final修饰符可修饰 类，属性，方法
final 修饰类：此类不可被继承，即final没有子类，这样可以保证用户调用时动作的一致性，防止子类覆盖情况的发生
final 修饰变量：此时的属性为常量，常量的地址不可变，但在地址中保存的值(即对象的属性)，是可以改变的
final 修饰方法：此方法不可覆盖
问题：final, finally, finalize 的区别
1.final--修饰符(关键字),如果一个类被声明为final,意味着它不能再派生出新的子类，不能作为父类被继承
2.finally是在异常处理时提供finally块来执行任何清除操作,不管有没有异常被抛出、捕获，finally块都会被执行
3.finalize方法来自于java.lang.Object，用于回收资源。在实际应用中，不要依赖使用该方法回收任何短缺的资源，这是因为很难知道这个方法什么时候被调用。

# 3.什么是函数的重载？
重载是同一个类中，有两个及以上的方法，拥有相同的方法名，但是参数不同，方法体也不同
系统会根据传入的参数类型和参数个数来判断要用到的方法

# 4. 函数的重写？
重写指的是子类方法覆盖父类方法，要求方法名和参数都相同，但修饰符和返回值可能不同，构造方法无法覆盖

# 5.什么是构造方法？
构造方法主要作用是完成对象的初始化工作，能够把定义对象时的参数传递给对象的域
1.构造方法名称必须与类名相同
2.没有返回类型，也不能定义void，方法前不声明方法类型
3.一个类可以定义多个构造方法，如在定义类时没有定义构造方法，系统会自动插入一个无参数的默认构造器，这个构造器不执行任何代码
4.构造方法可以重载

# 6.封装
把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口
封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口
java中提供四个修饰符来进行对象属性和方法的访问权限控制：
private ：类内部可见
default ：包内部可见
protected ：包内部或子类可见
public ：所有可见
好处:
.通过隐藏对象的属性来保护对象内部的状态。
.提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。
.禁止对象之间的不良交，互提高模块化。

# 7.继承
继承是从已有类得到继承信息创建新类的过程。
提供继承信息的类被称为父类，得到继承信息的类被称为子类
.父类非私有化的属性和方法可以继承到子类
.父类的构造方法子类不可以继承，更不存在覆盖
.java中不允许多继承，一个类只有一个父类
.super()表示调用父类的构造方法，super()和this()一样，必须放在第一行。
.this()用于调用本类的构造方法

# 8.多态
多态性是指允许不同子类型的对象对同一消息作出不同的响应
多态分为:编译时多态和运行时多态
.编译时多态：编译时动态加载(方法的重载)
.运行时多态：一个对象可以有多个类型(子类重写父类方法),父类引用指向子类对象

运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事
1.方法重写（子类继承父类并重写父类中已有的或抽象的方法）
2.父类引用指向子类对象,这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为	

.如果子类中重写了父类中的方法，那么在调用这个方法的时候，将会调用子类中的这个方法
.变量不能被重写(覆盖)，重写只针对方法，如果在子类中重写了父类中的变量，那么编译会报错
.如果继承的子类继承父类的一个方法后加以重载，则该父类引用不能使用重载后的那个方法

体现：父类引用指向子类对象
前提：	要有继承，要有方法重写，父类引用指向子类对象
好处：把不同的子类对象都当做父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码。

例: 游戏中有不同的角色，它们都有一个父类，它们做相同动作时表现出来的效果就会不一样，比如跑，魔法师的跑跟战士的跑就不会一样，
这就是俩者都覆盖了父类中的跑方法，各自有自己的现实，表现出来多态。
如果有一天你想再加个角色，只用再写一个类继承该父类，覆盖其中的跑方法就行了，其他代码不用怎么改，所以可维护性也很好。

# 9.接口、抽象类区别:
1.方法实现：
抽象类可以有默认的方法实现，接口完全是抽象的。它根本不存在方法的实现

2.构造方法：
抽象类可以有构造器，接口不能有构造方法。

3.多继承：
子类只能继承一个抽象类(java单继承，子类->(继承extend)抽象类)，
子类可以实现多个接口(子类->(实现implements)接口)

4.声明: 
接口：public inerface Person,
抽象类：abstract class Person

5.访问修饰符：
抽象方法可以有public/default等修饰符，接口方法默认修饰符是public，不能用其他修饰

6.实现：
抽象类：子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供接口中所有声明的方法的实现抽象类中所有声明的方法的实现。
接口：子类使用关键字implements来实现接口，它需要提供接口中所有声明的方法的实现

2018/12/18 update：
今天在读到Collection的源码时，发现Collection接口继承(extends)了Iterable接口，按照我以前的理解，接口(interface)只能被实现(implements)，不能被继承(extends)。
而实际上，java有个说法叫：
接口对接口的扩展，严格上不叫继承，即interface extends interface。
但是普通的java类是绝对不可以继承(extends)一个接口的。

# 10.内部类
注：所有使用内部类的地方都可以不用内部类，使用内部类可以使程序更加的简洁，便于命名规范和划分层次结构。
内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。
内部类是指在一个外部类的内部再定义一个类。内部类作为外部类的一个成员，并且依附于外部类而存在的。
内部类的分类：
.成员内部类:作为外部类的一个成员存在，与外部类的属性、方法并列
.局部内部类:在方法中定义的内部类
.静态内部类:静态内部类只能访问外部类的静态成员
.匿名内部类:通过匿名接口实现，是一种特殊的局部内部类

# 11.正向和反向代理
正向：代理服务器在客户端(client)那边就是正向代理,正向代理需要客户端配置，客户端是知道自己通过代理方式去访问服务器的，例如：vpn，ssr

反向：代理服务器在原始服务器(server)那边就是反向代理，反向代理，客户端根本就不知道，是服务端配置的。例如：nginx

# 12.get和post的区别？
1.get是从服务器上获取数据，post是向服务器传送数据。
2.get地址栏明文传输数据，post通过http header传输
3.get传输的数据量很小，post较大
4.get安全性教差，post安全性较高
5.get产生一个TCP数据包,post产生两个TCP数据包。

# 13.session和cookie的区别
1.session保存在服务器，客户端不知道其中信息；cookie保存在客户端，服务器可以知道其中信息
2.session保存的是对象，cookie保存的是字符串
3.cookie不安全，考虑安全应当用session
4.访问量增多会占用服务器性能，考虑到这应当用cookie

# 14.session的分布式处理
1.粘性session：
负载均衡器设置了粘性Session，用户的每次请求都会转发到同一台服务器上，
相当于把用户和服务器黏在了一起
缺点：容错性低,如果当前服务器故障，用户被转移到另一台服务器上，session信息会失效
实现：nginx通过ip_hash属性即可实现粘性session

2.服务器session复制：
任何一个服务器上的session发生改变，该节点会把这个session的所有内容序列化，
然后广播给其他节点，不管其他服务器是否需要，以此来实现session同步
缺点：降低服务器性能，对网络造成压力
实现：tomcat中，server.xml开启tomcat集群功能

3.redis实现session共享
4.session入库

# 15.jdbc基本流程
1.加载数据库驱动
2.获取数据库连接
3.创建sql对象
4.执行sql语句
5.处理ResultSet
6.释放资源

# 16. 反射
反射

首先我们了解一下JVM，什么是JVM，Java的虚拟机，java之所以能跨平台就是因为这个东西，
你可以理解成一个进程，程序，只不过他的作用是用来跑你的代码的。
假如你写了一段代码：Object o=new Object();  运行了起来！

1.首先JVM会启动，你的代码会编译成一个.class文件
2.然后被类加载器加载进jvm的内存中，你的类Object加载到方法区中，创建了Object类的class对象到堆中，注意这个不是new出来的对象，而是类的类型对象，每个类只有一个class对象，作为方法区类的数据结构的接口。

jvm创建对象前，会先检查类是否加载，寻找类对应的class对象，若加载好，则为你的对象分配内存，
初始化也就是代码:new Object()。
上面的流程就是你自己写好的代码扔给jvm去跑，跑完就over了，jvm关闭，你的程序也停止了。
为什么要讲这个呢？因为要理解反射必须知道它在什么场景下使用。

想想上面的程序对象是自己new的，程序相当于写死了给jvm去跑。
假如一个服务器上突然遇到某个请求要用到某个类，
但没加载进jvm，是不是要停下来自己写段代码，new一下，再启动一下服务器？错~~

反射是什么呢？当我们的程序在运行时，
需要动态的加载一些类这些类可能之前用不到所以不用加载到jvm。

举个例子我们的项目底层有时是用mysql，有时用oracle，
需要动态地根据实际情况加载驱动类，这个时候反射就有用了，
假设 com.java.dbtest.myqlConnection，com.java.dbtest.oracleConnection
这两个类我们要用，这时候我们的程序就写得比较动态化，
通过Class tc = Class.forName("com.java.dbtest.TestConnection");
通过类的全类名让jvm在服务器中找到并加载这个类，
而如果是oracle则传入的参数就变成另一个了。
这时候就可以看到反射的好处了，这个动态性就体现出java的特性了！
当然这里只是举了反射的一个应用，实际还有其他作用，只是这个例子能更好地理解！

一.概念
主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，
并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。

程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。
所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。
反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁

Java反射框架主要提供以下功能：

1.在运行时判断任意一个对象所属的类；
2.在运行时构造任意一个类的对象；
3.在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；
4.在运行时调用任意一个对象的方法
重点：是运行时而不是编译时

当我们在使用IDE(如Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。
很多框架（比如Spring）都是配置化的（比如通过XML文件配置JavaBean,Action之类的），
为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象.

二，反射机制的作用：
    1.反编译：.class-->.java
    2.通过反射机制访问java对象的属性，方法，构造方法等；


三，在这里先看一下sun为我们提供了那些反射机制中的类：
	java.lang.Class;
	java.lang.reflect.Constructor; 
	java.lang.reflect.Field;
	java.lang.reflect.Method;
	java.lang.reflect.Modifier;
	很多反射中的方法，属性等操作我们可以从这四个类中查询。
	
四.具体功能实现：
```
1.反射机制获取类有三种方法，我们来获取Employee类型
//第一种方式：  (注意要包名+类名)
Class c1 = Class.forName("demo.Employee");

//第二种方式：
//java中每个类型都有class属性.
Class c2 = Employee.class;

//第三种方式：
//java语言中任何一个java对象都有getClass 方法
Employee e = new Employee();
Class c3 = e.getClass(); //c3是运行时类 (e的运行时类是Employee)
    
2.创建对象：获取类以后我们来创建它的对象，利用newInstance：
Class c =Class.forName("demo.Employee");

//创建此Class 对象所表示的类的一个新实例
Object o = c.newInstance(); //调用了Employee的无参数构造方法
    
3.获取属性：分为所有的属性和指定的属性：
b，获取特定的属性，对比着传统的方法来学习：
//Student类
public class Student {
    private String name ;
    int age;
}

//传统方法：
Student s = new Student();
s.age = 12; //set 
        System.out.println(s.age);//get 
//但是无法获取private的属性


//反射方法
Class<?> c1 = Class.forName("reflect.Student");//取得对象
Object o = c1.newInstance();//实例化对象 
Field nameF = c1.getDeclaredField("name");//获取name属性
        nameF.setAccessible(true); //使用反射机制可以打破封装性，导致了java对象的属性不安全。  
        nameF.set(o,"钢铁侠");//给属性赋值
        System.out.println(nameF.get(o));
            
4，获取方法，和构造方法，不再详细描述，只来看一下关键字：
方法和关键字:
getDeclaredMethods():获取所有的方法
getReturnType():获得方法的放回类型
getParameterTypes():获得方法的传入参数类型
getDeclaredMethod("方法名",参数类型.class,……):获得特定的方法
        构造方法关键字
getDeclaredConstructors():获取所有的构造方法
getDeclaredConstructor(参数类型.class,……):获取特定的构造方法

父类和父接口:
getSuperclass():获取某类的父类
getInterfaces():获取某类实现的接口
```
这样我们就可以获得类的各种内容，进行了反编译。
对于JAVA这种先编译再运行的语言来说，反射机制可以使代码更加灵活，更加容易实现面向对象。

最后:	
JAVA反射的再次学习，灵活的运用它，能够使我们的代码更加灵活，但是它也有它的缺点，
就是运用它会使我们的软件的性能降低，复杂度增加，所以还要我们慎重的使用它。
