<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: 'UJCQ3PDF0F',
      apiKey: 'a3d4ab7cd60617bd0d524169bb08d56d',
      indexName: 'dev_ayanamiq',
      hits: {"per_page":10},
      labels: {"input_placeholder":"输入关键字","hits_empty":"没有找到关于 ${query} 的文章","hits_stats":"${hits} 相关记录，共耗时 ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="AOP概述AOP(面向切面编程)可以说是OOP(面向对象编程)的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系，例如日志功能。 日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其">
<meta name="keywords" content="Spring">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring">
<meta property="og:url" content="https://jingyao066.gitee.io/2018/12/06/Spring/index.html">
<meta property="og:site_name" content="王靖尧的博客">
<meta property="og:description" content="AOP概述AOP(面向切面编程)可以说是OOP(面向对象编程)的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系，例如日志功能。 日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://jingyao066.gitee.io/2018/12/06/Spring/1.png">
<meta property="og:image" content="https://jingyao066.gitee.io/2018/12/06/Spring/2.jpg">
<meta property="og:image" content="https://jingyao066.gitee.io/2018/12/06/Spring/3.jpg">
<meta property="og:updated_time" content="2019-06-13T07:27:32.283Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring">
<meta name="twitter:description" content="AOP概述AOP(面向切面编程)可以说是OOP(面向对象编程)的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系，例如日志功能。 日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其">
<meta name="twitter:image" content="https://jingyao066.gitee.io/2018/12/06/Spring/1.png">





  
  
  <link rel="canonical" href="https://jingyao066.gitee.io/2018/12/06/Spring/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Spring | 王靖尧的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">王靖尧的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jingyao066.gitee.io/2018/12/06/Spring/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王靖尧">
      <meta itemprop="description" content="一晃而过的时间，都做了些什么">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王靖尧的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Spring

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-06 18:22:43" itemprop="dateCreated datePublished" datetime="2018-12-06T18:22:43+08:00">2018-12-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-06-13 15:27:32" itemprop="dateModified" datetime="2019-06-13T15:27:32+08:00">2019-06-13</time>
              
            
          </span>

          

          
            
            
          

          
          
            <span id="/2018/12/06/Spring/" class="leancloud_visitors" data-flag-title="Spring">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="AOP概述"><a href="#AOP概述" class="headerlink" title="AOP概述"></a>AOP概述</h1><p>AOP(面向切面编程)可以说是OOP(面向对象编程)的补充和完善。<br>OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。<br>当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。<br>也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系，例如日志功能。</p>
<p>日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。<br>对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。<br>这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。<br>所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</p>
<p>AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。</p>
<p>使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。<br>业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。<br>横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。<br>Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p>
<h2 id="AOP的实现方式"><a href="#AOP的实现方式" class="headerlink" title="AOP的实现方式"></a>AOP的实现方式</h2><ul>
<li>采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行。</li>
<li>采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>Authentication 权限</li>
<li>Caching 缓存</li>
<li>Context passing 内容传递</li>
<li>Error handling 错误处理</li>
<li>Lazy loading　懒加载</li>
<li>Debugging　　调试</li>
<li>logging, tracing, profiling and monitoring　记录跟踪　优化　校准</li>
<li>Performance optimization　性能优化</li>
<li>Persistence　　持久化</li>
<li>Resource pooling　资源池</li>
<li>Synchronization　同步</li>
</ul>
<h2 id="AOP相关概念"><a href="#AOP相关概念" class="headerlink" title="AOP相关概念"></a>AOP相关概念</h2><p>方面（Aspect）：一个关注点的模块化，这个关注点实现可能另外横切多个对象。<br>事务管理是J2EE应用中一个很好的横切关注点例子。方面用Spring的 Advisor或拦截器实现。</p>
<p>连接点（Joinpoint）: 程序执行过程中明确的点，如方法的调用或特定的异常被抛出。</p>
<p> 通知（Advice）: 在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”和“throws”通知。通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。Spring中定义了四个advice: BeforeAdvice, AfterAdvice, ThrowAdvice和DynamicIntroductionAdvice</p>
<p> 切入点（Pointcut）: 指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。 Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解， MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上</p>
<p> 引入（Introduction）: 添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。Spring中要使用Introduction, 可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口</p>
<p> 目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象。POJO</p>
<p> AOP代理（AOP Proxy）: AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</p>
<p> 织入（Weaving）: 组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</p>
<h2 id="StringAOP组件"><a href="#StringAOP组件" class="headerlink" title="StringAOP组件"></a>StringAOP组件</h2><p><img src="/2018/12/06/Spring/1.png" alt=""></p>
<h2 id="如何使用AOP"><a href="#如何使用AOP" class="headerlink" title="如何使用AOP"></a>如何使用AOP</h2><p>可以通过配置文件或者编程的方式来使用SpringAOP。配置可以通过xml文件来进行，大概有四种方式：</p>
<ul>
<li>配置ProxyFactoryBean，显式地设置advisors, advice, target等</li>
<li>配置AutoProxyCreator，这种方式下，还是如以前一样使用定义的bean，但是从容器中获得的其实已经是代理对象</li>
<li>通过<a href="aop:config" target="_blank" rel="noopener">aop:config</a>来配置</li>
<li>通过&lt;aop: aspectj-autoproxy&gt;来配置，使用AspectJ的注解来标识通知及切入点<br>也可以直接使用ProxyFactory来以编程的方式使用Spring AOP，通过ProxyFactory提供的方法可以设置target对象, advisor等相关配置，最终通过 getProxy()方法来获取代理对象</li>
</ul>
<h2 id="SpringAOP代理对象的生成"><a href="#SpringAOP代理对象的生成" class="headerlink" title="SpringAOP代理对象的生成"></a>SpringAOP代理对象的生成</h2><p>Spring提供了两种方式来生成代理对象：JDK_Proxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。下面我们来研究一下Spring如何使用JDK来生成代理对象，具体的生成代码放在JdkDynamicAopProxy这个类中，直接上相关码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * &lt;ol&gt;</span><br><span class="line">    * &lt;li&gt;获取代理类要实现的接口,除了Advised对象中配置的,还会加上SpringProxy, Advised(opaque=false)</span><br><span class="line">    * &lt;li&gt;检查上面得到的接口中有没有定义 equals或者hashcode的接口</span><br><span class="line">    * &lt;li&gt;调用Proxy.newProxyInstance创建代理对象</span><br><span class="line">    * &lt;/ol&gt;</span><br><span class="line">    */</span><br><span class="line">   public Object getProxy(ClassLoader classLoader) &#123;</span><br><span class="line">       if (logger.isDebugEnabled()) &#123;</span><br><span class="line">           logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; +this.advised.getTargetSource());</span><br><span class="line">       &#125;</span><br><span class="line">       Class[] proxiedInterfaces =AopProxyUtils.completeProxiedInterfaces(this.advised);</span><br><span class="line">       findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">       return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那这个其实很明了，注释上我也已经写清楚了，不再赘述。下面的问题是，代理对象生成了，那切面是如何织入的？<br>我们知道InvocationHandler是JDK动态代理的核心，生成的代理对象的方法调用都会委托到InvocationHandler.invoke()方法。而通过JdkDynamicAopProxy的签名我们可以看到这个类其实也实现了InvocationHandler，下面我们就通过分析这个类中实现的invoke()方法来具体看下SpringAOP是如何织入切面的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">publicObject invoke(Object proxy, Method method, Object[] args) throwsThrowable &#123;</span><br><span class="line">       MethodInvocation invocation = null;</span><br><span class="line">       Object oldProxy = null;</span><br><span class="line">       boolean setProxyContext = false;</span><br><span class="line"> </span><br><span class="line">       TargetSource targetSource = this.advised.targetSource;</span><br><span class="line">       Class targetClass = null;</span><br><span class="line">       Object target = null;</span><br><span class="line"> </span><br><span class="line">       try &#123;</span><br><span class="line">           //eqauls()方法，具目标对象未实现此方法</span><br><span class="line">           if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method))&#123;</span><br><span class="line">                return (equals(args[0])? Boolean.TRUE : Boolean.FALSE);</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">           //hashCode()方法，具目标对象未实现此方法</span><br><span class="line">           if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method))&#123;</span><br><span class="line">                return newInteger(hashCode());</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">           //Advised接口或者其父接口中定义的方法,直接反射调用,不应用通知</span><br><span class="line">           if (!this.advised.opaque &amp;&amp;method.getDeclaringClass().isInterface()</span><br><span class="line">                    &amp;&amp;method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">                // Service invocations onProxyConfig with the proxy config...</span><br><span class="line">                return AopUtils.invokeJoinpointUsingReflection(this.advised,method, args);</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">           Object retVal = null;</span><br><span class="line"> </span><br><span class="line">           if (this.advised.exposeProxy) &#123;</span><br><span class="line">                // Make invocation available ifnecessary.</span><br><span class="line">                oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">                setProxyContext = true;</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">           //获得目标对象的类</span><br><span class="line">           target = targetSource.getTarget();</span><br><span class="line">           if (target != null) &#123;</span><br><span class="line">                targetClass = target.getClass();</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">           //获取可以应用到此方法上的Interceptor列表</span><br><span class="line">           List chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method,targetClass);</span><br><span class="line"> </span><br><span class="line">           //如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args)</span><br><span class="line">           if (chain.isEmpty()) &#123;</span><br><span class="line">                retVal = AopUtils.invokeJoinpointUsingReflection(target,method, args);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">                //创建MethodInvocation</span><br><span class="line">                invocation = newReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">                retVal = invocation.proceed();</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">           // Massage return value if necessary.</span><br><span class="line">           if (retVal != null &amp;&amp; retVal == target &amp;&amp;method.getReturnType().isInstance(proxy)</span><br><span class="line">                    &amp;&amp;!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">                // Special case: it returned&quot;this&quot; and the return type of the method</span><br><span class="line">                // is type-compatible. Notethat we can&apos;t help if the target sets</span><br><span class="line">                // a reference to itself inanother returned object.</span><br><span class="line">                retVal = proxy;</span><br><span class="line">           &#125;</span><br><span class="line">           return retVal;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (target != null &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">                // Must have come fromTargetSource.</span><br><span class="line">               targetSource.releaseTarget(target);</span><br><span class="line">           &#125;</span><br><span class="line">           if (setProxyContext) &#123;</span><br><span class="line">                // Restore old proxy.</span><br><span class="line">                AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>主流程可以简述为：获取可以应用到此方法上的通知链(Interceptor Chain)，如果有，则应用通知，并执行joinpoint； 如果没有，则直接反射执行joinpoint。而这里的关键是通知链是如何获取的以及它又是如何执行的，下面逐一分析下。<br>首先，从上面的代码可以看到，通知链是通过<br><code>Advised.getInterceptorsAndDynamicInterceptionAdvice()</code>这个方法来获取的，我们来看下这个方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Object&gt;getInterceptorsAndDynamicInterceptionAdvice(Method method, Class targetClass) &#123;</span><br><span class="line">           MethodCacheKeycacheKey = new MethodCacheKey(method);</span><br><span class="line">           List&lt;Object&gt;cached = this.methodCache.get(cacheKey);</span><br><span class="line">           if(cached == null) &#123;</span><br><span class="line">                    cached= this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(</span><br><span class="line">                                       this,method, targetClass);</span><br><span class="line">                    this.methodCache.put(cacheKey,cached);  </span><br><span class="line">           &#125;  </span><br><span class="line">           returncached;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到实际的获取工作其实是由<br><code>AdvisorChainFactory. getInterceptorsAndDynamicInterceptionAdvice()</code>这个方法来完成的，获取到的结果会被缓存。下面来分析下这个方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 从提供的配置实例config中获取advisor列表,遍历处理这些advisor.如果是IntroductionAdvisor,</span><br><span class="line">    * 则判断此Advisor能否应用到目标类targetClass上.如果是PointcutAdvisor,则判断</span><br><span class="line">    * 此Advisor能否应用到目标方法method上.将满足条件的Advisor通过AdvisorAdaptor转化成Interceptor列表返回.</span><br><span class="line">    */</span><br><span class="line">    publicList getInterceptorsAndDynamicInterceptionAdvice(Advised config, Methodmethod, Class targetClass) &#123;</span><br><span class="line">       // This is somewhat tricky... we have to process introductions first,</span><br><span class="line">       // but we need to preserve order in the ultimate list.</span><br><span class="line">       List interceptorList = new ArrayList(config.getAdvisors().length);</span><br><span class="line"> </span><br><span class="line">       //查看是否包含IntroductionAdvisor</span><br><span class="line">       boolean hasIntroductions = hasMatchingIntroductions(config,targetClass);</span><br><span class="line"> </span><br><span class="line">       //这里实际上注册一系列AdvisorAdapter,用于将Advisor转化成MethodInterceptor</span><br><span class="line">       AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line"> </span><br><span class="line">       Advisor[] advisors = config.getAdvisors();</span><br><span class="line">        for (int i = 0; i &lt;advisors.length; i++) &#123;</span><br><span class="line">           Advisor advisor = advisors[i];</span><br><span class="line">           if (advisor instanceof PointcutAdvisor) &#123;</span><br><span class="line">                // Add it conditionally.</span><br><span class="line">                PointcutAdvisor pointcutAdvisor= (PointcutAdvisor) advisor;</span><br><span class="line">                if(config.isPreFiltered() ||pointcutAdvisor.getPointcut().getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">                    //TODO: 这个地方这两个方法的位置可以互换下</span><br><span class="line">                    //将Advisor转化成Interceptor</span><br><span class="line">                    MethodInterceptor[]interceptors = registry.getInterceptors(advisor);</span><br><span class="line"> </span><br><span class="line">                    //检查当前advisor的pointcut是否可以匹配当前方法</span><br><span class="line">                    MethodMatcher mm =pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line"> </span><br><span class="line">                    if (MethodMatchers.matches(mm,method, targetClass, hasIntroductions)) &#123;</span><br><span class="line">                        if(mm.isRuntime()) &#123;</span><br><span class="line">                            // Creating a newobject instance in the getInterceptors() method</span><br><span class="line">                            // isn&apos;t a problemas we normally cache created chains.</span><br><span class="line">                            for (intj = 0; j &lt; interceptors.length; j++) &#123;</span><br><span class="line">                               interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptors[j],mm));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125; else if (advisor instanceof IntroductionAdvisor)&#123;</span><br><span class="line">                IntroductionAdvisor ia =(IntroductionAdvisor) advisor;</span><br><span class="line">                if(config.isPreFiltered() || ia.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">                    Interceptor[] interceptors= registry.getInterceptors(advisor);</span><br><span class="line">                    interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">                &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">                Interceptor[] interceptors =registry.getInterceptors(advisor);</span><br><span class="line">                interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return interceptorList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法执行完成后，Advised中配置能够应用到连接点或者目标类的Advisor全部被转化成了MethodInterceptor。</p>
<p>接下来我们再看下得到的拦截器链是怎么起作用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (chain.isEmpty()) &#123;</span><br><span class="line">        retVal = AopUtils.invokeJoinpointUsingReflection(target,method, args);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //创建MethodInvocation</span><br><span class="line">        invocation = newReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">        retVal = invocation.proceed();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>从这段代码可以看出，如果得到的拦截器链为空，则直接反射调用目标方法，否则创建MethodInvocation，调用其proceed方法，触发拦截器链的执行，来看下具体代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public Object proceed() throws Throwable &#123;</span><br><span class="line">       //  We start with an index of -1and increment early.</span><br><span class="line">       if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size()- 1) &#123;</span><br><span class="line">           //如果Interceptor执行完了，则执行joinPoint</span><br><span class="line">           return invokeJoinpoint();</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       Object interceptorOrInterceptionAdvice =</span><br><span class="line">           this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);</span><br><span class="line">       </span><br><span class="line">       //如果要动态匹配joinPoint</span><br><span class="line">       if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher)&#123;</span><br><span class="line">           // Evaluate dynamic method matcher here: static part will already have</span><br><span class="line">           // been evaluated and found to match.</span><br><span class="line">           InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">                (InterceptorAndDynamicMethodMatcher)interceptorOrInterceptionAdvice;</span><br><span class="line">           //动态匹配：运行时参数是否满足匹配条件</span><br><span class="line">           if (dm.methodMatcher.matches(this.method, this.targetClass,this.arguments)) &#123;</span><br><span class="line">                //执行当前Intercetpor</span><br><span class="line">                returndm.interceptor.invoke(this);</span><br><span class="line">           &#125;</span><br><span class="line">           else &#123;</span><br><span class="line">                //动态匹配失败时,略过当前Intercetpor,调用下一个Interceptor</span><br><span class="line">                return proceed();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       else &#123;</span><br><span class="line">           // It&apos;s an interceptor, so we just invoke it: The pointcutwill have</span><br><span class="line">           // been evaluated statically before this object was constructed.</span><br><span class="line">           //执行当前Intercetpor</span><br><span class="line">           return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码也比较简单，这里不再赘述。</p>
<p>面向对象编程更多的操作是在纵向部分(即继承，接口实现之类)，这就导致一些需要在横向上(即业务代码方法中的前后)嵌入的非核心代码得在每一个方法上都要去写(比如日志，权限，异常处理等）。<br>它们散布在各方法的横切面上，造成代码重复，也不利于各个模块的重用(毕竟，不同方法还是有所区别)。<br>AOP就是为了解决这种问题而生的。从AOP这个英文缩写来看。A是一把刀，把P的突出部分切出来（类比于围绕方法设定的日志，权限等需求，它们都是属于核心方法外的通用服务），它们有一个共性–圆溜溜的（就像一个工具箱中的扳手，钳子，螺丝刀之类的），所以能把它们集合成一块儿（它们都具有工具的属性），就是中间的O。<br>重新给接回去的时候，就着不同的需求，用O中不同的工具就好(通过不同的方法或注解指明)。<br>概念陈列： 目标对象，AOP代理对象，连接点，切入点，拦截器，通知，织入。<br>假设有一个对象A（目标对象），外部的对象B要想访问到A，需要通过一个安检过程(连接点，比如验证权限m1，登录密码m2，身份识别m3等)。B开始访问后，首先得经过第一层的安检，即权限验证m1(切入点)。通过这一层后，监控整个访问过程的你可以决定是否要向大家伙儿通报外部请求的访问情况。<br>例如：B进来了，在访问开始前，还是结束后，还是全程播报，这就是通知。<br>于A而言，他觉得直接跟B接触可能不太安全，所以A把自己的一些权限给到了代理对象Proxy_A，并让Proxy_A去正面刚B。(A间接的给自己加持了一副铠甲Proxy_A，这就是织入)<br>Proxy_A是怎样产生的呢？这就是AOP动态代理的辅助了。简单来讲，不论你是什么代理，Proxy_某个目标对象，只要是通过JDK或者CGLib的代理副本传送门（类比于抽象）进入到刚B的对战场景中，那么他都算是A（或者其他目标对象）的代言人。</p>
<h1 id="IOC和DI"><a href="#IOC和DI" class="headerlink" title="IOC和DI"></a>IOC和DI</h1><h2 id="IOC和DI第一种解释"><a href="#IOC和DI第一种解释" class="headerlink" title="IOC和DI第一种解释"></a>IOC和DI第一种解释</h2><p>IOC—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。<br>在Java开发中，IOC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。<br>如何理解好IOC呢？理解好IOC的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：</p>
<ul>
<li>谁控制谁，控制什么：传统JavaSE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IOC是有专门一个容器来创建这些对象，即由IOC容器来控制对象的创建；谁控制谁？当然是IOC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象，还有文件等）。</li>
<li>为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转。而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。<br>用图例说明一下，传统程序设计如下图，都是主动去创建相关对象然后再组合起来：<br><img src="/2018/12/06/Spring/2.jpg" alt=""><br>当有了IOC/DI的容器后，在客户端类中不再主动去创建这些对象了，如下图所示:<br><img src="/2018/12/06/Spring/3.jpg" alt=""></li>
</ul>
<h3 id="IOC能做什么"><a href="#IOC能做什么" class="headerlink" title="IOC能做什么"></a>IOC能做什么</h3><p>IOC不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试。有了IOC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。<br>其实IOC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IOC思想中，应用程序就变成被动的了，被动的等待IOC容器来创建并注入它所需要的资源了。<br>IOC很好的体现了面向对象设计法则之：好莱坞法则：“别找我们，我们找你”；即由IOC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p>
<h3 id="IOC和DI-1"><a href="#IOC和DI-1" class="headerlink" title="IOC和DI"></a>IOC和DI</h3><p>DI：Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。<br>理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”？</p>
<ul>
<li>谁依赖于谁：当然是应用程序依赖于IOC容器；</li>
<li>为什么需要依赖：应用程序需要IOC容器来提供对象需要的外部资源；</li>
<li>谁注入谁：很明显是IOC容器注入应用程序某个对象，应用程序依赖的对象；</li>
<li>注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</li>
</ul>
<p>IOC和DI有什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IOC 而言，“依赖注入”明确描述了“被注入对象依赖IOC容器配置依赖对象”。</p>
<h2 id="IOC和DI第二种解释"><a href="#IOC和DI第二种解释" class="headerlink" title="IOC和DI第二种解释"></a>IOC和DI第二种解释</h2><p>首先想说说IOC（Inversion of Control，控制反转）。这是spring的核心，贯穿始终。所谓IOC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。<br>那么IOC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</p>
<p>IOC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？JDK1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。<br>理解了IOC和DI的概念后，一切都将变得简单明了，剩下的工作只是在spring的框架中堆积木而已。</p>
<h2 id="IOC和DI第三种解释"><a href="#IOC和DI第三种解释" class="headerlink" title="IOC和DI第三种解释"></a>IOC和DI第三种解释</h2><p>在平时的java应用开发中，我们要实现某一个功能或者说是完成某个业务逻辑时至少需要两个或以上的对象来协作完成。<br>在没有使用Spring的时候，每个对象在需要使用他的合作对象时，自己均要使用像new object() 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建。<br>创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起。<br>而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面。<br>当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用。<br>至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)，A得到Spring给我们的对象之后，两个人一起协作完成要完成的工作即可。<br>所以控制反转IOC(Inversion of Control)是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，比如转移交给了IOC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了IOC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IOC容器了，通过IOC容器来建立它们之间的关系。</p>
<p>DI(依赖注入)其实就是IOC的另外一种说法，DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。<br>他总结：控制的什么被反转了？就是：<strong>获得–依赖对象–的方式–反转了</strong>。</p>
<p>其实我觉得依赖注入，翻译成<code>依赖的注入</code>更贴切，因为依赖注入是IOC的一个过程，我们使用了IOC容器，现在，对象是被动的等待IOC容器来创建并注入它所需要的资源了，<br>依赖注入，是程序(对象)变为了依赖注入这种状态，而依赖注入是一种行为，以前是我们主动的去创建对象，现在对象等待IOC容器来创建并注入它所需的资源，现在的对象是<strong>依赖注入的</strong><br>IOC源码解读：<br><a href="http://www.cnblogs.com/ITtangtang/p/3978349.html" target="_blank" rel="noopener">http://www.cnblogs.com/ITtangtang/p/3978349.html</a></p>
<h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><ul>
<li><p>Spring有哪些优点<br>轻量级：Spring在大小和透明性方面绝对属于轻量级的，基础版本的Spring框架大约只有2MB。<br>控制反转(IOC)：Spring使用控制反转技术实现了低耦合。依赖被注入到对象，而不是创建或寻找依赖对象。<br>面向切面编程(AOP)： Spring支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。<br>容器：Spring包含并管理应用程序对象的配置及生命周期。<br>MVC框架：Spring的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。<br>事务管理：Spring对下至本地业务上至全局业务(JAT)提供了统一的事务管理接口。<br>异常处理：Spring提供一个方便的API将特定技术的异常(由JDBC, Hibernate, 或JDO抛出)转化为一致的、Unchecked异常。</p>
</li>
<li><p>Spring框架有哪些模块？<br>Spring框架的基本模块如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Core module</span><br><span class="line">Bean module</span><br><span class="line">Context module</span><br><span class="line">Expression Language module</span><br><span class="line">JDBC module</span><br><span class="line">ORM module</span><br><span class="line">OXM module</span><br><span class="line">Java Messaging Service(JMS) module</span><br><span class="line">Transaction module</span><br><span class="line">Web module</span><br><span class="line">Web-Servlet module</span><br><span class="line">Web-Struts module</span><br><span class="line">Web-Portlet module</span><br></pre></td></tr></table></figure>
</li>
<li><p>解释核心容器(应用上下文)模块<br>这是Spring的基本模块，它提供了Spring框架的基本功能。BeanFactory 是所有Spring应用的核心。Spring框架是建立在这个模块之上的，这也使得Spring成为一个容器。</p>
</li>
<li><p>BeanFactory – BeanFactory 实例<br>BeanFactory是工厂模式的一种实现，它使用控制反转将应用的配置和依赖与实际的应用代码分离开来。<br>最常用的BeanFactory实现是XmlBeanFactory类。</p>
</li>
<li><p>XmlBeanFactory<br>最常用的就是org.springframework.beans.factory.xml.XmlBeanFactory，它根据XML文件中定义的内容加载beans。该容器从XML文件中读取配置元数据，并用它来创建一个完备的系统或应用。</p>
</li>
<li><p>解释AOP模块<br>AOP模块用来开发Spring应用程序中具有切面性质的部分。该模块的大部分服务由AOP Aliance提供，这就保证了Spring框架和其他AOP框架之间的互操作性。另外，该模块将元数据编程引入到了Spring。</p>
</li>
<li><p>解释抽象JDBC和DAO模块<br>通过使用抽象JDBC和DAO模块保证了与数据库连接代码的整洁与简单，同时避免了由于未能关闭数据库资源引起的问题。<br>它在多种数据库服务器的错误信息之上提供了一个很重要的异常层。它还利用Spring的AOP模块为Spring应用程序中的对象提供事务管理服务。</p>
</li>
<li><p>解释对象/关系映射集成模块<br>Spring通过提供ORM模块在JDBC的基础上支持对象关系映射工具。这样的支持使得Spring可以集成主流的ORM框架，<br>包括Hibernate, JDO, 及iBATIS SQL Maps。Spring的事务管理可以同时支持以上某种框架和JDBC。</p>
</li>
<li><p>解释web模块<br>Spring的web模块建立在应用上下文(application context)模块之上，提供了一个适合基于web应用程序的上下文环境。<br>该模块还支持了几个面向web的任务，如透明的处理多文件上传请求及将请求参数同业务对象绑定起来。</p>
</li>
<li><p>解释Spring MVC模块<br>Spring提供MVC框架构建web应用程序。Spring可以很轻松的同其他MVC框架结合，<br>但Spring的MVC是个更好的选择，因为它通过控制反转将控制逻辑和业务对象完全分离开来。</p>
</li>
<li><p>Spring IoC容器是什么？<br>Spring IOC负责创建对象、管理对象(通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期。</p>
</li>
<li><p>IOC有什么优点？<br>IOC或依赖注入减少了应用程序的代码量。它使得应用程序的测试很简单，因为在单元测试中不再需要单例或JNDI查找机制。<br>简单的实现以及较少的干扰机制使得低耦合得以实现。IOC容器支持勤性单例及延迟加载服务。</p>
</li>
<li><p>应用上下文是如何实现的？<br>FileSystemXmlApplicationContext 容器加载XML文件中beans的定义。XML Bean配置文件的完整路径必须传递给构造器。<br>FileSystemXmlApplicationContext 容器也加载XML文件中beans的定义。注意，你需要正确的设置CLASSPATH，因为该容器会在CLASSPATH中查看bean的XML配置文件。<br>WebXmlApplicationContext：该容器加载xml文件，这些文件定义了web应用中所有的beans。</p>
</li>
<li><p>Bean Factory和ApplicationContext有什么区别？<br>ApplicationContext提供了一种解决文档信息的方法，一种加载文件资源的方式(如图片)，他们可以向监听他们的beans发送消息。<br>另外，容器或者容器中beans的操作，这些必须以bean工厂的编程方式处理的操作可以在应用上下文中以声明的方式处理。<br>应用上下文实现了MessageSource，该接口用于获取本地消息，实际的实现是可选的。</p>
</li>
<li><p>有哪些不同类型的IOC(依赖注入)？<br>构造器依赖注入：构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。<br>Setter方法依赖注入：首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用bean中的setter方法完成Setter方法依赖注入。</p>
</li>
<li><p>你推荐哪种依赖注入？构造器依赖注入还是Setter方法依赖注入？<br>你可以同时使用两种方式的依赖注入，最好的选择是使用构造器参数实现强制依赖注入，使用setter方法实现可选的依赖关系。</p>
</li>
<li><p>什么是Spring Beans？<br>Spring Beans是构成Spring应用核心的Java对象。这些对象由Spring IOC容器实例化、组装、管理。<br>这些对象通过容器中配置的元数据创建，例如，使用XML文件中定义的创建。<br>在Spring中创建的beans都是单例的beans。在bean标签中有一个属性为”singleton”,如果设为true，该bean是单例的，<br>如果设为false，该bean是原型bean。Singleton属性默认设置为true。因此，spring框架中所有的bean都默认为单例bean。</p>
</li>
<li><p>Spring Bean中定义了什么内容？<br>Spring Bean中定义了所有的配置元数据，这些配置信息告知容器如何创建它，它的生命周期是什么以及它的依赖关系。</p>
</li>
<li><p>你如何定义bean的作用域？<br>在Spring中创建一个bean的时候，我们可以声明它的作用域。只需要在bean定义的时候通过’scope’属性定义即可。<br>例如，当Spring需要产生每次一个新的bean实例时，应该声明bean的scope属性为prototype。如果每次你希望Spring返回一个实例，应该声明bean的scope属性为singleton。</p>
</li>
<li><p>说一下Spring中支持的bean作用域<br>Spring框架支持如下五种不同的作用域：<br>singleton：在Spring IOC容器中仅存在一个Bean实例，Bean以单实例的方式存在。<br>prototype：一个bean可以定义多个实例。<br>request：每次HTTP请求都会创建一个新的Bean。该作用域仅适用于WebApplicationContext环境。<br>session：一个HTTP Session定义一个Bean。该作用域仅适用于WebApplicationContext环境.<br>globalSession：同一个全局HTTP Session定义一个Bean。该作用域同样仅适用于WebApplicationContext环境.<br>bean默认的scope属性是’singleton‘。</p>
</li>
<li><p>Spring框架中单例beans是线程安全的吗？<br>不是，Spring框架中的单例beans不是线程安全的。</p>
</li>
<li><p>解释Spring框架中bean的生命周期<br>Spring容器读取XML文件中bean的定义并实例化bean。<br>Spring根据bean的定义设置属性值。<br>如果该Bean实现了BeanNameAware接口，Spring将bean的id传递给setBeanName()方法。<br>如果该Bean实现了BeanFactoryAware接口，Spring将beanfactory传递给setBeanFactory()方法。<br>如果任何bean BeanPostProcessors 和该bean相关，Spring调用postProcessBeforeInitialization()方法。<br>如果该Bean实现了InitializingBean接口，调用Bean中的afterPropertiesSet方法。如果bean有初始化函数声明，调用相应的初始化方法。<br>如果任何bean BeanPostProcessors 和该bean相关，调用postProcessAfterInitialization()方法。<br>如果该bean实现了DisposableBean，调用destroy()方法。</p>
</li>
<li><p>哪些是最重要的bean生命周期方法？能重写它们吗？<br>有两个重要的bean生命周期方法。第一个是setup方法，该方法在容器加载bean的时候被调用。第二个是teardown方法，该方法在bean从容器中移除的时候调用。<br>bean标签有两个重要的属性(init-method 和 destroy-method)，你可以通过这两个属性定义自己的初始化方法和析构方法。Spring也有相应的注解：@PostConstruct 和 @PreDestroy。</p>
</li>
<li><p>什么是Spring的内部bean？<br>当一个bean被用作另一个bean的属性时，这个bean可以被声明为内部bean。在基于XML的配置元数据中，<br>可以通过把元素定义在 或元素内部实现定义内部bean。内部bean总是匿名的并且它们的scope总是prototype。</p>
</li>
<li><p>如何在Spring中注入Java集合类？<br>Spring提供如下几种类型的集合配置元素：<br>list元素用来注入一系列的值，允许有相同的值。<br>set元素用来注入一些列的值，不允许有相同的值。<br>map用来注入一组”键-值”对，键、值可以是任何类型的。<br>props也可以用来注入一组”键-值”对，这里的键、值都字符串类型。</p>
</li>
<li><p>什么是bean wiring？<br>Wiring，或者说bean Wiring是指beans在Spring容器中结合在一起的情况。当装配bean的时候，Spring容器需要知道需要哪些beans以及如何使用依赖注入将它们结合起来。</p>
</li>
<li><p>什么是bean自动装配？<br>Spring容器可以自动配置相互协作beans之间的关联关系。这意味着Spring可以自动配置一个bean和其他协作bean之间的关系，通过检查BeanFactory 的内容里没有使用和&lt; property&gt;元素。</p>
</li>
<li><p>解释自动装配的各种模式？<br>自动装配提供五种不同的模式供Spring容器用来自动装配beans之间的依赖注入:<br>no：默认的方式是不进行自动装配，通过手工设置ref 属性来进行装配bean。<br>byName：通过参数名自动装配，Spring容器查找beans的属性，这些beans在XML配置文件中被设置为byName。之后容器试图匹配、装配和该bean的属性具有相同名字的bean。<br>byType：通过参数的数据类型自动自动装配，Spring容器查找beans的属性，这些beans在XML配置文件中被设置为byType。<br>  之后容器试图匹配和装配和该bean的属性类型一样的bean。如果有多个bean符合条件，则抛出错误。<br>constructor：这个同byType类似，不过是应用于构造函数的参数。如果在BeanFactory中不是恰好有一个bean与构造函数参数相同类型，则抛出一个严重的错误。<br>autodetect：如果有默认的构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</p>
</li>
<li><p>自动装配有哪些局限性？<br>自动装配有如下局限性：<br>重写：你仍然需要使用 和&lt; property&gt;设置指明依赖，这意味着总要重写自动装配。<br>原生数据类型:你不能自动装配简单的属性，如原生类型、字符串和类。<br>模糊特性：自动装配总是没有自定义装配精确，因此，如果可能尽量使用自定义装配。</p>
</li>
<li><p>你可以在Spring中注入null或空字符串吗？<br>完全可以。<br>Spring注解</p>
</li>
<li><p>什么是Spring基于Java的配置？给出一些注解的例子<br>基于Java的配置允许你使用Java的注解进行Spring的大部分配置而非通过传统的XML文件配置。<br>以注解@Configuration为例，它用来标记类，说明作为beans的定义，可以被Spring IOC容器使用。<br>另一个例子是@Bean注解，它表示该方法定义的Bean要被注册进Spring应用上下文中。</p>
</li>
<li><p>什么是基于注解的容器配置?<br>另外一种替代XML配置的方式为基于注解的配置，这种方式通过字节元数据装配组件而非使用尖括号声明。<br>开发人员将直接在类中进行配置，通过注解标记相关的类、方法或字段声明，而不再使用XML描述bean之间的连线关系。</p>
</li>
<li><p>@Required 注解<br>@Required表明bean的属性必须在配置时设置，可以在bean的定义中明确指定也可通过自动装配设置。<br>如果bean的属性未设置，则抛出BeanInitializationException异常。</p>
</li>
<li><p>@Autowired 注解<br>@Autowired 注解提供更加精细的控制，包括自动装配在何处完成以及如何完成。<br>它可以像@Required一样自动装配setter方法、构造器、属性或者具有任意名称和/或多个参数的PN方法。</p>
</li>
<li><p>@Qualifier 注解<br>当有多个相同类型的bean而只有其中的一个需要自动装配时，将@Qualifier 注解和@Autowire 注解结合使用消除这种混淆，指明需要装配的bean。</p>
</li>
<li><p>Spring对DAO的支持<br>Spring对数据访问对象(DAO)的支持旨在使它可以与数据访问技术(如 JDBC, Hibernate 及JDO)方便的结合起来工作。<br>这使得我们可以很容易在的不同的持久层技术间切换，编码时也无需担心会抛出特定技术的异常。</p>
</li>
<li><p>Spring支持的ORM<br>Spring支持以下ORM：<br>Hibernate<br>MyBatis<br>JPA (Java -Persistence API)<br>TopLink<br>JDO (Java Data Objects)<br>OJB</p>
</li>
<li><p>Spring支持的事务管理类型<br>Spring支持如下两种方式的事务管理：<br>编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。<br>声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。</p>
</li>
<li><p>Spring框架的事务管理有哪些优点？<br>它为不同的事务API(如JTA, JDBC, Hibernate, JPA, 和JDO)提供了统一的编程模型。<br>它为编程式事务管理提供了一个简单的API而非一系列复杂的事务API(如JTA).<br>它支持声明式事务管理。<br>它可以和Spring 的多种数据访问技术很好的融合。</p>
</li>
<li><p>你更推荐那种类型的事务管理？<br>许多Spring框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。<br>声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理(这种方式允许你通过代码控制业务)。</p>
</li>
<li><p>解释AOP<br>面向切面编程,或AOP允许程序员模块化横向业务逻辑，或定义核心部分的功能，例如日志管理和事务管理。</p>
</li>
<li><p>在Spring AOP中concern和 cross-cutting concern的区别是什么？<br>Concern(核心逻辑)：表示在应用程序中一个模块的行为。Concern可以定义为我们想要实现的功能。<br>Cross-cutting concern(横向的通用逻辑)：指的是整个应用程序都会用到的功能，它影响整个应用程序。<br>例如，日志管理（Logging）、安全管理（Security）以及数据交互是应用程序的每个模块都要涉及到的，因此这些都属于Cross-cutting concern。</p>
</li>
<li><p>连接点(Join point)<br>连接点代表应用程序中插入AOP切面的地点。它实际上是Spring AOP框架在应用程序中执行动作的地点。</p>
</li>
<li><p>通知(Advice)<br>通知表示在方法执行前后需要执行的动作。实际上它是Spring AOP框架在程序执行过程中触发的一些代码。<br>Spring切面可以执行一下五种类型的通知:<br>before(前置通知)：在一个方法之前执行的通知。<br>after(最终通知)：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。<br>after-returning(后置通知)：在某连接点正常完成后执行的通知。<br>after-throwing(异常通知)：在方法抛出异常退出时执行的通知。<br>around(环绕通知)：在方法调用前后触发的通知。</p>
</li>
<li><p>有几种不同类型的自动代理？<br>BeanNameAutoProxyCreator：bean名称自动代理创建器<br>DefaultAdvisorAutoProxyCreator：默认通知者自动代理创建器<br>Metadata autoproxying：元数据自动代理</p>
</li>
<li><p>什么是织入？什么是织入应用的不同点？<br>织入是将切面和其他应用类型或对象连接起来创建一个通知对象的过程。织入可以在编译、加载或运行时完成。</p>
</li>
</ul>
<ul>
<li><p>什么是Spring的MVC框架？<br>Spring提供了一个功能齐全的MVC框架用于构建Web应用程序。Spring框架可以很容易的和其他的MVC框架融合(如Struts)，<br>该框架使用控制反转(IOC)将控制器逻辑和业务对象分离开来。它也允许以声明的方式绑定请求参数到业务对象上。</p>
</li>
<li><p>DispatcherServlet<br>Spring的MVC框架围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。</p>
</li>
<li><p>WebApplicationContext<br>WebApplicationContext继承了ApplicationContext，并添加了一些web应用程序需要的功能。<br>和普通的ApplicationContext 不同，WebApplicationContext可以用来处理主题样式，它也知道如何找到相应的servlet。</p>
</li>
<li><p>什么是Spring MVC框架的控制器？<br>控制器提供对应用程序行为的访问，通常通过服务接口实现。控制器解析用户的输入，并将其转换为一个由视图呈现给用户的模型。<br>Spring 通过一种极其抽象的方式实现控制器，它允许用户创建多种类型的控制器。</p>
</li>
<li><p>@Controller annotation<br>@Controller注解表示该类扮演控制器的角色。Spring不需要继承任何控制器基类或应用Servlet API。</p>
</li>
<li><p>@RequestMapping annotation<br>@RequestMapping注解用于将URL映射到任何一个类或者一个特定的处理方法上</p>
</li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Spring/" rel="tag"># Spring</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/06/Collection/" rel="next" title="Collection">
                <i class="fa fa-chevron-left"></i> Collection
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/08/idea-Setting/" rel="prev" title="idea-Setting">
                idea-Setting <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">王靖尧</p>
              <div class="site-description motion-element" itemprop="description">一晃而过的时间，都做了些什么</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">104</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">34</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#AOP概述"><span class="nav-number">1.</span> <span class="nav-text">AOP概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP的实现方式"><span class="nav-number">1.1.</span> <span class="nav-text">AOP的实现方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用场景"><span class="nav-number">1.2.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP相关概念"><span class="nav-number">1.3.</span> <span class="nav-text">AOP相关概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StringAOP组件"><span class="nav-number">1.4.</span> <span class="nav-text">StringAOP组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何使用AOP"><span class="nav-number">1.5.</span> <span class="nav-text">如何使用AOP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringAOP代理对象的生成"><span class="nav-number">1.6.</span> <span class="nav-text">SpringAOP代理对象的生成</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IOC和DI"><span class="nav-number">2.</span> <span class="nav-text">IOC和DI</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IOC和DI第一种解释"><span class="nav-number">2.1.</span> <span class="nav-text">IOC和DI第一种解释</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IOC能做什么"><span class="nav-number">2.1.1.</span> <span class="nav-text">IOC能做什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IOC和DI-1"><span class="nav-number">2.1.2.</span> <span class="nav-text">IOC和DI</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IOC和DI第二种解释"><span class="nav-number">2.2.</span> <span class="nav-text">IOC和DI第二种解释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IOC和DI第三种解释"><span class="nav-number">2.3.</span> <span class="nav-text">IOC和DI第三种解释</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一些问题"><span class="nav-number">3.</span> <span class="nav-text">一些问题</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王靖尧</span>

  

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>




  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  



  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/algolia-search.js?v=7.1.0"></script>



  
  
  <script>
    
    function addCount(Counter) {
      var $visitors = $('.leancloud_visitors');
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', '/classes/Counter/' + counter.objectId, JSON.stringify({ time: { '__op': 'Increment', 'amount': 1 } }))
            
              .done(function() {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.time + 1);
              })
            
              .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
              })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1 }))
                .done(function() {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function() {
                  console.log('Failed to create');
                });
            
          }
        })
        .fail(function ({ responseJSON }) {
          console.log('LeanCloud Counter Error: ' + responseJSON.code + ' ' + responseJSON.error);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'DFKH5YVSHsNt0wDOVISahMVx-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: 'https://' + api_server + '/1.1' + url,
              headers: {
                'X-LC-Id': 'DFKH5YVSHsNt0wDOVISahMVx-gzGzoHsz',
                'X-LC-Key': 'ILHc2Y6O0p9xfqi3iAWMwnuv',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
          
            addCount(Counter);
          
        });
    });
  </script>



  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
