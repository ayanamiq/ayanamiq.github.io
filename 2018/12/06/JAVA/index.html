<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: 'UJCQ3PDF0F',
      apiKey: 'a3d4ab7cd60617bd0d524169bb08d56d',
      indexName: 'dev_ayanamiq',
      hits: {"per_page":10},
      labels: {"input_placeholder":"输入关键字","hits_empty":"没有找到关于 ${query} 的文章","hits_stats":"${hits} 相关记录，共耗时 ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="this：表示当前函数，所属对象的引用super：用于调用父类方法 概念staticstatic可修饰属性、方法和代码块static 修饰属性：是一个类的共享变量，属于整个类，在不实例化对象的情况下就能访问。static 修饰方法：不需要实例化对象，可以使用类名调用，静态方法不能访问非静态成员，包括成员的方法和变量。因为此时用类调用，没有对象的概念，this是不可用的。static 修饰代码块：一">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA">
<meta property="og:url" content="https://jingyao066.gitee.io/2018/12/06/JAVA/index.html">
<meta property="og:site_name" content="王靖尧的博客">
<meta property="og:description" content="this：表示当前函数，所属对象的引用super：用于调用父类方法 概念staticstatic可修饰属性、方法和代码块static 修饰属性：是一个类的共享变量，属于整个类，在不实例化对象的情况下就能访问。static 修饰方法：不需要实例化对象，可以使用类名调用，静态方法不能访问非静态成员，包括成员的方法和变量。因为此时用类调用，没有对象的概念，this是不可用的。static 修饰代码块：一">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://github.com/ayanamiq/images/blob/master/token.png?raw=true">
<meta property="og:updated_time" content="2020-04-08T10:18:11.066Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JAVA">
<meta name="twitter:description" content="this：表示当前函数，所属对象的引用super：用于调用父类方法 概念staticstatic可修饰属性、方法和代码块static 修饰属性：是一个类的共享变量，属于整个类，在不实例化对象的情况下就能访问。static 修饰方法：不需要实例化对象，可以使用类名调用，静态方法不能访问非静态成员，包括成员的方法和变量。因为此时用类调用，没有对象的概念，this是不可用的。static 修饰代码块：一">
<meta name="twitter:image" content="https://github.com/ayanamiq/images/blob/master/token.png?raw=true">





  
  
  <link rel="canonical" href="https://jingyao066.gitee.io/2018/12/06/JAVA/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>JAVA | 王靖尧的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">王靖尧的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jingyao066.gitee.io/2018/12/06/JAVA/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王靖尧">
      <meta itemprop="description" content="一晃而过的时间，都做了些什么">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王靖尧的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JAVA

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-06 18:18:52" itemprop="dateCreated datePublished" datetime="2018-12-06T18:18:52+08:00">2018-12-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-04-08 18:18:11" itemprop="dateModified" datetime="2020-04-08T18:18:11+08:00">2020-04-08</time>
              
            
          </span>

          

          
            
            
          

          
          
            <span id="/2018/12/06/JAVA/" class="leancloud_visitors" data-flag-title="JAVA">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>this：表示当前函数，所属对象的引用<br>super：用于调用父类方法</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>static可修饰属性、方法和代码块<br>static 修饰属性：是一个类的共享变量，属于整个类，在不实例化对象的情况下就能访问。<br>static 修饰方法：不需要实例化对象，可以使用类名调用，静态方法不能访问非静态成员，包括成员的方法和变量。因为此时用类调用，没有对象的概念，this是不可用的。<br>static 修饰代码块：一般静态代码块用来初始化静态成员。<br>因为静态优先于对象存在，静态方法不可以出现this。<br>非静态函数中可以访问静态成员变量</p>
<p>static关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。<br>公有puclic：公有变量，外部也可以调用的变量<br>私有private：私有变量,只能在对象内部调用，外部调用需要设置get()，set()方法，get用于获取对象的属性，set用于设置对象的属性</p>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>final修饰符可修饰类、属性、方法<br>final 修饰类：此类不可被继承，即final没有子类，这样可以保证用户调用时动作的一致性，防止子类覆盖情况的发生<br>final 修饰变量：此时的属性为常量，常量的地址不可变，但在地址中保存的值(即对象的属性)，是可以改变的<br>final 修饰方法：此方法不可覆盖</p>
<p>问题：final、finally、finalize的区别</p>
<ul>
<li>final，修饰符(关键字)，如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。</li>
<li>finally是在异常处理时提供finally块来执行任何清除操作，不管有没有异常被抛出、捕获，finally块都会被执行。</li>
<li>finalize方法来自于java.lang.Object，用于回收资源。在实际应用中，不要依赖使用该方法回收任何短缺的资源，这是因为很难知道这个方法什么时候被调用。</li>
</ul>
<h2 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h2><p>重载是同一个类中，有两个及以上的方法，拥有相同的方法名，但是参数不同，方法体也不同。<br>系统会根据传入的参数类型和参数个数来判断要用到的方法。</p>
<h2 id="函数的重写"><a href="#函数的重写" class="headerlink" title="函数的重写"></a>函数的重写</h2><p>重写指的是子类方法覆盖父类方法，要求方法名和参数都相同，但修饰符和返回值可能不同，构造方法无法覆盖</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法主要作用是完成对象的初始化工作，能够把定义对象时的参数传递给对象的域</p>
<ul>
<li>构造方法名称必须与类名相同</li>
<li>没有返回类型，也不能定义void，方法前不声明方法类型</li>
<li>一个类可以定义多个构造方法，如在定义类时没有定义构造方法，系统会自动插入一个无参数的默认构造器，这个构造器不执行任何代码</li>
<li>构造方法可以重载</li>
</ul>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。<br>封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。</p>
<p>java中提供四个修饰符来进行对象属性和方法的访问权限控制：<br>private ：类内部可见<br>default ：包内部可见<br>protected ：包内部或子类可见<br>public ：所有可见</p>
<p>好处:</p>
<ul>
<li>通过隐藏对象的属性来保护对象内部的状态。</li>
<li>提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。</li>
<li>禁止对象之间的不良交，互提高模块化。</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是从已有类得到继承信息创建新类的过程。<br>提供继承信息的类被称为父类，得到继承信息的类被称为子类。</p>
<ul>
<li>父类非私有化的属性和方法可以继承到子类</li>
<li>父类的构造方法子类不可以继承，更不存在覆盖</li>
<li>java中不允许多继承，一个类只有一个父类</li>
<li>super()表示调用父类的构造方法，super()和this()一样，必须放在第一行。</li>
<li>this()用于调用本类的构造方法</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态性是指允许不同子类型的对象对同一消息作出不同的响应。<br>多态分为：编译时多态和运行时多态。</p>
<ul>
<li>编译时多态：编译时动态加载(方法的重载)。</li>
<li>运行时多态：一个对象可以有多个类型(子类重写父类方法)，父类引用指向子类对象。</li>
</ul>
<p>运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事</p>
<ul>
<li>方法重写（子类继承父类并重写父类中已有的或抽象的方法）</li>
<li>父类引用指向子类对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为</li>
</ul>
<p>注意：</p>
<ul>
<li>如果子类中重写了父类中的方法，那么在调用这个方法的时候，将会调用子类中的这个方法</li>
<li>变量不能被重写(覆盖)，重写只针对方法，如果在子类中重写了父类中的变量，那么编译会报错</li>
<li>如果继承的子类继承父类的一个方法后加以重载，则该父类引用不能使用重载后的那个方法</li>
</ul>
<p>体现：父类引用指向子类对象<br>前提：要有继承，要有方法重写，父类引用指向子类对象<br>好处：把不同的子类对象都当做父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码。</p>
<p>例: 游戏中有不同的角色，它们都有一个父类，它们做相同动作时表现出来的效果就会不一样，比如跑，魔法师的跑跟战士的跑就不会一样，这就是俩者都覆盖了父类中的跑方法，各自有自己的现实，表现出来多态。如果有一天你想再加个角色，只用再写一个类继承该父类，覆盖其中的跑方法就行了，其他代码不用怎么改，所以可维护性也很好。</p>
<h2 id="接口、抽象类区别"><a href="#接口、抽象类区别" class="headerlink" title="接口、抽象类区别:"></a>接口、抽象类区别:</h2><ul>
<li><p>方法实现：<br>抽象类可以有默认的方法实现，接口完全是抽象的。它根本不存在方法的实现</p>
</li>
<li><p>构造方法：<br>抽象类可以有构造器，接口不能有构造方法。</p>
</li>
<li><p>多继承：<br>子类只能继承一个抽象类(java单继承，子类-&gt;(继承extend)抽象类)，<br>子类可以实现多个接口(子类-&gt;(实现implements)接口)</p>
</li>
<li><p>声明:<br>接口：<code>public inerface Person</code><br>抽象类：<code>abstract class Person</code></p>
</li>
<li><p>访问修饰符：<br>抽象方法可以有public/default等修饰符，接口方法默认修饰符是public，不能用其他修饰</p>
</li>
<li><p>实现：<br>抽象类：子类使用extends关键字来<strong>继承</strong>抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明方法的实现，反之可以按照需要实现方法。<br>接口：子类使用关键字implements来<strong>实现</strong>接口，它需要提供接口中所有声明的方法的实现。</p>
</li>
</ul>
<p>2018/12/18 update：<br>今天在读到Collection的源码时，发现Collection接口继承(extends)了Iterable接口，按照我以前的理解，接口(interface)只能被实现(implements)，不能被继承(extends)。<br>而实际上，java有个说法叫：<br>接口对接口的扩展，严格上不叫继承，即<code>interface extends interface</code>。<br>但是普通的java类是绝对不可以继承(extends)一个接口的。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。<br>内部类是指在一个外部类的内部再定义一个类。内部类作为外部类的一个成员，并且依附于外部类而存在的。<br>内部类的分类：</p>
<ul>
<li>成员内部类：作为外部类的一个成员存在，与外部类的属性、方法并列</li>
<li>局部内部类：在方法中定义的内部类</li>
<li>静态内部类：静态内部类只能访问外部类的静态成员</li>
<li>匿名内部类：通过匿名接口实现，是一种特殊的局部内部类</li>
</ul>
<p>注：所有使用内部类的地方都可以不用内部类，使用内部类可以使程序更加的简洁，便于命名规范和划分层次结构。</p>
<h2 id="正向和反向代理"><a href="#正向和反向代理" class="headerlink" title="正向和反向代理"></a>正向和反向代理</h2><p>正向：代理服务器在客户端(client)那边就是正向代理，正向代理需要客户端配置，客户端是知道自己通过代理方式去访问服务器的，例如：vpn，ssr</p>
<p>反向：代理服务器在原始服务器(server)那边就是反向代理，反向代理，客户端根本就不知道，是服务端配置的。例如：nginx</p>
<h2 id="session和cookie的区别"><a href="#session和cookie的区别" class="headerlink" title="session和cookie的区别"></a>session和cookie的区别</h2><ul>
<li>session保存在服务器，客户端不知道其中信息；cookie保存在客户端，服务器可以知道其中信息</li>
<li>session保存的是对象，cookie保存的是字符串</li>
<li>cookie不安全，考虑安全应当用session</li>
<li>访问量增多会占用服务器性能，考虑到这应当用cookie</li>
</ul>
<h2 id="session的分布式处理"><a href="#session的分布式处理" class="headerlink" title="session的分布式处理"></a>session的分布式处理</h2><p><a href="https://www.cnblogs.com/newP/p/6518918.html" target="_blank" rel="noopener">https://www.cnblogs.com/newP/p/6518918.html</a><br>1.粘性session：<br>负载均衡器设置了粘性Session，用户的每次请求都会转发到同一台服务器上，<br>相当于把用户和服务器黏在了一起<br>缺点：容错性低,如果当前服务器故障，用户被转移到另一台服务器上，session信息会失效<br>实现：nginx通过ip_hash属性即可实现粘性session</p>
<p>2.服务器session复制：<br>任何一个服务器上的session发生改变，该节点会把这个session的所有内容序列化，<br>然后广播给其他节点，不管其他服务器是否需要，以此来实现session同步<br>缺点：降低服务器性能，对网络造成压力<br>实现：tomcat中，server.xml开启tomcat集群功能</p>
<p>3.redis实现session共享<br>4.session入库</p>
<h2 id="jdbc基本流程"><a href="#jdbc基本流程" class="headerlink" title="jdbc基本流程"></a>jdbc基本流程</h2><ol>
<li>加载数据库驱动</li>
<li>获取数据库连接</li>
<li>创建sql对象</li>
<li>执行sql语句</li>
<li>处理ResultSet</li>
<li>释放资源</li>
</ol>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>首先我们了解一下JVM，什么是JVM，Java的虚拟机，java之所以能跨平台就是因为这个东西，<br>你可以理解成一个进程，程序，只不过他的作用是用来跑你的代码的。<br>假如你写了一段代码：Object o=new Object();  运行了起来！</p>
<p>1.首先JVM会启动，你的代码会编译成一个.class文件<br>2.然后被类加载器加载进jvm的内存中，你的类Object加载到方法区中，创建了Object类的class对象到堆中，注意这个不是new出来的对象，而是类的类型对象，每个类只有一个class对象，作为方法区类的数据结构的接口。</p>
<p>jvm创建对象前，会先检查类是否加载，寻找类对应的class对象，若加载好，则为你的对象分配内存，<br>初始化也就是代码:new Object()。<br>上面的流程就是你自己写好的代码扔给jvm去跑，跑完就over了，jvm关闭，你的程序也停止了。<br>为什么要讲这个呢？因为要理解反射必须知道它在什么场景下使用。</p>
<p>想想上面的程序对象是自己new的，程序相当于写死了给jvm去跑。<br>假如一个服务器上突然遇到某个请求要用到某个类，<br>但没加载进jvm，是不是要停下来自己写段代码，new一下，再启动一下服务器？错~~</p>
<p>反射是什么呢？当我们的程序在运行时，<br>需要动态的加载一些类这些类可能之前用不到所以不用加载到jvm。</p>
<p>举个例子我们的项目底层有时是用mysql，有时用oracle，<br>需要动态地根据实际情况加载驱动类，这个时候反射就有用了，<br>假设 com.java.dbtest.myqlConnection，com.java.dbtest.oracleConnection<br>这两个类我们要用，这时候我们的程序就写得比较动态化，<br>通过Class tc = Class.forName(“com.java.dbtest.TestConnection”);<br>通过类的全类名让jvm在服务器中找到并加载这个类，<br>而如果是oracle则传入的参数就变成另一个了。<br>这时候就可以看到反射的好处了，这个动态性就体现出java的特性了！<br>当然这里只是举了反射的一个应用，实际还有其他作用，只是这个例子能更好地理解！</p>
<p>一.概念<br>主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，<br>并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。</p>
<p>程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。<br>所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。<br>反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁</p>
<p>Java反射框架主要提供以下功能：</p>
<p>1.在运行时判断任意一个对象所属的类；<br>2.在运行时构造任意一个类的对象；<br>3.在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；<br>4.在运行时调用任意一个对象的方法<br>重点：是运行时而不是编译时</p>
<p>当我们在使用IDE(如Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。<br>很多框架（比如Spring）都是配置化的（比如通过XML文件配置JavaBean,Action之类的），<br>为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象.</p>
<p>二，反射机制的作用：<br>    1.反编译：.class–&gt;.java<br>    2.通过反射机制访问java对象的属性，方法，构造方法等；</p>
<p>三，在这里先看一下sun为我们提供了那些反射机制中的类：<br>    java.lang.Class;<br>    java.lang.reflect.Constructor;<br>    java.lang.reflect.Field;<br>    java.lang.reflect.Method;<br>    java.lang.reflect.Modifier;<br>    很多反射中的方法，属性等操作我们可以从这四个类中查询。</p>
<p>四.具体功能实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.反射机制获取类有三种方法，我们来获取Employee类型</span><br><span class="line"><span class="comment">//第一种方式：  (注意要包名+类名)</span></span><br><span class="line">Class c1 = Class.forName(<span class="string">"demo.Employee"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方式：</span></span><br><span class="line"><span class="comment">//java中每个类型都有class属性.</span></span><br><span class="line">Class c2 = Employee.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种方式：</span></span><br><span class="line"><span class="comment">//java语言中任何一个java对象都有getClass 方法</span></span><br><span class="line">Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">Class c3 = e.getClass(); <span class="comment">//c3是运行时类 (e的运行时类是Employee)</span></span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>.创建对象：获取类以后我们来创建它的对象，利用newInstance：</span><br><span class="line">Class c =Class.forName(<span class="string">"demo.Employee"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建此Class 对象所表示的类的一个新实例</span></span><br><span class="line">Object o = c.newInstance(); <span class="comment">//调用了Employee的无参数构造方法</span></span><br><span class="line">    </span><br><span class="line"><span class="number">3</span>.获取属性：分为所有的属性和指定的属性：</span><br><span class="line">b，获取特定的属性，对比着传统的方法来学习：</span><br><span class="line"><span class="comment">//Student类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传统方法：</span></span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">s.age = <span class="number">12</span>; <span class="comment">//set </span></span><br><span class="line">        System.out.println(s.age);<span class="comment">//get </span></span><br><span class="line"><span class="comment">//但是无法获取private的属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//反射方法</span></span><br><span class="line">Class&lt;?&gt; c1 = Class.forName(<span class="string">"reflect.Student"</span>);<span class="comment">//取得对象</span></span><br><span class="line">Object o = c1.newInstance();<span class="comment">//实例化对象 </span></span><br><span class="line">Field nameF = c1.getDeclaredField(<span class="string">"name"</span>);<span class="comment">//获取name属性</span></span><br><span class="line">        nameF.setAccessible(<span class="keyword">true</span>); <span class="comment">//使用反射机制可以打破封装性，导致了java对象的属性不安全。  </span></span><br><span class="line">        nameF.set(o,<span class="string">"钢铁侠"</span>);<span class="comment">//给属性赋值</span></span><br><span class="line">        System.out.println(nameF.get(o));</span><br><span class="line">            </span><br><span class="line"><span class="number">4</span>，获取方法，和构造方法，不再详细描述，只来看一下关键字：</span><br><span class="line">方法和关键字:</span><br><span class="line">getDeclaredMethods():获取所有的方法</span><br><span class="line">getReturnType():获得方法的放回类型</span><br><span class="line">getParameterTypes():获得方法的传入参数类型</span><br><span class="line">getDeclaredMethod(<span class="string">"方法名"</span>,参数类型.class,……):获得特定的方法</span><br><span class="line">        构造方法关键字</span><br><span class="line">getDeclaredConstructors():获取所有的构造方法</span><br><span class="line">getDeclaredConstructor(参数类型.class,……):获取特定的构造方法</span><br><span class="line"></span><br><span class="line">父类和父接口:</span><br><span class="line">getSuperclass():获取某类的父类</span><br><span class="line">getInterfaces():获取某类实现的接口</span><br></pre></td></tr></table></figure></p>
<p>这样我们就可以获得类的各种内容，进行了反编译。<br>对于JAVA这种先编译再运行的语言来说，反射机制可以使代码更加灵活，更加容易实现面向对象。</p>
<p>最后:<br>JAVA反射的再次学习，灵活的运用它，能够使我们的代码更加灵活，但是它也有它的缺点，<br>就是运用它会使我们的软件的性能降低，复杂度增加，所以还要我们慎重的使用它。<br><a href="https://www.sczyh30.com/posts/Java/java-reflection-1/" target="_blank" rel="noopener">参考地址</a></p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。<br>this的用法在java中大体可以分为3种：<br>1.普通的直接引用<br>这种就不用讲了，this相当于是指向当前对象本身。</p>
<p>2.形参与成员名字重名，用this来区分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    private int age = 10;</span><br><span class="line">    public Person()&#123;</span><br><span class="line">        System.out.println(&quot;初始化年龄：&quot;+age);</span><br><span class="line">    &#125;</span><br><span class="line">    public int GetAge(int age)&#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        return this.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class test1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person Harry = new Person();</span><br><span class="line">        System.out.println(&quot;Harry&apos;s age is &quot;+Harry.GetAge(12));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">初始化年龄：10</span><br><span class="line">Harry&apos;s age is 12</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里age是GetAge成员方法的形参，this.age是Person类的成员变量。</p>
<p>3.引用构造函数<br>这个和super放在一起讲，见下面。</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。<br>super也有三种用法：<br>1.普通的直接引用<br>与this类似，super相当于是指向当前对象的父类，这样就可以用super.xxx来引用父类的成员。</p>
<p>2.子类中的成员变量或方法与父类中的成员变量或方法同名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Country &#123;</span><br><span class="line">    String name;</span><br><span class="line">    void value() &#123;</span><br><span class="line">       name = &quot;China&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">class City extends Country &#123;</span><br><span class="line">    String name;</span><br><span class="line">    void value() &#123;</span><br><span class="line">    name = &quot;Shanghai&quot;;</span><br><span class="line">    super.value();      //调用父类的方法</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(super.name);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       City c=new City();</span><br><span class="line">       c.value();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Shanghai</span><br><span class="line">China</span><br></pre></td></tr></table></figure>
<p>可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法value()，只调用父类变量name的话，则父类name值为默认值null。</p>
<p>3.引用构造函数<br>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。<br>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123; </span><br><span class="line">    public static void prt(String s) &#123; </span><br><span class="line">       System.out.println(s); </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">    Person() &#123; </span><br><span class="line">       prt(&quot;父类·无参数构造方法： &quot;+&quot;A Person.&quot;); </span><br><span class="line">    &#125;//构造方法(1) </span><br><span class="line">    </span><br><span class="line">    Person(String name) &#123; </span><br><span class="line">       prt(&quot;父类·含一个参数的构造方法： &quot;+&quot;A person&apos;s name is &quot; + name); </span><br><span class="line">    &#125;//构造方法(2) </span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">public class Chinese extends Person &#123; </span><br><span class="line">    Chinese() &#123; </span><br><span class="line">       super(); // 调用父类构造方法（1） </span><br><span class="line">       prt(&quot;子类·调用父类”无参数构造方法“： &quot;+&quot;A chinese coder.&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    Chinese(String name) &#123; </span><br><span class="line">       super(name);// 调用父类具有相同形参的构造方法（2） </span><br><span class="line">       prt(&quot;子类·调用父类”含一个参数的构造方法“： &quot;+&quot;his name is &quot; + name); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    Chinese(String name, int age) &#123; </span><br><span class="line">       this(name);// 调用具有相同形参的构造方法（3） </span><br><span class="line">       prt(&quot;子类：调用子类具有相同形参的构造方法：his age is &quot; + age); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123; </span><br><span class="line">       Chinese cn = new Chinese(); </span><br><span class="line">       cn = new Chinese(&quot;codersai&quot;); </span><br><span class="line">       cn = new Chinese(&quot;codersai&quot;, 18); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">父类·无参数构造方法： A Person.</span><br><span class="line">子类·调用父类”无参数构造方法“： A chinese coder.</span><br><span class="line">父类·含一个参数的构造方法： A person&apos;s name is codersai</span><br><span class="line">子类·调用父类”含一个参数的构造方法“： his name is codersai</span><br><span class="line">父类·含一个参数的构造方法： A person&apos;s name is codersai</span><br><span class="line">子类·调用父类”含一个参数的构造方法“： his name is codersai</span><br><span class="line">子类：调用子类具有相同形参的构造方法：his age is 18</span><br></pre></td></tr></table></figure></p>
<p>从本例可以看到，可以用super和this分别调用父类的构造方法和本类中其他形式的构造方法。<br>例子中Chinese类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。</p>
<h2 id="super和this的异同"><a href="#super和this的异同" class="headerlink" title="super和this的异同"></a>super和this的异同</h2><p>super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句）<br>this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）<br>super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名    super.成员函数据名（实参）<br>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）<br>调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。<br>super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。<br>super()和this()均需放在构造方法内第一行。<br>尽管可以用this调用一个构造器，但却不能调用两个。<br>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。<br>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。<br>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言？"><a href="#什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言？" class="headerlink" title="什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言？"></a>什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言？</h2><p>Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。<br>Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。<br>Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p>
<h2 id="JDK和JRE的区别是什么？"><a href="#JDK和JRE的区别是什么？" class="headerlink" title="JDK和JRE的区别是什么？"></a>JDK和JRE的区别是什么？</h2><p>JRE:Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。<br>JDK:Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。</p>
<h2 id="是否可以在static环境中访问非static变量？-不可以"><a href="#是否可以在static环境中访问非static变量？-不可以" class="headerlink" title="是否可以在static环境中访问非static变量？(不可以)"></a>是否可以在static环境中访问非static变量？(不可以)</h2><p>static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。<br>如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p>
<h2 id="Java支持的数据类型有哪些？什么是自动拆装箱？"><a href="#Java支持的数据类型有哪些？什么是自动拆装箱？" class="headerlink" title="Java支持的数据类型有哪些？什么是自动拆装箱？"></a>Java支持的数据类型有哪些？什么是自动拆装箱？</h2><p>Java语言支持的8中基本数据类型是：<br>byte,short,int,long,float,double,boolean,char<br>自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。<br>Integer  a=1;//这就是一个自动装箱，如果没有自动装箱的话，需要这样Integer  a=new Integer(1)<br>int b=a;//这就是一个自动拆箱，如果没有自动拆箱的话，需要这样：int b=a.intValue()<br>自动装箱和自动拆箱是简化了基本数据类型和相对应对象的转化步骤</p>
<h2 id="什么是值传递和引用传递？"><a href="#什么是值传递和引用传递？" class="headerlink" title="什么是值传递和引用传递？"></a>什么是值传递和引用传递？</h2><p>对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。<br>对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。</p>
<h2 id="进程和线程的区别是什么？"><a href="#进程和线程的区别是什么？" class="headerlink" title="进程和线程的区别是什么？"></a>进程和线程的区别是什么？</h2><p>进程是执行着的应用程序，而线程是进程内部的一个执行序列<br>一个进程可以有多个线程。线程又叫做轻量级进程。</p>
<h2 id="什么是死锁-deadlock-？"><a href="#什么是死锁-deadlock-？" class="headerlink" title="什么是死锁(deadlock)？"></a>什么是死锁(deadlock)？</h2><p>两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。</p>
<h2 id="如何确保N个线程可以访问N个资源同时又不导致死锁？"><a href="#如何确保N个线程可以访问N个资源同时又不导致死锁？" class="headerlink" title="如何确保N个线程可以访问N个资源同时又不导致死锁？"></a>如何确保N个线程可以访问N个资源同时又不导致死锁？</h2><p>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</p>
<h2 id="什么是迭代器-Iterator-？"><a href="#什么是迭代器-Iterator-？" class="headerlink" title="什么是迭代器(Iterator)？"></a>什么是迭代器(Iterator)？</h2><p>Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。</p>
<h2 id="Iterator和ListIterator的区别是什么？"><a href="#Iterator和ListIterator的区别是什么？" class="headerlink" title="Iterator和ListIterator的区别是什么？"></a>Iterator和ListIterator的区别是什么？</h2><p>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。<br>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。<br>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p>
<h2 id="Java中的HashMap的工作原理是什么？"><a href="#Java中的HashMap的工作原理是什么？" class="headerlink" title="Java中的HashMap的工作原理是什么？"></a>Java中的HashMap的工作原理是什么？</h2><p>Java中的HashMap是以键值对(key-value)的形式存储元素的。<br>HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。<br>当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。<br>如果key已经存在了，value会被更新成新值。<br>HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。</p>
<h2 id="Java中HashMap遍历的四种方式"><a href="#Java中HashMap遍历的四种方式" class="headerlink" title="Java中HashMap遍历的四种方式"></a>Java中HashMap遍历的四种方式</h2><p>1.entrySet().iterator()<br>效率高,以后一定要使用此种方式！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map map = new HashMap();</span><br><span class="line">　　Iterator iter = map.entrySet().iterator();</span><br><span class="line">　　while (iter.hasNext()) &#123;</span><br><span class="line">　　Map.Entry entry = (Map.Entry) iter.next();</span><br><span class="line">　　Object key = entry.getKey();</span><br><span class="line">　　Object val = entry.getValue();</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.keySet().iterator()<br>效率低,以后尽量少使用！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map map = new HashMap();</span><br><span class="line">　　Iterator iter = map.keySet().iterator();</span><br><span class="line">　　while (iter.hasNext()) &#123;</span><br><span class="line">　　Object key = iter.next();</span><br><span class="line">　　Object val = map.get(key);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.entrySet遍历key和value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(Map.Entry&lt;String, String&gt; entry: map.entrySet())&#123;</span><br><span class="line">    Object key = entry.getKey();</span><br><span class="line">　Object val = entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用Array而不是ArrayList？"><a href="#数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用Array而不是ArrayList？" class="headerlink" title="数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？"></a>数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？</h2><p>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。<br>Array大小是固定的，ArrayList的大小是动态变化的。</p>
<h2 id="ArrayList和LinkedList有什么区别？"><a href="#ArrayList和LinkedList有什么区别？" class="headerlink" title="ArrayList和LinkedList有什么区别？"></a>ArrayList和LinkedList有什么区别？</h2><p>ArrayList和LinkedList都实现了List接口，他们有以下的不同点：<br>1.ArrayList数组实现，增删慢(增删元素时，需要重新计算大小或更新数组索引)，查找快<br>LinkedList链表实现，增删快，查找慢。<br>2.LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</p>
<h2 id="System-gc-和Runtime-gc-会做什么事情？"><a href="#System-gc-和Runtime-gc-会做什么事情？" class="headerlink" title="System.gc()和Runtime.gc()会做什么事情？"></a>System.gc()和Runtime.gc()会做什么事情？</h2><p>这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。</p>
<h2 id="堆栈区别？"><a href="#堆栈区别？" class="headerlink" title="堆栈区别？"></a>堆栈区别？</h2><p>1.栈区:编译器自动分配,存放函数的参数值，局部变量等<br>2.2.堆区:手动分配释放</p>
<h2 id="什么是线程安全和不安全？"><a href="#什么是线程安全和不安全？" class="headerlink" title="什么是线程安全和不安全？"></a>什么是线程安全和不安全？</h2><p>1.线程安全:a,b线程同时操作一个变量,a操作的时候，b不能操作,相当于单线程<br>2.线程不安全:a,b线程同时操作一个变量,可同时操作</p>
<h2 id="同步和异步？"><a href="#同步和异步？" class="headerlink" title="同步和异步？"></a>同步和异步？</h2><p>同步:发送一个请求,等待返回结果，然后再发送下一个请求<br>特点:需要等待,避免出现死锁，脏读数据的发生<br>异步:发送一个请求,不等待返回,随时可以再发送下一个请求<br>特点:无需等待,提高效率，但是会出现死锁，脏读数据</p>
<h2 id="九种基本数据类型的大小，以及他们的封装类-一个字节是8位"><a href="#九种基本数据类型的大小，以及他们的封装类-一个字节是8位" class="headerlink" title="九种基本数据类型的大小，以及他们的封装类(一个字节是8位)"></a>九种基本数据类型的大小，以及他们的封装类(一个字节是8位)</h2><table>
<thead>
<tr>
<th>基本类型</th>
<th>大小(字节)</th>
<th>默认值</th>
<th>封装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>1</td>
<td>(byte)0</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>(short)0</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>0</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>0L</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>0.0f</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>0.0d</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>-</td>
<td>false</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
<td>\u0000(null)</td>
<td>Character</td>
</tr>
<tr>
<td>void</td>
<td>-</td>
<td>-</td>
<td>Void</td>
</tr>
</tbody>
</table>
<h2 id="equals、-、hashcode-区别"><a href="#equals、-、hashcode-区别" class="headerlink" title="equals、==、hashcode  区别"></a>equals、==、hashcode  区别</h2><p>1.基本数据类型<br>byte/int/double/boolean等，用==，比较的是他们的值<br>2.引用类型(对象)<br>用==比较的是内存地址，同一个new出来的对象，为true，反之为false<br>(对象是存放在堆中的，栈中存放的是对象的引用(地址),由此可见==比较的是栈中的值<br>如果要比较堆中的对象是否相同，要重写equals方法)</p>
<p>equals:比较对象的内容(就是最表面的值)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;1&quot;;</span><br><span class="line">String b = &quot;1&quot;;</span><br><span class="line">String c = new String(&quot;1&quot;);</span><br><span class="line">System.out.println(a==b);//true,是一块内存地址</span><br><span class="line">System.out.println(a==c);//false,不是一块内存地址</span><br><span class="line">System.out.println(a.equals(b));//true,比较的是值</span><br></pre></td></tr></table></figure>
<h2 id="Java的四种引用，强弱软虚，用到的场景"><a href="#Java的四种引用，强弱软虚，用到的场景" class="headerlink" title="Java的四种引用，强弱软虚，用到的场景"></a>Java的四种引用，强弱软虚，用到的场景</h2><p>1.强引用:如果一个对象具有强引用，那垃圾回收器绝不会回收它<br>Object o=new Object();   //  强引用<br>2.软引用:内存够，不会被回收(垃圾回收器),反之会被回收.<br>引用可用来实现内存敏感的高速缓存。<br>3.弱引用:垃圾回收器一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存<br>4.虚引用：任何时候都可能被垃圾回收器回收</p>
<h2 id="Hashcode的作用"><a href="#Hashcode的作用" class="headerlink" title="Hashcode的作用"></a>Hashcode的作用</h2><p>1.生成一个hash码,表示对象存储的物理地址<br>2.可以用来用来鉴定2个对象是否相等</p>
<h2 id="String、StringBuffer与StringBuilder的区别。"><a href="#String、StringBuffer与StringBuilder的区别。" class="headerlink" title="String、StringBuffer与StringBuilder的区别。"></a>String、StringBuffer与StringBuilder的区别。</h2><p>string:字符串常量，不可改变的对象<br>StringBuffer:字符串变量,可变对象,线程安全，效率低<br>StringBuilder:字符串变量,可变对象,线程不安全，效率高</p>
<h2 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h2><p>HashMap:异步的，线程不安全<br>HashTable:同步的，线程安全</p>
<h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p> 一、我们先解释一下他的含义：<br>1.token的引入<br>token是客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，token便应运而生<br>2、Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。<br>3、使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。<br>二、如何使用Token？<br>1、用设备号/设备mac地址作为Token（推荐）<br>客户端：客户端在登录的时候获取设备的设备号/mac地址，并将其作为参数传递到服务端。<br> 服务端：服务端接收到该参数后，便用一个变量来接收同时将其作为Token保存在数据库，并将该Token设置到session中，客户端每次请求的时候都要统一拦截，并将客户端传递的token和服务器端session中的token进行对比，如果相同则放行，不同则拒绝。<br>分析：此刻客户端和服务器端就统一了一个唯一的标识Token，而且保证了每一个设备拥有了一个唯一的会话。<br>该方法的缺点是客户端需要带设备号/mac地址作为参数传递，而且服务器端还需要保存；优点是客户端不需重新登录，只要登录一次以后一直可以使用，至于超时的问题是有服务器这边来处理，如何处理？若服务器的Token超时后，服务器只需将客户端传递的Token向数据库中查询，同时并赋值给变量Token，如此，Token的超时又重新计时。<br>2、用session值作为Token<br>客户端：客户端只需携带用户名和密码登陆即可。<br>客户端：客户端接收到用户名和密码后并判断，如果正确了就将本地获取sessionID作为Token返回给客户端，客户端以后只需带上请求数据即可。<br>分析：这种方式使用的好处是方便，不用存储数据，但是缺点就是当session过期后，客户端必须重新登录才能进行访问数据。<br>三、使用过程中出现的问题以及解决方案？<br>刚才我们轻松介绍了Token的两种使用方式，但是在使用过程中我们还出现各种问题，Token第一种方法中我们隐藏了一个在网络不好或者并发请求时会导致多次重复提交数据的问题。</p>
<p>该问题的解决方案：将session和Token套用，如此便可解决，如何套用呢？请看这段解释：<br><img src="https://github.com/ayanamiq/images/blob/master/token.png?raw=true" alt=""><br>这就是解决重复提交的方案。</p>
<h2 id="java局部变量和成员变量名相同"><a href="#java局部变量和成员变量名相同" class="headerlink" title="java局部变量和成员变量名相同"></a>java局部变量和成员变量名相同</h2><p>java中，<strong>在同一个作用域下</strong>，不能定义一样的标识符(变量名)，因为需要保证在某个作用域下使用某个标识符的时候，JVM能够正确进行区分。<br>全局变量、局部变量和内存不存在绝对直接的关系。不管是全局的还是局部的变量，他的标识都是保存在栈中的。<br>成员变量的作用域是整个类，局部变量能够覆盖成员(全局)变量。在局部使用某个变量的时候JVM会优先找和当前使用位置”近”的变量的的定义。<br>如果在局部定义了和全局变量一样的名字，如果调用全局变量的话，可以使用this关键字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    int i = 1;</span><br><span class="line">    void f()&#123;</span><br><span class="line">        int i = 10;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(this.i);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test t = new Test();</span><br><span class="line">        t.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用Iterator在遍历的时候删除List里的元素"><a href="#使用Iterator在遍历的时候删除List里的元素" class="headerlink" title="使用Iterator在遍历的时候删除List里的元素"></a>使用Iterator在遍历的时候删除List里的元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iteratorRemove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	List&lt;Student&gt; students = <span class="keyword">this</span>.getStudents();</span><br><span class="line">	System.out.println(students);</span><br><span class="line">	Iterator&lt;Student&gt; stuIter = students.iterator();</span><br><span class="line">	<span class="keyword">while</span> (stuIter.hasNext()) &#123;</span><br><span class="line">		Student student = stuIter.next();</span><br><span class="line">		<span class="keyword">if</span> (student.getId() % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">			stuIter.remove();<span class="comment">//这里要使用Iterator的remove方法移除当前对象，如果使用List的remove方法，则同样会出现ConcurrentModificationException</span></span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(students);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java中的三元运算符"><a href="#Java中的三元运算符" class="headerlink" title="Java中的三元运算符"></a>Java中的三元运算符</h2><p>你是想写一个表达式语句，你认为：(x == 5) ? “yes” : “no” 是一个表达式,则加上;后就成为一个语句了? </p>
<p>这个在C/C++中正确的,在JAVA中对表达式有特定的要求.即:  表达式E;<br>要形成一个表达式语句,则表达式E必须只能是:</p>
<ul>
<li>赋值表达式,</li>
<li>自增++表达式,</li>
<li>自减–表达式,</li>
<li>方法调用表达式,</li>
<li>new 表达式</li>
</ul>
<h2 id="？？？"><a href="#？？？" class="headerlink" title="？？？"></a>？？？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Long a = <span class="number">1l</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">System.out.println(a == b);</span><br><span class="line"></span><br><span class="line">Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"a"</span>,a);</span><br><span class="line">map.put(<span class="string">"b"</span>,b);</span><br><span class="line">System.out.println(map.get(<span class="string">"a"</span>) == map.get(<span class="string">"b"</span>));</span><br></pre></td></tr></table></figure>
<h2 id="自动拆箱问题"><a href="#自动拆箱问题" class="headerlink" title="自动拆箱问题"></a>自动拆箱问题</h2><p>今天在写接口时，有个方法的参数是int类型：<br><code>public xxx(int id);</code></p>
<p>我在传递参数时，可能为null，所以我这么写：<br><code>token == null ? null : token.getId()</code></p>
<p>这时编译器是不报错的，但是会给提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Unboxing of &apos;null&apos; may produce &apos;NullPointerException&apos;</span><br><span class="line">Inspection info: This inspection analyzes method control and data flow to report possible conditions that are always true or false, expressions whose value is statically proven to be constant, and situations that can lead to nullability contract violations.</span><br><span class="line">Variables, method parameters and return values marked as @Nullable or @NotNull are treated as nullable (or not-null, respectively) and used during the analysis to check nullability contracts, e.g. report NullPointerException (NPE) errors that might be produced.</span><br><span class="line">More complex contracts can be defined using @Contract annotation, for example:</span><br><span class="line">@Contract(&quot;_, null -&gt; null&quot;) — method returns null if its second argument is null</span><br><span class="line">@Contract(&quot;_, null -&gt; null; _, !null -&gt; !null&quot;) — method returns null if its second argument is null and not-null otherwise</span><br><span class="line">@Contract(&quot;true -&gt; fail&quot;) — a typical assertFalse method which throws an exception if true is passed to it</span><br><span class="line"></span><br><span class="line">The inspection can be configured to use custom @Nullable@NotNull annotations (by default the ones from annotations.jar will be used)</span><br></pre></td></tr></table></figure></p>
<p>运行时直接报错了。因为<code>null</code>为对象类型，参数为int，在调用方法时，jvm会尝试把null拆箱为int类型，然后就直接报空指针了。<br>直接把参数改成<code>Integer</code>就好了。</p>
<p>2019/7/26更新<br><code>java.lang.NullPointerException: cannot unbox null value</code><br>需求参数为int，如果不传入参数，或为null，会报上边的错误。<br>这时把需求参数改为Integer，就好了。</p>
<h2 id="集合指定和不指定反省的区别"><a href="#集合指定和不指定反省的区别" class="headerlink" title="集合指定和不指定反省的区别"></a>集合指定和不指定反省的区别</h2><p>指定了参数类型编译器在编译期间就会帮助你检查存入容器的对象是不是参数类型，不是就会报错，保证了类型安全，性能上没什么影响，因为泛型在运行期间会擦除。<br>就是说用不用类型参数在运行期间编译后的运行代码是一样的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">Map&lt;String,String&gt; map1 =<span class="keyword">new</span>  HashMap&lt;String,String&gt;();</span><br><span class="line">System.out.println(map.getClass().equals(map1.getClass()));</span><br></pre></td></tr></table></figure></p>
<p>返回结果会true；说明他们运行的是同一份字节码。</p>
<h2 id="将代码打成jar包"><a href="#将代码打成jar包" class="headerlink" title="将代码打成jar包"></a>将代码打成jar包</h2><h2 id="遍历枚举类"><a href="#遍历枚举类" class="headerlink" title="遍历枚举类"></a>遍历枚举类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Test &#123;</span><br><span class="line"></span><br><span class="line">    UPDATE(<span class="number">1</span>,<span class="string">"更新"</span>),</span><br><span class="line">    LOGIN(<span class="number">2</span>,<span class="string">"登陆"</span>),</span><br><span class="line">    STOCK_IN(<span class="number">3</span>,<span class="string">"库存领用"</span>),</span><br><span class="line">    QUERY_ACCOUNT(<span class="number">4</span>,<span class="string">"账户查询"</span>),</span><br><span class="line">    PERSTORE(<span class="number">5</span>,<span class="string">"预存"</span>),</span><br><span class="line">    OPEN_CARD_APPLY(<span class="number">6</span>,<span class="string">"开卡申请"</span>),</span><br><span class="line">    OPEN_CARD(<span class="number">7</span>,<span class="string">"开卡"</span>),</span><br><span class="line">    YIJIETIAO_APPLY(<span class="number">8</span>,<span class="string">"借条申请"</span>),</span><br><span class="line">    ADDED_SERVICE_MAG(<span class="number">9</span>,<span class="string">"增值服务管理"</span>),</span><br><span class="line">    NEW_ACCOUNT(<span class="number">10</span>,<span class="string">"新建账户"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">(Integer code, String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(Integer code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"第一种通过反射"</span>);</span><br><span class="line">        Class&lt;Test&gt; clz = Test.class;</span><br><span class="line">        <span class="keyword">for</span> (Test obj : clz.getEnumConstants()) &#123;</span><br><span class="line">            System.out.println(obj.getType());</span><br><span class="line">            System.out.println(obj.getCode());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"第二种通过枚举静态方法values()"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Test rate : Test.values()) &#123;</span><br><span class="line">            System.out.println(rate.getType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java实现Office系列文件转PDF文件"><a href="#Java实现Office系列文件转PDF文件" class="headerlink" title="Java实现Office系列文件转PDF文件"></a>Java实现Office系列文件转PDF文件</h2><p><a href="https://downloads.aspose.com/" target="_blank" rel="noopener">官网下载jar包</a><br><a href="https://pan.baidu.com/s/1vzYobuqDZYe6-VPRp06l3w" target="_blank" rel="noopener">获取在网盘下载破解包</a><br>官网下载的有水印，不过是最新版，破解的是比较旧的版本，不过都能用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.archive.util.AsposeUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aspose.cells.Workbook;</span><br><span class="line"><span class="keyword">import</span> com.aspose.slides.Presentation;</span><br><span class="line"><span class="keyword">import</span> com.aspose.words.Document;</span><br><span class="line"><span class="keyword">import</span> com.aspose.words.SaveFormat;</span><br><span class="line"><span class="keyword">import</span> com.aspose.words.License;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: wjy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Create in 14:28 2019/10/31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> : Office系列文件转PDF文件工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsposeUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接把凭证内容写进来，省的读取本地文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String licenseStr =</span><br><span class="line">            <span class="string">"&lt;License&gt;"</span> +</span><br><span class="line">            <span class="string">"  &lt;Data&gt;"</span> +</span><br><span class="line">            <span class="string">"    &lt;Products&gt;"</span> +</span><br><span class="line">            <span class="string">"      &lt;Product&gt;Aspose.Total for Java&lt;/Product&gt;"</span> +</span><br><span class="line">            <span class="string">"    &lt;/Products&gt;"</span> +</span><br><span class="line">            <span class="string">"    &lt;EditionType&gt;Enterprise&lt;/EditionType&gt;"</span> +</span><br><span class="line">            <span class="string">"    &lt;SubscriptionExpiry&gt;20991231&lt;/SubscriptionExpiry&gt;"</span> +</span><br><span class="line">            <span class="string">"    &lt;LicenseExpiry&gt;20991231&lt;/LicenseExpiry&gt;"</span> +</span><br><span class="line">            <span class="string">"    &lt;SerialNumber&gt;8bfe198c-7f0c-4ef8-8ff0-acc3237bf0d7&lt;/SerialNumber&gt;"</span> +</span><br><span class="line">            <span class="string">"  &lt;/Data&gt;"</span> +</span><br><span class="line">            <span class="string">"  &lt;Signature&gt;sNLLKGMUdF0r8O1kKilWAGdgfs2BvJb/2Xp8p5iuDVfZXmhppo+d0Ran1P9TKdjV4ABwAgKXxJ3jcQTqE/2IRfqwnPf8itN8aFZlV3TJPYeD3yWE7IT55Gz6EijUpC7aKeoohTb4w2fpox58wWoF3SNp6sK6jDfiAUGEHYJ9pjU=&lt;/Signature&gt;"</span> +</span><br><span class="line">            <span class="string">"&lt;/License&gt;"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取word、excel、ppt的license</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getLicense</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream license = <span class="keyword">new</span> ByteArrayInputStream(licenseStr.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            <span class="comment">//也可以读取本地文件license.xml</span></span><br><span class="line">            <span class="comment">//InputStream license = new FileInputStream(new File("E:\\IDEA2017\\something2pdf-demo\\src\\main\\resources\\license.xml"));</span></span><br><span class="line">            <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//word</span></span><br><span class="line">                    License wordLicense = <span class="keyword">new</span> License();</span><br><span class="line">                    wordLicense.setLicense(license);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//excel</span></span><br><span class="line">                    com.aspose.cells.License excelLicense = <span class="keyword">new</span> com.aspose.cells.License();</span><br><span class="line">                    excelLicense.setLicense(license);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//ppt</span></span><br><span class="line">                    com.aspose.slides.License pptLicense = <span class="keyword">new</span> com.aspose.slides.License();</span><br><span class="line">                    pptLicense.setLicense(license);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * word转pdf</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doc2pdf</span><span class="params">(String outputPath,String inputPath)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//验证License 若不验证则转化出的pdf文档会有水印产生</span></span><br><span class="line">        <span class="keyword">if</span> (!getLicense(<span class="number">1</span>)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//pdf输出路径</span></span><br><span class="line">            FileOutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(outputPath));</span><br><span class="line">            <span class="comment">//word文件路径，即本地word文件路径</span></span><br><span class="line">            Document doc = <span class="keyword">new</span> Document(inputPath);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里也可以获取上传的文件</span></span><br><span class="line">            <span class="comment">//Document doc = new Document(multipartFile.getInputStream());</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//保存转换的pdf文件</span></span><br><span class="line">            doc.save(os, SaveFormat.PDF);</span><br><span class="line">            os.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * excel转pdf</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">excel2pdf</span><span class="params">(String outputPath,String inputPath)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 验证License 若不验证则转化出的pdf文档会有水印产生</span></span><br><span class="line">        <span class="keyword">if</span> (!getLicense(<span class="number">2</span>)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//pdf输出路径</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(outputPath);</span><br><span class="line">            FileOutputStream os = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//excel输入路径，即本地excel文件路径</span></span><br><span class="line">            Workbook wb = <span class="keyword">new</span> Workbook(inputPath);</span><br><span class="line">            wb.save(os, com.aspose.cells.SaveFormat.PDF);</span><br><span class="line">            os.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ppt转pdf</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ppt2pdf</span><span class="params">(String outputPath,String inputPath)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 验证License</span></span><br><span class="line">        <span class="keyword">if</span> (!getLicense(<span class="number">3</span>)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//pdf输出路径</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(outputPath);</span><br><span class="line">            <span class="comment">//ppt输入路径，即本地ppt文件路径</span></span><br><span class="line">            Presentation pres = <span class="keyword">new</span> Presentation(inputPath);</span><br><span class="line"></span><br><span class="line">            FileOutputStream fileOS = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            pres.save(fileOS, com.aspose.slides.SaveFormat.Pdf);</span><br><span class="line">            fileOS.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AsposeUtil.doc2pdf(<span class="string">"D:\\doc2pdf.pdf"</span>,<span class="string">"C:\\Users\\wjy\\Desktop\\测试word.docx"</span>);</span><br><span class="line">        AsposeUtil.excel2pdf(<span class="string">"D:\\excel2pdf.pdf"</span>,<span class="string">"C:\\Users\\wjy\\Desktop\\测试excel.xlsx"</span>);</span><br><span class="line">        AsposeUtil.ppt2pdf(<span class="string">"D:\\ppt2pdf.pdf"</span>,<span class="string">"C:\\Users\\wjy\\Desktop\\测试ppt.pptx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>maven仓库里没有这三个包。需要自己下载，然后放到项目里，或放到自己的maven仓库里。<br>而且<code>new License()</code>和<code>SaveFormat</code>两个方法，三个包的名字是相同的，所以只能倒一个包，剩下两个写全路径。</p>
<p>三个包名：<br><code>aspose-cells-18.9.jar</code>excel转pdf<br><code>aspose-slides-19.6.jar</code>ppt转pdf<br><code>aspose-words-16.8.0-jdk16.jar</code>word转pdf</p>
<p><a href="https://www.jianshu.com/p/86716c7122ef" target="_blank" rel="noopener">words转pdf参考</a><br><a href="https://blog.csdn.net/qq_34190023/article/details/82999054" target="_blank" rel="noopener">参考地址</a><br><a href="https://blog.csdn.net/qq_42834405/article/details/98635337" target="_blank" rel="noopener">如何破解</a></p>
<h2 id="两个同名的jar包"><a href="#两个同名的jar包" class="headerlink" title="两个同名的jar包"></a>两个同名的jar包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import com.aspose.words.License;</span><br><span class="line">import com.aspose.cells.License;</span><br></pre></td></tr></table></figure>
<p>这样下边这个包会报错。<br>解决办法：<br>只倒一个包，另外的直接用全路径，不倒包。如：<br><code>com.aspose.cells.License asposeLic = new com.aspose.cells.License();</code><br><code>java.io.File dest = new java.io.File(filePath + alias);</code></p>
<h2 id="读取pdf内容"><a href="#读取pdf内容" class="headerlink" title="读取pdf内容"></a>读取pdf内容</h2><p>文本内容提取:<br>pom引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.apache.pdfbox&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;pdfbox&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.0.15&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.apache.pdfbox&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;fontbox&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.0.15&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.apache.pdfbox&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;jempbox&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.8.16&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读PDF文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readPDF</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">	File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">	FileInputStream in = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		PDDocument document=PDDocument.load(file);</span><br><span class="line">		<span class="comment">// 获取页码</span></span><br><span class="line">		<span class="keyword">int</span> pages = document.getNumberOfPages();</span><br><span class="line">		<span class="comment">// 读文本内容</span></span><br><span class="line">		PDFTextStripper stripper=<span class="keyword">new</span> PDFTextStripper();</span><br><span class="line">		<span class="comment">// 设置按顺序输出</span></span><br><span class="line">		stripper.setSortByPosition(<span class="keyword">true</span>);</span><br><span class="line">		stripper.setStartPage(<span class="number">1</span>);</span><br><span class="line">		stripper.setEndPage(pages);</span><br><span class="line">		String content = stripper.getText(document);</span><br><span class="line">		System.out.println(content);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//可选，将pdf内容写入到txt文本文件</span></span><br><span class="line"><span class="comment">//            FileWriter fileWriter = new FileWriter(new File("pdf.txt"));</span></span><br><span class="line"><span class="comment">//            fileWriter.write(content);</span></span><br><span class="line"><span class="comment">//            fileWriter.flush();</span></span><br><span class="line"><span class="comment">//            fileWriter.close();</span></span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		System.out.println(<span class="string">"读取PDF文件"</span> + file.getAbsolutePath() + <span class="string">"失败！"</span> + e);</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				in.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="util"><a href="#util" class="headerlink" title="util"></a>util</h1><h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><ul>
<li><p>判断两个时间戳是否是同一天</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSameDay</span><span class="params">(<span class="keyword">int</span> beginTimestamp,<span class="keyword">int</span> endTimestamp)</span> </span>&#123;</span><br><span class="line">	SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">	String ds1 = sdf.format(beginTimestamp * <span class="number">1000l</span>);</span><br><span class="line">	String ds2 = sdf.format(endTimestamp * <span class="number">1000l</span>);</span><br><span class="line">	<span class="keyword">if</span> (ds1.equals(ds2)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算两个时间戳差值(秒级时间戳)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTimeDifference</span><span class="params">(<span class="keyword">int</span> beginTimestamp, <span class="keyword">int</span> endTimestamp, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (beginTimestamp == <span class="number">0</span> || endTimestamp == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> millisecond = endTimestamp - beginTimestamp;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Math.abs((int)(millisecond/1000)); 绝对值 1秒 = 1000毫秒</span></span><br><span class="line"><span class="comment">		 * millisecond/1000 --&gt; 秒</span></span><br><span class="line"><span class="comment">		 * millisecond/1000*60 - &gt; 分钟</span></span><br><span class="line"><span class="comment">		 * millisecond/(1000*60*60) -- &gt; 小时</span></span><br><span class="line"><span class="comment">		 * millisecond/(1000*60*60*24) --&gt; 天</span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// second</span></span><br><span class="line">				<span class="keyword">return</span>  millisecond;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// minute</span></span><br><span class="line">				<span class="keyword">return</span> (millisecond / <span class="number">60</span>);</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// hour</span></span><br><span class="line">				<span class="keyword">return</span>  (millisecond / (<span class="number">60</span> * <span class="number">60</span>));</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// day</span></span><br><span class="line">				<span class="keyword">return</span> (millisecond / (<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author: wjy</span><br><span class="line"> * @description: 字符串根据ASCII码表进行升序排列</span><br><span class="line"> */</span><br><span class="line">public static String ASCIISort(String str) &#123;</span><br><span class="line">	char[] test = new char[str.length()];</span><br><span class="line">	StringBuilder sb = new StringBuilder();</span><br><span class="line">	while (true) &#123;</span><br><span class="line">		String a = str;//直接读取这行当中的字符串。</span><br><span class="line">		for (int i = 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">			test[i] = a.charAt(i);//字符串处理每次读取一位。</span><br><span class="line">		&#125;</span><br><span class="line">		Arrays.sort(test);</span><br><span class="line">		for (int i = 0; i &lt; test.length; i++) &#123;</span><br><span class="line">			sb.append(test[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		String trim = sb.toString().trim();</span><br><span class="line">		return trim;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>Lambda 表达式是一种匿名函数，简单地说，它是没有声明的方法，也即没有访问修饰符、返回值声明和名字。<br>它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使 Java 语言的表达能力得到了提升。<br>Lambda表达式是Java SE 8中一个重要的新特性，允许你通过表达式来代替功能接口。就和方法一样，它提供了一个正常的参数列表和一个使用这些参数的主体(body，可以是一个表达式或一个代码块)。Lambda表达式还增强了集合库。<br>Java SE 8添加了2个对集合数据进行批量操作的包：java.util.function 包以及 java.util.stream 包。<br>流(stream)就如同迭代器(iterator)，但附加了许多额外的功能。<br>总的来说，lambda表达式和 stream 是自Java语言添加泛型(Generics)和注解(annotation)以来最大的变化。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>jdk1.8以上</p>
<h2 id="Lambda表达式的语法"><a href="#Lambda表达式的语法" class="headerlink" title="Lambda表达式的语法"></a>Lambda表达式的语法</h2><p>基本语法:<br>(parameters) -&gt; expression<br>或<br>(parameters) -&gt;{ statements; }</p>
<p>简单例子：<br>// 1. 不需要参数,返回值为 5<br>() -&gt; 5</p>
<p>// 2. 接收一个参数(数字类型)，返回其2倍的值<br>x -&gt; 2 * x</p>
<p>// 3. 接受2个参数(数字)，并返回他们的差值<br>(x, y) -&gt; x – y</p>
<p>// 4. 接收2个int型整数，返回他们的和<br>(int x, int y) -&gt; x + y</p>
<p>// 5. 接受一个 string 对象，并在控制台打印，不返回任何值(看起来像是返回void)<br>(String s) -&gt; System.out.print(s)</p>
<h2 id="什么是函数式接口"><a href="#什么是函数式接口" class="headerlink" title="什么是函数式接口"></a>什么是函数式接口</h2><p>在对上面进行举例说明之前，必须先来理解下函数式接口，因为Lambda是建立在函数式接口的基础上的。</p>
<ul>
<li>只包含一个抽象方法的接口，称为函数式接口。</li>
<li>你可以通过 Lambda 表达式来创建该接口的对象。</li>
<li>我们可以在任意函数式接口上使用 @FunctionalInterface 注解，这样做可以检测它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。在实际开发者🈶️两个比较常见的函数式接口：Runnable接口，Comparator接口</li>
</ul>
<p>Runnable接口相关<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.1使用匿名内部类  </span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                System.out.println(<span class="string">"Hello world !"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;).start();  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 1.2使用 lambda 获得Runnable接口对象  </span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"Hello world !"</span>)).start();  </span><br><span class="line">        </span><br><span class="line"><span class="comment">//=============================================================================</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.1使用匿名内部类  </span></span><br><span class="line">        Runnable race1 = <span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                System.out.println(<span class="string">"Hello world !"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 2.2使用 lambda直接获得接口对象 </span></span><br><span class="line">        Runnable race2 = () -&gt; System.out.println(<span class="string">"Hello world !"</span>);          </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 直接调用 run 方法(没开新线程哦!)  </span></span><br><span class="line">        race1.run();  </span><br><span class="line">        race2.run();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment"> * Hello world !</span></span><br><span class="line"><span class="comment"> * Hello world !</span></span><br><span class="line"><span class="comment"> * Hello world !</span></span><br><span class="line"><span class="comment"> * Hello world !</span></span><br><span class="line"><span class="comment"> *／</span></span><br></pre></td></tr></table></figure></p>
<p>使用Lambda对数组排序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArray</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] players = &#123;<span class="string">"zhansgan"</span>, <span class="string">"lisi"</span>, <span class="string">"wangwu"</span>, <span class="string">"zhaoliu"</span>,  <span class="string">"wangmazi"</span>&#125;;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.1 使用匿名内部类根据 surname 排序 players  </span></span><br><span class="line">        Arrays.sort(players, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">return</span> (s1.compareTo(s2));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.2 使用 lambda 排序,根据 surname  </span></span><br><span class="line">        Arrays.sort(players, (String s1, String s2) -&gt;  s1.compareTo(s2));  </span><br><span class="line">         </span><br><span class="line"><span class="comment">//================================================================================================</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 2.1 使用匿名内部类根据 name lenght 排序 players  </span></span><br><span class="line">        Arrays.sort(players, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">return</span> (s1.length() - s2.length());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2使用Lambda,根据name length  </span></span><br><span class="line">        Arrays.sort(players, (String s1, String s2) -&gt; (s1.length() - s2.length()));  </span><br><span class="line">    </span><br><span class="line"><span class="comment">//==================================================================================================    </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.1 使用匿名内部类排序 players, 根据最后一个字母  </span></span><br><span class="line">        Arrays.sort(players, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;  </span><br><span class="line">                <span class="keyword">return</span> (s1.charAt(s1.length() - <span class="number">1</span>) - s2.charAt(s2.length() - <span class="number">1</span>));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2 使用Lambda,根据最后一个字母</span></span><br><span class="line">        Arrays.sort(players, (String s1, String s2) -&gt; (s1.charAt(s1.length() - <span class="number">1</span>) - s2.charAt(s2.length() - <span class="number">1</span>)));  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面例子我们再来思考为什么Lambda表达式需要函数式接口？其实很简单目的就是为来保证唯一。<br>你的Runnable接口只要一个抽象方法，那么我用() -&gt; System.out.println(“Hello world !”)，就只能代表run方法，如果你下面还有一个抽象方法，那我使用Lambda表达式，那鬼才知道要调用哪个抽象方法呢。</p>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>函数式接口的实例可以通过 lambda 表达式、 方法引用、构造方法引用来创建。方法引用是 lambda 表达式的语法糖，任何用方法引用的地方都可由lambda表达式替换，但是并不是所有的lambda表达式都可以用方法引用来替换。<br>举例，这就是一个打印集合所有元素的例子，value -&gt; System.out.println(value) 是一个Consumer函数式接口， 这个函数式接口可以通过方法引用来替换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class TestArray &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         List&lt;String&gt; list = Arrays.asList(&quot;xuxiaoxiao&quot;, &quot;xudada&quot;, &quot;xuzhongzhong&quot;);</span><br><span class="line">           list.forEach(value -&gt; System.out.println(value));</span><br><span class="line">    &#125;</span><br><span class="line">    /* 输出：</span><br><span class="line">     * xuxiaoxiao</span><br><span class="line">     * xudada</span><br><span class="line">     * xuzhongzhong</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用方法引用的方式，和上面的输出是一样的，方法引用使用的是双冒号（::）<br><code>list.forEach(System.out::println);</code></p>
<p>分类</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>使用形式</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态方法引用</td>
<td>类名 :: 静态方法名</td>
</tr>
<tr>
<td>实例方法引用</td>
<td>对象名(引用名) :: 实例方法名</td>
</tr>
<tr>
<td>类方法引用</td>
<td>类名 :: 实例方法名</td>
</tr>
<tr>
<td>构造方法引用</td>
<td>类名 :: new</td>
</tr>
</tbody>
</table>
<ul>
<li>静态方法引用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(String name, String color, <span class="keyword">double</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareByWeight</span><span class="params">(Apple a1, Apple a2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> diff = a1.getWeight() - a2.getWeight();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Double(diff).intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//还有getter setter toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>有一个苹果的List，现在需要根据苹果的重量进行排序。List 的 sort 函数接收一个 Comparator 类型的参数，Comparator 是一个函数式接口，接收两个参数，返回一个int值。<br>Apple的静态方法compareByWeight正好符合Comparator函数式接口，所以可以使用：<br>Apple::compareByWeight 静态方法引用来替代lambda表达式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Apple apple1 = <span class="keyword">new</span> Apple(<span class="string">"红富士"</span>, <span class="string">"Red"</span>, <span class="number">280</span>);</span><br><span class="line">        Apple apple2 = <span class="keyword">new</span> Apple(<span class="string">"冯心"</span>, <span class="string">"Yello"</span>, <span class="number">470</span>);</span><br><span class="line">        Apple apple3 = <span class="keyword">new</span> Apple(<span class="string">"大牛"</span>, <span class="string">"Red"</span>, <span class="number">320</span>);</span><br><span class="line">        Apple apple4 = <span class="keyword">new</span> Apple(<span class="string">"小小"</span>, <span class="string">"Green"</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Apple&gt; appleList = Arrays.asList(apple1, apple2, apple3, apple4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//lambda 表达式形式</span></span><br><span class="line">        <span class="comment">//appleList.sort((Apple a1, Apple a2) -&gt; &#123;</span></span><br><span class="line">        <span class="comment">//    return new Double(a1.getWeight() - a2.getWeight()).intValue();</span></span><br><span class="line">        <span class="comment">//&#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态方法引用形式（可以看出引用方法比上面的更加简单</span></span><br><span class="line">        appleList.sort(Apple::compareByWeight);</span><br><span class="line"></span><br><span class="line">        appleList.forEach(apple -&gt; System.out.println(apple));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Apple&#123;category=<span class="string">'红富士'</span>, color=<span class="string">'Red'</span>, weight=<span class="number">280.0</span>&#125;</span><br><span class="line">Apple&#123;category=<span class="string">'小小'</span>, color=<span class="string">'Green'</span>, weight=<span class="number">300.0</span>&#125;</span><br><span class="line">Apple&#123;category=<span class="string">'大牛'</span>, color=<span class="string">'Red'</span>, weight=<span class="number">320.0</span>&#125;</span><br><span class="line">Apple&#123;category=<span class="string">'冯心'</span>, color=<span class="string">'Yello'</span>, weight=<span class="number">470.0</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>Apple.compareByWeight是方法的调用，而Apple::compareByWeight方法引用，这两者完全不是一回事。</p>
<ul>
<li>实例方法引用<br>这个compareByWeight是一个实例方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class AppleComparator &#123;</span><br><span class="line"></span><br><span class="line">    public int compareByWeight(Apple a1, Apple a2) &#123;</span><br><span class="line">        double diff = a1.getWeight() - a2.getWeight();</span><br><span class="line">        return new Double(diff).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面的例子通过实例对象的方法引用 comparator::compareByWeight 来代替lambda表达式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Apple apple1 = <span class="keyword">new</span> Apple(<span class="string">"红富士"</span>, <span class="string">"Red"</span>, <span class="number">280</span>);</span><br><span class="line">        Apple apple2 = <span class="keyword">new</span> Apple(<span class="string">"冯心"</span>, <span class="string">"Yello"</span>, <span class="number">470</span>);</span><br><span class="line">        Apple apple3 = <span class="keyword">new</span> Apple(<span class="string">"哈哈"</span>, <span class="string">"Red"</span>, <span class="number">320</span>);</span><br><span class="line">        Apple apple4 = <span class="keyword">new</span> Apple(<span class="string">"小小"</span>, <span class="string">"Green"</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;Apple&gt; appleList = Arrays.asList(apple1, apple2, apple3, apple4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//lambda 表达式形式</span></span><br><span class="line">        <span class="comment">//appleList.sort((Apple a1, Apple a2) -&gt; &#123;</span></span><br><span class="line">        <span class="comment">//    return new Double(a1.getWeight() - a2.getWeight()).intValue();</span></span><br><span class="line">        <span class="comment">//&#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例方法引用</span></span><br><span class="line">        AppleComparator comparator = <span class="keyword">new</span> AppleComparator();</span><br><span class="line">        appleList.sort(comparator::compareByWeight);</span><br><span class="line"></span><br><span class="line">        appleList.forEach(apple -&gt; System.out.println(apple));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Apple&#123;category=<span class="string">'红富士'</span>, color=<span class="string">'Red'</span>, weight=<span class="number">280.0</span>&#125;</span><br><span class="line">Apple&#123;category=<span class="string">'小小'</span>, color=<span class="string">'Green'</span>, weight=<span class="number">300.0</span>&#125;</span><br><span class="line">Apple&#123;category=<span class="string">'哈哈'</span>, color=<span class="string">'Red'</span>, weight=<span class="number">320.0</span>&#125;</span><br><span class="line">Apple&#123;category=<span class="string">'冯心'</span>, color=<span class="string">'Yello'</span>, weight=<span class="number">470.0</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面两个例子可以看到，静态方法引用和实例方法引用都是比较好理解的。</p>
<ul>
<li>类方法引用<br>一般来说，同类型对象的比较，应该当前调用方法的对象与另外一个对象进行比较，好的设计应该像下面： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String category;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(String category, String color, <span class="keyword">double</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.category = category;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这里和上面静态方式唯一区别就是这个参数就一个，需要实例对象调这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareByWeight</span><span class="params">(Apple other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> diff = <span class="keyword">this</span>.getWeight() - other.getWeight();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Double(diff).intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getter setter toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>还是之前List排序的例子，看看使用类方法引用如何写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Apple apple1 = <span class="keyword">new</span> Apple(<span class="string">"红富士"</span>, <span class="string">"Red"</span>, <span class="number">280</span>);</span><br><span class="line">        Apple apple2 = <span class="keyword">new</span> Apple(<span class="string">"黄元帅"</span>, <span class="string">"Yello"</span>, <span class="number">470</span>);</span><br><span class="line">        Apple apple3 = <span class="keyword">new</span> Apple(<span class="string">"红将军"</span>, <span class="string">"Red"</span>, <span class="number">320</span>);</span><br><span class="line">        Apple apple4 = <span class="keyword">new</span> Apple(<span class="string">"国光"</span>, <span class="string">"Green"</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;Apple&gt; appleList = Arrays.asList(apple1, apple2, apple3, apple4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//lambda 表达式形式</span></span><br><span class="line">        <span class="comment">//appleList.sort((Apple a1, Apple a2) -&gt; &#123;</span></span><br><span class="line">        <span class="comment">//    return new Double(a1.getWeight() - a2.getWeight()).intValue();</span></span><br><span class="line">        <span class="comment">//&#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里是类方法引用</span></span><br><span class="line">        appleList.sort(Apple::compareByWeight);</span><br><span class="line"></span><br><span class="line">        appleList.forEach(apple -&gt; System.out.println(apple));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Apple&#123;category=<span class="string">'红富士'</span>, color=<span class="string">'Red'</span>, weight=<span class="number">280.0</span>&#125;</span><br><span class="line">Apple&#123;category=<span class="string">'国光'</span>, color=<span class="string">'Green'</span>, weight=<span class="number">300.0</span>&#125;</span><br><span class="line">Apple&#123;category=<span class="string">'红将军'</span>, color=<span class="string">'Red'</span>, weight=<span class="number">320.0</span>&#125;</span><br><span class="line">Apple&#123;category=<span class="string">'黄元帅'</span>, color=<span class="string">'Yello'</span>, weight=<span class="number">470.0</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里使用的是：类名::实例方法名。首先要说明的是，方法引用不是方法调用。compareByWeight一定是某个实例调用的，就是lambda表达式的第一个参数，然后lambda表达式剩下的参数作为<br>compareByWeight的参数，这样compareByWeight正好符合lambda表达式的定义。<br>或者也可以这样理解：<br>(Apple a1, Apple a2) -&gt; { return new Double(a1.getWeight() - a2.getWeight()).intValue(); }<br>int compareByWeight(Apple other) 需要当前对象调用，然后与另外一个对象比较，并且返回一个int值。可以理解为lambda表达式的第一个参数 a1 赋值给当前对象， 然后 a2 赋值给 other对象，然后返回int值。</p>
<ul>
<li>构造方法引用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ConstructionMethodTest &#123;</span><br><span class="line"></span><br><span class="line">    public String getString(Supplier&lt;String&gt; supplier) &#123;</span><br><span class="line">        return supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ConstructionMethodTest test = new ConstructionMethodTest();</span><br><span class="line"></span><br><span class="line">        //lambda表达式形式</span><br><span class="line">        System.out.println(test.getString(() -&gt; &#123; return new String();&#125;));</span><br><span class="line"></span><br><span class="line">        //构造方法引用形式</span><br><span class="line">        System.out.println(test.getString(String::new));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>getString 方法接收一个Supplier类型的参数，Supplier 不接收参数，返回一个String。lambda表达式应该这样写：<br><code>() -&gt; { return new String();}</code><br>替换成方法引用的形式如下： 实际上调用的是String 无参构造方法。<br><code>String::new</code></p>
<h2 id="基本的Lambda例子"><a href="#基本的Lambda例子" class="headerlink" title="基本的Lambda例子"></a>基本的Lambda例子</h2><p>假设有一个玩家List，程序员可以使用 for循环来遍历，在Java SE 8中可以转换为另一种形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String[] atp = &#123;&quot;小明&quot;,&quot;小红&quot;, &quot;小黑&quot;, &quot;小白&quot;,&quot;小兰&quot;, &quot;小强&quot;,&quot;小绿&quot;, &quot;小小&quot;&#125;;</span><br><span class="line">List&lt;String&gt; players =  Arrays.asList(atp);</span><br><span class="line"></span><br><span class="line">//以前的循环方式</span><br><span class="line">for (String player : players) &#123;</span><br><span class="line">	System.out.print(player + &quot;; &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用lambda表达式以及函数操作(functional operation)</span><br><span class="line">players.forEach((player) -&gt; System.out.println(player + &quot;;&quot;));</span><br><span class="line"></span><br><span class="line">//在JAVA 8 中使用双冒号操作符(double colon operator)</span><br><span class="line">players.forEach(System.out::println);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//下面是使用lambdas 来实现 Runnable接口 的示例:</span><br><span class="line">// 1.1使用匿名内部类</span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		System.out.println(&quot;Hello world !&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">// 1.2使用 lambda expression</span><br><span class="line">new Thread(() -&gt; System.out.println(&quot;Hello world !&quot;)).start();</span><br><span class="line"></span><br><span class="line">// 2.1使用匿名内部类</span><br><span class="line">Runnable race1 = new Runnable() &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		System.out.println(&quot;Hello world !&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 2.2使用 lambda expression</span><br><span class="line">Runnable race2 = () -&gt; System.out.println(&quot;Hello world !&quot;);</span><br><span class="line"></span><br><span class="line">// 直接调用 run 方法(没开新线程哦!)</span><br><span class="line">race1.run();</span><br><span class="line">race2.run();</span><br></pre></td></tr></table></figure>
<h2 id="使用Lambda对集合进行排序"><a href="#使用Lambda对集合进行排序" class="headerlink" title="使用Lambda对集合进行排序"></a>使用Lambda对集合进行排序</h2><p>在java中，Comparator 类被用来排序集合，在下面的例子中，我们将根据球员的 name, surname, name 长度以及最后一个字母。和前面的示例一样，先使用匿名内部类来排序，然后再使用lambda表达式精简我们的代码。<br>在第一个例子中,我们将根据name来排序list。使用旧的方式,代码如下所示：</p>
<p><code>String[] atp = {&quot;小明&quot;,&quot;小红&quot;, &quot;小黑&quot;, &quot;小白&quot;,&quot;小兰&quot;, &quot;小强&quot;,&quot;小绿&quot;, &quot;小小&quot;};</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1.1 使用匿名内部类根据 name 排序 players </span><br><span class="line">Arrays.sort(players, new Comparator&lt;String&gt;() &#123; </span><br><span class="line">    @Override </span><br><span class="line">    public int compare(String s1, String s2) &#123; </span><br><span class="line">        return (s1.compareTo(s2));  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>使用lambdas，可以通过下面的代码实现同样的功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1.2 使用 lambda expression 排序 players </span><br><span class="line">Comparator&lt;String&gt; sortByName = (String s1, String s2) -&gt; (s1.compareTo(s2)); </span><br><span class="line">Arrays.sort(players, sortByName); </span><br><span class="line">  </span><br><span class="line">// 1.3 也可以采用如下形式: </span><br><span class="line">Arrays.sort(players, (String s1, String s2) -&gt; (s1.compareTo(s2)));</span><br></pre></td></tr></table></figure></p>
<p>其他的排序如下所示。和上面的示例一样，代码分别通过匿名内部类和一些lambda表达式来实现Comparator：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 1.1 使用匿名内部类根据 surname 排序 players </span><br><span class="line">Arrays.sort(players, new Comparator&lt;String&gt;() &#123; </span><br><span class="line">    @Override </span><br><span class="line">    public int compare(String s1, String s2) &#123; </span><br><span class="line">        return (s1.substring(s1.indexOf(&quot; &quot;)).compareTo(s2.substring(s2.indexOf(&quot; &quot;))));  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;); </span><br><span class="line">  </span><br><span class="line">// 1.2 使用 lambda expression 排序,根据 surname </span><br><span class="line">Comparator&lt;String&gt; sortBySurname = (String s1, String s2) -&gt; </span><br><span class="line">    ( s1.substring(s1.indexOf(&quot; &quot;)).compareTo( s2.substring(s2.indexOf(&quot; &quot;)) ) ); </span><br><span class="line">Arrays.sort(players, sortBySurname); </span><br><span class="line">  </span><br><span class="line">// 1.3 或者这样,怀疑原作者是不是想错了,括号好多... </span><br><span class="line">Arrays.sort(players, (String s1, String s2) -&gt; </span><br><span class="line">      ( s1.substring(s1.indexOf(&quot; &quot;)).compareTo( s2.substring(s2.indexOf(&quot; &quot;)) ) ) </span><br><span class="line">    );</span><br><span class="line">  </span><br><span class="line">// 2.1 使用匿名内部类根据 name lenght 排序 players</span><br><span class="line">Arrays.sort(players, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(String s1, String s2) &#123;</span><br><span class="line">        return (s1.length() - s2.length());  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line">// 2.2 使用 lambda expression 排序,根据 name lenght</span><br><span class="line">Comparator&lt;String&gt; sortByNameLenght = (String s1, String s2) -&gt; (s1.length() - s2.length());</span><br><span class="line">Arrays.sort(players, sortByNameLenght);</span><br><span class="line">  </span><br><span class="line">// 2.3 or this</span><br><span class="line">Arrays.sort(players, (String s1, String s2) -&gt; (s1.length() - s2.length()));</span><br><span class="line">  </span><br><span class="line">// 3.1 使用匿名内部类排序 players, 根据最后一个字母</span><br><span class="line">Arrays.sort(players, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(String s1, String s2) &#123;</span><br><span class="line">        return (s1.charAt(s1.length() - 1) - s2.charAt(s2.length() - 1));  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line">// 3.2 使用 lambda expression 排序,根据最后一个字母</span><br><span class="line">Comparator&lt;String&gt; sortByLastLetter = </span><br><span class="line">    (String s1, String s2) -&gt;</span><br><span class="line">        (s1.charAt(s1.length() - 1) - s2.charAt(s2.length() - 1));  </span><br><span class="line">Arrays.sort(players, sortByLastLetter);</span><br><span class="line">  </span><br><span class="line">// 3.3 or this</span><br><span class="line">Arrays.sort(players, (String s1, String s2) -&gt; (s1.charAt(s1.length() - 1) - s2.charAt(s2.length() - 1)));</span><br></pre></td></tr></table></figure></p>
<h2 id="使用Lambdas和Streams"><a href="#使用Lambdas和Streams" class="headerlink" title="使用Lambdas和Streams"></a>使用Lambdas和Streams</h2><p>Stream是对集合的包装，通常和lambda一起使用。 使用lambdas可以支持许多操作，<br>如 map、filter、limit、sorted、count、min、max、sum、collect等等。<br>同样，tream使用懒运算，他们并不会真正地读取所有数据，遇到像getFirst()这样的方法就会结束链式语法。<br>在接下来的例子中,我们将探索lambdas和streams 能做什么。我们创建了一个Person类并使用这个类来添加一些数据到list中，将用于进一步流操作。</p>
<p>Person只是一个简单的POJO类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">  </span><br><span class="line">private String firstName, lastName, job, gender;</span><br><span class="line">private int salary, age;</span><br><span class="line">  </span><br><span class="line">public Person(String firstName, String lastName, String job,</span><br><span class="line">                String gender, int age, int salary)       &#123;  </span><br><span class="line">          this.firstName = firstName;  </span><br><span class="line">          this.lastName = lastName;  </span><br><span class="line">          this.gender = gender;  </span><br><span class="line">          this.age = age;  </span><br><span class="line">          this.job = job;  </span><br><span class="line">          this.salary = salary;  </span><br><span class="line">&#125;</span><br><span class="line">// Getter and Setter</span><br><span class="line">// . . . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，我们将创建两个list，都用来存放Person对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; javaProgrammers = new ArrayList&lt;Person&gt;() &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    add(new Person(&quot;Elsdon&quot;, &quot;Jaycob&quot;, &quot;Java programmer&quot;, &quot;male&quot;, 43, 2000));</span><br><span class="line">    add(new Person(&quot;Tamsen&quot;, &quot;Brittany&quot;, &quot;Java programmer&quot;, &quot;female&quot;, 23, 1500));</span><br><span class="line">    add(new Person(&quot;Floyd&quot;, &quot;Donny&quot;, &quot;Java programmer&quot;, &quot;male&quot;, 33, 1800));</span><br><span class="line">    add(new Person(&quot;Sindy&quot;, &quot;Jonie&quot;, &quot;Java programmer&quot;, &quot;female&quot;, 32, 1600));</span><br><span class="line">    add(new Person(&quot;Vere&quot;, &quot;Hervey&quot;, &quot;Java programmer&quot;, &quot;male&quot;, 22, 1200));</span><br><span class="line">    add(new Person(&quot;Maude&quot;, &quot;Jaimie&quot;, &quot;Java programmer&quot;, &quot;female&quot;, 27, 1900));</span><br><span class="line">    add(new Person(&quot;Shawn&quot;, &quot;Randall&quot;, &quot;Java programmer&quot;, &quot;male&quot;, 30, 2300));</span><br><span class="line">    add(new Person(&quot;Jayden&quot;, &quot;Corrina&quot;, &quot;Java programmer&quot;, &quot;female&quot;, 35, 1700));</span><br><span class="line">    add(new Person(&quot;Palmer&quot;, &quot;Dene&quot;, &quot;Java programmer&quot;, &quot;male&quot;, 33, 2000));</span><br><span class="line">    add(new Person(&quot;Addison&quot;, &quot;Pam&quot;, &quot;Java programmer&quot;, &quot;female&quot;, 34, 1300));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">List&lt;Person&gt; phpProgrammers = new ArrayList&lt;Person&gt;() &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    add(new Person(&quot;Jarrod&quot;, &quot;Pace&quot;, &quot;PHP programmer&quot;, &quot;male&quot;, 34, 1550));</span><br><span class="line">    add(new Person(&quot;Clarette&quot;, &quot;Cicely&quot;, &quot;PHP programmer&quot;, &quot;female&quot;, 23, 1200));</span><br><span class="line">    add(new Person(&quot;Victor&quot;, &quot;Channing&quot;, &quot;PHP programmer&quot;, &quot;male&quot;, 32, 1600));</span><br><span class="line">    add(new Person(&quot;Tori&quot;, &quot;Sheryl&quot;, &quot;PHP programmer&quot;, &quot;female&quot;, 21, 1000));</span><br><span class="line">    add(new Person(&quot;Osborne&quot;, &quot;Shad&quot;, &quot;PHP programmer&quot;, &quot;male&quot;, 32, 1100));</span><br><span class="line">    add(new Person(&quot;Rosalind&quot;, &quot;Layla&quot;, &quot;PHP programmer&quot;, &quot;female&quot;, 25, 1300));</span><br><span class="line">    add(new Person(&quot;Fraser&quot;, &quot;Hewie&quot;, &quot;PHP programmer&quot;, &quot;male&quot;, 36, 1100));</span><br><span class="line">    add(new Person(&quot;Quinn&quot;, &quot;Tamara&quot;, &quot;PHP programmer&quot;, &quot;female&quot;, 21, 1000));</span><br><span class="line">    add(new Person(&quot;Alvin&quot;, &quot;Lance&quot;, &quot;PHP programmer&quot;, &quot;male&quot;, 38, 1600));</span><br><span class="line">    add(new Person(&quot;Evonne&quot;, &quot;Shari&quot;, &quot;PHP programmer&quot;, &quot;female&quot;, 40, 1800));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在我们使用forEach方法来迭代输出上述列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;所有程序员的姓名:&quot;);</span><br><span class="line">javaProgrammers.forEach((p) -&gt; System.out.printf(&quot;%s %s; &quot;, p.getFirstName(), p.getLastName()));</span><br><span class="line">phpProgrammers.forEach((p) -&gt; System.out.printf(&quot;%s %s; &quot;, p.getFirstName(), p.getLastName()));</span><br></pre></td></tr></table></figure></p>
<p>我们同样使用forEach方法，增加程序员的工资5%：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;给程序员加薪 5% :&quot;);</span><br><span class="line">Consumer&lt;Person&gt; giveRaise = e -&gt; e.setSalary(e.getSalary() / 100 * 5 + e.getSalary());</span><br><span class="line">  </span><br><span class="line">javaProgrammers.forEach(giveRaise);</span><br><span class="line">phpProgrammers.forEach(giveRaise);</span><br></pre></td></tr></table></figure></p>
<p>另一个有用的方法是过滤器filter()，让我们显示月薪超过1400美元的PHP程序员：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;下面是月薪超过 $1,400 的PHP程序员:&quot;)</span><br><span class="line">phpProgrammers.stream()</span><br><span class="line">          .filter((p) -&gt; (p.getSalary() &gt; 1400))  </span><br><span class="line">          .forEach((p) -&gt; System.out.printf(&quot;%s %s; &quot;, p.getFirstName(), p.getLastName()));</span><br></pre></td></tr></table></figure></p>
<p>我们也可以定义过滤器，然后重用它们来执行其他操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 定义 filters</span><br><span class="line">Predicate&lt;Person&gt; ageFilter = (p) -&gt; (p.getAge() &gt; 25);</span><br><span class="line">Predicate&lt;Person&gt; salaryFilter = (p) -&gt; (p.getSalary() &gt; 1400);</span><br><span class="line">Predicate&lt;Person&gt; genderFilter = (p) -&gt; (&quot;female&quot;.equals(p.getGender()));</span><br><span class="line">  </span><br><span class="line">System.out.println(&quot;下面是年龄大于 24岁且月薪在$1,400以上的女PHP程序员:&quot;);</span><br><span class="line">phpProgrammers.stream()</span><br><span class="line">          .filter(ageFilter)  </span><br><span class="line">          .filter(salaryFilter)  </span><br><span class="line">          .filter(genderFilter)  </span><br><span class="line">          .forEach((p) -&gt; System.out.printf(&quot;%s %s; &quot;, p.getFirstName(), p.getLastName()));  </span><br><span class="line">  </span><br><span class="line">// 重用filters</span><br><span class="line">System.out.println(&quot;年龄大于 24岁的女性 Java programmers:&quot;);</span><br><span class="line">javaProgrammers.stream()</span><br><span class="line">          .filter(ageFilter)  </span><br><span class="line">          .filter(genderFilter)  </span><br><span class="line">          .forEach((p) -&gt; System.out.printf(&quot;%s %s; &quot;, p.getFirstName(), p.getLastName()));</span><br></pre></td></tr></table></figure></p>
<p>使用limit方法，可以限制结果集的个数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;最前面的3个 Java programmers:&quot;);</span><br><span class="line">javaProgrammers.stream()</span><br><span class="line">          .limit(3)  </span><br><span class="line">          .forEach((p) -&gt; System.out.printf(&quot;%s %s; &quot;, p.getFirstName(), p.getLastName()));</span><br><span class="line">		  </span><br><span class="line">System.out.println(&quot;最前面的3个女性 Java programmers:&quot;);</span><br><span class="line">javaProgrammers.stream()</span><br><span class="line">          .filter(genderFilter)</span><br><span class="line">          .limit(3)</span><br><span class="line">          .forEach((p) -&gt; System.out.printf(&quot;%s %s; &quot;, p.getFirstName(), p.getLastName()));</span><br></pre></td></tr></table></figure></p>
<p>排序呢? 我们在stream中能处理吗? 答案是肯定的。在下面的例子中,我们将根据名字和薪水排序Java程序员，放到一个list中,然后显示列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;根据 name 排序,并显示前5个 Java programmers:&quot;);</span><br><span class="line">List&lt;Person&gt; sortedJavaProgrammers = javaProgrammers</span><br><span class="line">          .stream()  </span><br><span class="line">          .sorted((p, p2) -&gt; (p.getFirstName().compareTo(p2.getFirstName())))  </span><br><span class="line">          .limit(5)  </span><br><span class="line">          .collect(toList());  </span><br><span class="line">  </span><br><span class="line">sortedJavaProgrammers.forEach((p) -&gt; System.out.printf(&quot;%s %s; %n&quot;, p.getFirstName(), p.getLastName()));</span><br><span class="line">   </span><br><span class="line">System.out.println(&quot;根据 salary 排序 Java programmers:&quot;);</span><br><span class="line">sortedJavaProgrammers = javaProgrammers</span><br><span class="line">          .stream()  </span><br><span class="line">          .sorted( (p, p2) -&gt; (p.getSalary() - p2.getSalary()) )  </span><br><span class="line">          .collect( toList() );  </span><br><span class="line">  </span><br><span class="line">sortedJavaProgrammers.forEach((p) -&gt; System.out.printf(&quot;%s %s; %n&quot;, p.getFirstName(), p.getLastName()));</span><br></pre></td></tr></table></figure></p>
<p>如果我们只对最低和最高的薪水感兴趣，比排序后选择第一个/最后一个更快的是min和max方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;工资最低的 Java programmer:&quot;);</span><br><span class="line">Person pers = javaProgrammers</span><br><span class="line">          .stream()  </span><br><span class="line">          .min((p1, p2) -&gt; (p1.getSalary() - p2.getSalary()))  </span><br><span class="line">          .get()  </span><br><span class="line">  </span><br><span class="line">System.out.printf(&quot;Name: %s %s; Salary: $%,d.&quot;, pers.getFirstName(), pers.getLastName(), pers.getSalary())</span><br><span class="line">  </span><br><span class="line">System.out.println(&quot;工资最高的 Java programmer:&quot;);</span><br><span class="line">Person person = javaProgrammers</span><br><span class="line">          .stream()  </span><br><span class="line">          .max((p, p2) -&gt; (p.getSalary() - p2.getSalary()))  </span><br><span class="line">          .get()  </span><br><span class="line">  </span><br><span class="line">System.out.printf(&quot;Name: %s %s; Salary: $%,d.&quot;, person.getFirstName(), person.getLastName(), person.getSalary())</span><br></pre></td></tr></table></figure></p>
<p>上面的例子中我们已经看到 collect 方法是如何工作的。结合 map 方法，我们可以使用 collect 方法来将我们的结果集放到一个字符串，一个 Set 或一个TreeSet中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;将 PHP programmers 的 first name 拼接成字符串:&quot;);</span><br><span class="line">String phpDevelopers = phpProgrammers</span><br><span class="line">          .stream()  </span><br><span class="line">          .map(Person::getFirstName)  </span><br><span class="line">          .collect(joining(&quot; ; &quot;)); // 在进一步的操作中可以作为标记(token)     </span><br><span class="line">  </span><br><span class="line">System.out.println(&quot;将 Java programmers 的 first name 存放到 Set:&quot;);</span><br><span class="line">Set&lt;String&gt; javaDevFirstName = javaProgrammers</span><br><span class="line">          .stream()  </span><br><span class="line">          .map(Person::getFirstName)  </span><br><span class="line">          .collect(toSet());  </span><br><span class="line">  </span><br><span class="line">System.out.println(&quot;将 Java programmers 的 first name 存放到 TreeSet:&quot;);</span><br><span class="line">TreeSet&lt;String&gt; javaDevLastName = javaProgrammers</span><br><span class="line">          .stream()  </span><br><span class="line">          .map(Person::getLastName)  </span><br><span class="line">          .collect(toCollection(TreeSet::new));</span><br></pre></td></tr></table></figure></p>
<p>Streams 还可以是并行的(parallel)。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;计算付给 Java programmers 的所有money:&quot;);</span><br><span class="line">int totalSalary = javaProgrammers</span><br><span class="line">          .parallelStream()  </span><br><span class="line">          .mapToInt(p -&gt; p.getSalary())  </span><br><span class="line">          .sum();</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用summaryStatistics方法获得stream中元素的各种汇总数据。接下来，我们可以访问这些方法，比如getMax，getMin，getSum或getAverage：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//计算 count, min, max, sum, and average for numbers</span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);</span><br><span class="line">IntSummaryStatistics stats = numbers</span><br><span class="line">          .stream()  </span><br><span class="line">          .mapToInt((x) -&gt; x)  </span><br><span class="line">          .summaryStatistics();  </span><br><span class="line">  </span><br><span class="line">System.out.println(&quot;List中最大的数字 : &quot; + stats.getMax());</span><br><span class="line">System.out.println(&quot;List中最小的数字 : &quot; + stats.getMin());</span><br><span class="line">System.out.println(&quot;所有数字的总和   : &quot; + stats.getSum());</span><br><span class="line">System.out.println(&quot;所有数字的平均值 : &quot; + stats.getAverage());</span><br></pre></td></tr></table></figure></p>
<p><a href="https://www.cnblogs.com/franson-2016/p/5593080.html" target="_blank" rel="noopener">参考</a></p>
<h1 id="base64编码和解码"><a href="#base64编码和解码" class="headerlink" title="base64编码和解码"></a>base64编码和解码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final Base64.Decoder decoder = Base64.getDecoder();</span><br><span class="line">final Base64.Encoder encoder = Base64.getEncoder();</span><br><span class="line">final String text = &quot;字串文字&quot;;</span><br><span class="line">final byte[] textByte = text.getBytes(&quot;UTF-8&quot;);</span><br><span class="line">//编码</span><br><span class="line">final String encodedText = encoder.encodeToString(textByte);</span><br><span class="line">System.out.println(encodedText);</span><br><span class="line">//解码</span><br><span class="line">System.out.println(new String(decoder.decode(encodedText), &quot;UTF-8&quot;));</span><br></pre></td></tr></table></figure>
<h1 id="养成良好的编程习惯"><a href="#养成良好的编程习惯" class="headerlink" title="养成良好的编程习惯"></a>养成良好的编程习惯</h1><h2 id="常量-amp-变量"><a href="#常量-amp-变量" class="headerlink" title="常量&amp;变量"></a>常量&amp;变量</h2><ul>
<li><p>直接赋值常量值，禁止声明新对象。<br>直接赋值常量值，只是创建了一个对象引用，而这个对象引用指向常量值。<br>反例：<br><code>Long i = new Long(1L);</code><br><code>String s = new String(&quot;abc&quot;);</code><br>正例：<br><code>Long i = 1L;</code><br><code>String s = &quot;abc&quot;;</code></p>
</li>
<li><p>当成员变量值无需改变时，尽量定义为静态常量。<br>在类的每个对象实例中，每个成员变量都有一份副本，而成员静态常量只有一份实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">反例：</span><br><span class="line">public class HttpConnection &#123;</span><br><span class="line">    private final long timeout = 5L;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line">public class HttpConnection &#123;</span><br><span class="line">    private static final long TIMEOUT = 5L;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尽量使用基本数据类型，避免自动拆箱和装箱<br>Java 中的基本数据类型double、float、long、int、short、char、boolean，分别对应包装类Double、Float、Long、Integer、Short、Character、Boolean。<br>JVM支持基本类型与对应包装类的自动转换，被称为自动装箱和拆箱。装箱和拆箱都是需要CPU和内存资源的，所以应尽量避免使用自动装箱和拆箱。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">反例：</span><br><span class="line">Integer sum = 0;</span><br><span class="line">int[] values = ...;</span><br><span class="line">for (int value : values) &#123;</span><br><span class="line">    sum += value; // 相当于result = Integer.valueOf(result.intValue() + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line">int sum = 0;</span><br><span class="line">int[] values = ...;</span><br><span class="line">for (int value : values) &#123;</span><br><span class="line">    sum += value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果变量的初始值会被覆盖，就没有必要给变量赋初值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">反例：</span><br><span class="line">List&lt;UserDO&gt; userList = new ArrayList&lt;&gt;();</span><br><span class="line">if (isAll) &#123;</span><br><span class="line">    userList = userDAO.queryAll();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    userList = userDAO.queryActive();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line">List&lt;UserDO&gt; userList;</span><br><span class="line">if (isAll) &#123;</span><br><span class="line">    userList = userDAO.queryAll();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    userList = userDAO.queryActive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尽量使用函数内的基本类型临时变量<br>在函数内，基本类型的参数和临时变量都保存在栈（Stack）中，访问速度较快；对象类型的参数和临时变量的引用都保存在栈（Stack）中，内容都保存在堆（Heap）中，访问速度较慢。在类中，任何类型的成员变量都保存在堆（Heap）中，访问速度较慢。<br>反例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final class Accumulator &#123;</span><br><span class="line">    private double result = 0.0D;</span><br><span class="line">    public void addAll(@NonNull double[] values) &#123;</span><br><span class="line">        for(double value : values) &#123;</span><br><span class="line">            result += value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>正例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final class Accumulator &#123;</span><br><span class="line">    private double result = 0.0D;</span><br><span class="line">    public void addAll(@NonNull double[] values) &#123;</span><br><span class="line">        double sum = 0.0D;</span><br><span class="line">        for(double value : values) &#123;</span><br><span class="line">            sum += value;</span><br><span class="line">        &#125;</span><br><span class="line">        result += sum;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/06/idea快捷键/" rel="next" title="idea快捷键">
                <i class="fa fa-chevron-left"></i> idea快捷键
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/06/Collection/" rel="prev" title="Collection">
                Collection <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">王靖尧</p>
              <div class="site-description motion-element" itemprop="description">一晃而过的时间，都做了些什么</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">104</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">34</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概念"><span class="nav-number">1.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#static"><span class="nav-number">1.1.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final"><span class="nav-number">1.2.</span> <span class="nav-text">final</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的重载"><span class="nav-number">1.3.</span> <span class="nav-text">函数的重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的重写"><span class="nav-number">1.4.</span> <span class="nav-text">函数的重写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造方法"><span class="nav-number">1.5.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#封装"><span class="nav-number">1.6.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">1.7.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态"><span class="nav-number">1.8.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口、抽象类区别"><span class="nav-number">1.9.</span> <span class="nav-text">接口、抽象类区别:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内部类"><span class="nav-number">1.10.</span> <span class="nav-text">内部类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正向和反向代理"><span class="nav-number">1.11.</span> <span class="nav-text">正向和反向代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#session和cookie的区别"><span class="nav-number">1.12.</span> <span class="nav-text">session和cookie的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#session的分布式处理"><span class="nav-number">1.13.</span> <span class="nav-text">session的分布式处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jdbc基本流程"><span class="nav-number">1.14.</span> <span class="nav-text">jdbc基本流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反射"><span class="nav-number">1.15.</span> <span class="nav-text">反射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this"><span class="nav-number">1.16.</span> <span class="nav-text">this</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#super"><span class="nav-number">1.17.</span> <span class="nav-text">super</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#super和this的异同"><span class="nav-number">1.18.</span> <span class="nav-text">super和this的异同</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#问题"><span class="nav-number">2.</span> <span class="nav-text">问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言？"><span class="nav-number">2.1.</span> <span class="nav-text">什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK和JRE的区别是什么？"><span class="nav-number">2.2.</span> <span class="nav-text">JDK和JRE的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#是否可以在static环境中访问非static变量？-不可以"><span class="nav-number">2.3.</span> <span class="nav-text">是否可以在static环境中访问非static变量？(不可以)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java支持的数据类型有哪些？什么是自动拆装箱？"><span class="nav-number">2.4.</span> <span class="nav-text">Java支持的数据类型有哪些？什么是自动拆装箱？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是值传递和引用传递？"><span class="nav-number">2.5.</span> <span class="nav-text">什么是值传递和引用传递？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程和线程的区别是什么？"><span class="nav-number">2.6.</span> <span class="nav-text">进程和线程的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是死锁-deadlock-？"><span class="nav-number">2.7.</span> <span class="nav-text">什么是死锁(deadlock)？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何确保N个线程可以访问N个资源同时又不导致死锁？"><span class="nav-number">2.8.</span> <span class="nav-text">如何确保N个线程可以访问N个资源同时又不导致死锁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是迭代器-Iterator-？"><span class="nav-number">2.9.</span> <span class="nav-text">什么是迭代器(Iterator)？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Iterator和ListIterator的区别是什么？"><span class="nav-number">2.10.</span> <span class="nav-text">Iterator和ListIterator的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中的HashMap的工作原理是什么？"><span class="nav-number">2.11.</span> <span class="nav-text">Java中的HashMap的工作原理是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中HashMap遍历的四种方式"><span class="nav-number">2.12.</span> <span class="nav-text">Java中HashMap遍历的四种方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用Array而不是ArrayList？"><span class="nav-number">2.13.</span> <span class="nav-text">数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList和LinkedList有什么区别？"><span class="nav-number">2.14.</span> <span class="nav-text">ArrayList和LinkedList有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#System-gc-和Runtime-gc-会做什么事情？"><span class="nav-number">2.15.</span> <span class="nav-text">System.gc()和Runtime.gc()会做什么事情？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆栈区别？"><span class="nav-number">2.16.</span> <span class="nav-text">堆栈区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是线程安全和不安全？"><span class="nav-number">2.17.</span> <span class="nav-text">什么是线程安全和不安全？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步和异步？"><span class="nav-number">2.18.</span> <span class="nav-text">同步和异步？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#九种基本数据类型的大小，以及他们的封装类-一个字节是8位"><span class="nav-number">2.19.</span> <span class="nav-text">九种基本数据类型的大小，以及他们的封装类(一个字节是8位)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#equals、-、hashcode-区别"><span class="nav-number">2.20.</span> <span class="nav-text">equals、==、hashcode  区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java的四种引用，强弱软虚，用到的场景"><span class="nav-number">2.21.</span> <span class="nav-text">Java的四种引用，强弱软虚，用到的场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hashcode的作用"><span class="nav-number">2.22.</span> <span class="nav-text">Hashcode的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String、StringBuffer与StringBuilder的区别。"><span class="nav-number">2.23.</span> <span class="nav-text">String、StringBuffer与StringBuilder的区别。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap和HashTable的区别"><span class="nav-number">2.24.</span> <span class="nav-text">HashMap和HashTable的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#token"><span class="nav-number">2.25.</span> <span class="nav-text">token</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java局部变量和成员变量名相同"><span class="nav-number">2.26.</span> <span class="nav-text">java局部变量和成员变量名相同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Iterator在遍历的时候删除List里的元素"><span class="nav-number">2.27.</span> <span class="nav-text">使用Iterator在遍历的时候删除List里的元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中的三元运算符"><span class="nav-number">2.28.</span> <span class="nav-text">Java中的三元运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#？？？"><span class="nav-number">2.29.</span> <span class="nav-text">？？？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自动拆箱问题"><span class="nav-number">2.30.</span> <span class="nav-text">自动拆箱问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合指定和不指定反省的区别"><span class="nav-number">2.31.</span> <span class="nav-text">集合指定和不指定反省的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将代码打成jar包"><span class="nav-number">2.32.</span> <span class="nav-text">将代码打成jar包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#遍历枚举类"><span class="nav-number">2.33.</span> <span class="nav-text">遍历枚举类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java实现Office系列文件转PDF文件"><span class="nav-number">2.34.</span> <span class="nav-text">Java实现Office系列文件转PDF文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#两个同名的jar包"><span class="nav-number">2.35.</span> <span class="nav-text">两个同名的jar包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读取pdf内容"><span class="nav-number">2.36.</span> <span class="nav-text">读取pdf内容</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#util"><span class="nav-number">3.</span> <span class="nav-text">util</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#时间戳"><span class="nav-number">3.1.</span> <span class="nav-text">时间戳</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lambda表达式"><span class="nav-number">4.</span> <span class="nav-text">Lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#环境准备"><span class="nav-number">4.1.</span> <span class="nav-text">环境准备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda表达式的语法"><span class="nav-number">4.2.</span> <span class="nav-text">Lambda表达式的语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是函数式接口"><span class="nav-number">4.3.</span> <span class="nav-text">什么是函数式接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法引用"><span class="nav-number">4.4.</span> <span class="nav-text">方法引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本的Lambda例子"><span class="nav-number">4.5.</span> <span class="nav-text">基本的Lambda例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Lambda对集合进行排序"><span class="nav-number">4.6.</span> <span class="nav-text">使用Lambda对集合进行排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Lambdas和Streams"><span class="nav-number">4.7.</span> <span class="nav-text">使用Lambdas和Streams</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#base64编码和解码"><span class="nav-number">5.</span> <span class="nav-text">base64编码和解码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#养成良好的编程习惯"><span class="nav-number">6.</span> <span class="nav-text">养成良好的编程习惯</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常量-amp-变量"><span class="nav-number">6.1.</span> <span class="nav-text">常量&amp;变量</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王靖尧</span>

  

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>




  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  



  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/algolia-search.js?v=7.1.0"></script>



  
  
  <script>
    
    function addCount(Counter) {
      var $visitors = $('.leancloud_visitors');
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', '/classes/Counter/' + counter.objectId, JSON.stringify({ time: { '__op': 'Increment', 'amount': 1 } }))
            
              .done(function() {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.time + 1);
              })
            
              .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
              })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1 }))
                .done(function() {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function() {
                  console.log('Failed to create');
                });
            
          }
        })
        .fail(function ({ responseJSON }) {
          console.log('LeanCloud Counter Error: ' + responseJSON.code + ' ' + responseJSON.error);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'DFKH5YVSHsNt0wDOVISahMVx-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: 'https://' + api_server + '/1.1' + url,
              headers: {
                'X-LC-Id': 'DFKH5YVSHsNt0wDOVISahMVx-gzGzoHsz',
                'X-LC-Key': 'ILHc2Y6O0p9xfqi3iAWMwnuv',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
          
            addCount(Counter);
          
        });
    });
  </script>



  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
