<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: 'UJCQ3PDF0F',
      apiKey: 'a3d4ab7cd60617bd0d524169bb08d56d',
      indexName: 'dev_ayanamiq',
      hits: {"per_page":10},
      labels: {"input_placeholder":"输入关键字","hits_empty":"没有找到关于 ${query} 的文章","hits_stats":"${hits} 相关记录，共耗时 ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="概述Docker是一个开源项目，诞生于2013年初，最初是dotCloud公司内部的一个业余项目。它基于Google公司推出的Go语言实现。项目后来加入了Linux基金会，遵从了Apache2.0协议，项目代码在GitHub上进行维护。 Docker项目的目标是实现轻量级的操作系统虚拟化解决方案。Docker的基础是Linux容器(LXC)等技术。在LXC的基础上Docker进行了进一步封装，让用">
<meta name="keywords" content="部署">
<meta property="og:type" content="article">
<meta property="og:title" content="docker">
<meta property="og:url" content="https://jingyao066.gitee.io/2019/03/05/docker/index.html">
<meta property="og:site_name" content="王靖尧的博客">
<meta property="og:description" content="概述Docker是一个开源项目，诞生于2013年初，最初是dotCloud公司内部的一个业余项目。它基于Google公司推出的Go语言实现。项目后来加入了Linux基金会，遵从了Apache2.0协议，项目代码在GitHub上进行维护。 Docker项目的目标是实现轻量级的操作系统虚拟化解决方案。Docker的基础是Linux容器(LXC)等技术。在LXC的基础上Docker进行了进一步封装，让用">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://jingyao066.gitee.io/2019/03/05/docker/1.png">
<meta property="og:image" content="https://jingyao066.gitee.io/2019/03/05/docker/7.png">
<meta property="og:image" content="https://jingyao066.gitee.io/2019/03/05/docker/8.png">
<meta property="og:image" content="https://jingyao066.gitee.io/2019/03/05/docker/2.png">
<meta property="og:image" content="https://jingyao066.gitee.io/2019/03/05/docker/3.png">
<meta property="og:image" content="https://jingyao066.gitee.io/2019/03/05/docker/4.png">
<meta property="og:image" content="https://jingyao066.gitee.io/2019/03/05/docker/5.png">
<meta property="og:image" content="https://jingyao066.gitee.io/2019/03/05/docker/6.png">
<meta property="og:updated_time" content="2020-04-07T05:49:44.446Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="docker">
<meta name="twitter:description" content="概述Docker是一个开源项目，诞生于2013年初，最初是dotCloud公司内部的一个业余项目。它基于Google公司推出的Go语言实现。项目后来加入了Linux基金会，遵从了Apache2.0协议，项目代码在GitHub上进行维护。 Docker项目的目标是实现轻量级的操作系统虚拟化解决方案。Docker的基础是Linux容器(LXC)等技术。在LXC的基础上Docker进行了进一步封装，让用">
<meta name="twitter:image" content="https://jingyao066.gitee.io/2019/03/05/docker/1.png">





  
  
  <link rel="canonical" href="https://jingyao066.gitee.io/2019/03/05/docker/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>docker | 王靖尧的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">王靖尧的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jingyao066.gitee.io/2019/03/05/docker/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王靖尧">
      <meta itemprop="description" content="一晃而过的时间，都做了些什么">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王靖尧的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">docker

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-05 10:26:24" itemprop="dateCreated datePublished" datetime="2019-03-05T10:26:24+08:00">2019-03-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-04-07 13:49:44" itemprop="dateModified" datetime="2020-04-07T13:49:44+08:00">2020-04-07</time>
              
            
          </span>

          

          
            
            
          

          
          
            <span id="/2019/03/05/docker/" class="leancloud_visitors" data-flag-title="docker">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Docker是一个开源项目，诞生于2013年初，最初是dotCloud公司内部的一个业余项目。它基于Google公司推出的Go语言实现。项目后来加入了Linux基金会，遵从了Apache2.0协议，项目代码在GitHub上进行维护。</p>
<p>Docker项目的目标是实现轻量级的操作系统虚拟化解决方案。Docker的基础是Linux容器(LXC)等技术。在LXC的基础上Docker进行了进一步封装，让用户不用去关心容器的管理，使得操作更为简便，用户操作docker容器就像操作一个轻量级虚拟机一样简单。</p>
<p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见docker是在操作系统上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。<br><img src="/2019/03/05/docker/1.png" alt=""></p>
<h1 id="为什么使用docker"><a href="#为什么使用docker" class="headerlink" title="为什么使用docker"></a>为什么使用docker</h1><p>作为一种新兴的虚拟化方式，docker跟传统的虚拟化方式相比具备众多的优势。</p>
<ul>
<li><p>更快速的交付和部署<br>Docker在整个开发周期都可以完美的辅助你实现快速交付。Docker允许开发者在装有应用和服务的本地容器中做开发，可以直接集成到可持续开发流程中。<br>例如：开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码。 Docker 可以快速创建容器，快速迭代应用程序，并让整个过程全程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。 Docker 容器很轻很快！容器的启动时间是秒级的，大量地节约开发、测试、部署的时间。</p>
</li>
<li><p>高效的部署和扩容<br>Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。<br>Docker的兼容性和轻量特性可以很轻松的实现负载的动态管理。你可以快速扩容或方便的下线的你的应用和服务，这种速度趋近实时。</p>
</li>
<li><p>更高的资源利用率<br>Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而Docker 只需要启动 10 个隔离的应用即可。</p>
</li>
<li><p>更简单的管理<br>使用 Docker，只需要小小的修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。</p>
</li>
</ul>
<p>举个最简单的例子：<br>传统的javaWeb应用是部署在tomcat中的，一个服务器可能运行多个tomcat，每个tomcat中有一个或多个web应用，那么此时docker就可以起到应用隔离和资源独立的作用。<br><img src="/2019/03/05/docker/7.png" alt=""></p>
<ul>
<li>如果不使用docker，一台服务器上多个tomcat，即A1，所有的应用共享服务器的CPU、内存等资源，这时如果一个应用出现问题，导致CPU爆满等等，其他应用也会无法运行。</li>
<li>那么这时就需要做到资源独立，一个应用一份资源，即我们所说的传统的虚拟化方式，即A2，这样需要在服务器上安装数个虚拟机，每个虚拟机运行一个应用，这样的缺点是，重启虚拟机太麻烦，迁移应用需要重装虚拟机，配置环境等等。</li>
<li>A3即使用docker，此时服务器上运行多个容器，每个容器都拥有独立的CPU、内存等资源，完全满足了应用隔离的需求，重启容器只需要几秒，迁移应用也很方便，所有装了Docker的服务器，只需把镜像pull或者load进去，run，就可以了。</li>
</ul>
<p><img src="/2019/03/05/docker/8.png" alt=""><br>上图是docker的运行流程</p>
<h1 id="docker引擎"><a href="#docker引擎" class="headerlink" title="docker引擎"></a>docker引擎</h1><p>docker引擎是一个c/s结构的应用，主要组件见下图：<br><img src="/2019/03/05/docker/2.png" alt=""></p>
<ul>
<li>server是一个常驻进程</li>
<li>REST API实现了server和client之间的交互协议</li>
<li>CLI实现容器和镜像的管理，为用户提供统一的管理界面</li>
</ul>
<h1 id="docker架构"><a href="#docker架构" class="headerlink" title="docker架构"></a>docker架构</h1><p>Docker使用C/S架构，Client 通过接口与Server进程通信实现容器的构建，运行和发布。client和server可以运行在同一台集群，也可以通过跨主机实现远程通信。<br><img src="/2019/03/05/docker/3.png" alt=""></p>
<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><ul>
<li>镜像(Image)</li>
</ul>
<p>docker镜像就是一个只读的模板，如：一个镜像可以包含一个完整的操作系统环境，里面仅安装了Apache或用户需要的其他应用程序。<br>镜像可以用来创建docker容器，一个镜像可以创建很多容器。Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。</p>
<p>镜像（Image）就是一堆只读层（read-only layer）的统一视角，也许这个定义有些难以理解，看看下面这张图：<br><img src="/2019/03/05/docker/4.png" alt=""><br>右边我们看到了多个只读层，它们重叠在一起。除了最上面一层，其它层都会有一个指针指向下一层。这些层是Docker内部的实现细节，并且能够在docker宿主机的文件系统上访问到。统一文件系统（Union File System）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。</p>
<ul>
<li>仓库(repository)<br>仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器混为一谈，并不严格区分。实际上，仓库注册服务器往往存放着多个仓库，每个仓库又包含了多个镜像，每个镜像有不同的标签(tag)。</li>
</ul>
<p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。国内的公开仓库包括 时速云 、网易云 等，可以提供大陆用户更稳定快速的访问。当然，用户也可以在本地网络内创建一个私有仓库。<br>当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。<br>Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。</p>
<ul>
<li>容器(container)<br>docker利用容器来运行应用。容器时从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。<br>容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。<br><img src="/2019/03/05/docker/5.png" alt=""><br>一个运行态容器被定义为一个可读写的统一文件系统加上隔离的进程空间和包含其中的进程。下面这张图片展示了一个运行中的容器。<br><img src="/2019/03/05/docker/6.png" alt=""><br>正是文件系统隔离技术使得Docker成为了一个非常有潜力的虚拟化技术。一个容器中的进程可能会对文件进行修改、删除、创建，这些改变都将作用于可读写层。</li>
</ul>
<h1 id="docker安装部署"><a href="#docker安装部署" class="headerlink" title="docker安装部署"></a>docker安装部署</h1><ul>
<li><p>Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。<br>通过 uname -r 命令查看你当前的内核版本<br><code>uname -r</code></p>
</li>
<li><p>使用 root 权限登录 Centos。确保 yum 包更新到最新。<br><code>sudo yum update</code></p>
</li>
<li><p>卸载旧版本(如果安装过旧版本的话)<br><code>sudo yum remove docker  docker-common docker-selinux docker-engine</code></p>
</li>
<li><p>安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的<br><code>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code></p>
</li>
<li><p>设置yum源<br>这是dockerHub上的镜像源：<br><code>sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code><br>我们使用阿里的镜像源：<br><code>sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></p>
</li>
<li><p>查看仓库中所有docker版本，并选择特定版本安装<br><code>yum list docker-ce --showduplicates | sort -r</code></p>
</li>
<li><p>安装docker<br><code>sudo yum install docker-ce</code>#由于repo中默认只开启stable仓库，故这里安装的是最新稳定版17.12.0<br>可以指定版本安装，如：<br><code>sudo yum install docker-ce-18.03.0.ce</code></p>
</li>
<li><p>启动并加入开机启动<br><code>sudo systemctl start docker</code><br><code>sudo systemctl enable docker</code></p>
</li>
<li><p>验证安装是否成功(有client和service两部分表示docker安装启动都成功了)<br><code>docker version</code></p>
</li>
</ul>
<h1 id="删除docker"><a href="#删除docker" class="headerlink" title="删除docker"></a>删除docker</h1><p><code>yum remove docker docker-common docker-selinux docker-engine -y</code><br><code>/etc/systemd -name &#39;*docker*&#39; -exec rm -f {} ;</code><br><code>find /etc/systemd -name &#39;*docker*&#39; -exec rm -f {} \;</code><br><code>find /lib/systemd -name &#39;*docker*&#39; -exec rm -f {} \;</code></p>
<h1 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p><code>docker pull</code><br>从仓库获取所需镜像，示例如下:<br><code>docker pull centos:centos6</code></p>
<p>实际上相当于 docker pull registry.hub.docker.com/centos:centos6<br>命令，即从注册服务器 registry.hub.docker.com 中的 centos 仓库来下载标记为 centos6 的镜像。<br>有时候官方仓库注册服务器下载较慢，可以从其他仓库下载。 从其它仓库下载时需要指定完整的仓库注册服务器地址。</p>
<p>docker默认从docker自己的服务器下载镜像，在国内自然是很慢。我们可以将镜像源替换成阿里的源。通过<code>daemon.json</code>这个文件配置镜像。<br>docker安装后默认没有daemon.json这个配置文件，需要进行手动创建。配置文件的默认路径：/etc/docker/daemon.json<br><code>touch /etc/docker/daemon.json</code><br><code>vim /etc/docker/daemon.json</code><br>输入如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://t21sxucj.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么从哪找这个地址呢？我们知道阿里云有提供docker镜像服务。</p>
<ul>
<li>登录阿里云（没有账号先注册）</li>
<li>找到容器镜像服务</li>
<li>点击创建镜像仓库</li>
<li>创建之后点击<code>镜像加速器</code>选项卡<br>在右侧可以看到配置镜像加速器，在下边可以看到想要的地址。</li>
</ul>
<p>配置完之后重启docker<br><code>systemctl restart docker</code><br>然后再<code>docker pull xxx</code>试试，体验飞一般的感觉。<br><a href="https://blog.csdn.net/weixin_43569697/article/details/89279225" target="_blank" rel="noopener">参考1</a><br><a href="https://blog.csdn.net/u013948858/article/details/79974796" target="_blank" rel="noopener">参考2</a></p>
<h2 id="查看镜像列表"><a href="#查看镜像列表" class="headerlink" title="查看镜像列表"></a>查看镜像列表</h2><p><code>docker images</code><br>列出了所有顶层（top-level）镜像。实际上，在这里我们没有办法区分一个镜像和一个只读层，所以我们提出了top-level镜像。<br>只有创建容器时使用的镜像或者是直接pull下来的镜像能被称为顶层（top-level）镜像，并且每一个顶层镜像下面都隐藏了多个镜像层。</p>
<p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                   centos6             6a77ab6655b9        8 weeks ago         194.6 MB</span><br><span class="line">ubuntu                   latest              2fa927b5cdd3        9 weeks ago         122 MB</span><br></pre></td></tr></table></figure></p>
<p>在列出信息中，可以看到几个字段信息</p>
<ul>
<li>来自于哪个仓库，比如 ubuntu</li>
<li>镜像的标记，比如 latest</li>
<li>它的 ID 号（唯一）</li>
<li>创建时间</li>
<li>镜像大小</li>
</ul>
<h2 id="利用dockerfile来创建镜像"><a href="#利用dockerfile来创建镜像" class="headerlink" title="利用dockerfile来创建镜像"></a>利用dockerfile来创建镜像</h2><p><code>docker build</code><br>使用 docker commit 来扩展一个镜像比较简单，但是不方便在一个团队中分享。我们可以使用docker build 来创建一个新的镜像。为此，首先需要创建一个Dockerfile，包含一些如何创建镜像的指令。新建一个目录和一个Dockerfile。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir test_docker</span><br><span class="line">cd test_docker</span><br><span class="line">touch Dockerfile</span><br></pre></td></tr></table></figure></p>
<p>Dockerfile 中每一条指令都创建镜像的一层，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:centos6</span><br><span class="line">MAINTAINER sandywei &lt;sandy@test.tech&gt;</span><br><span class="line"># move all configuration files into container</span><br><span class="line"></span><br><span class="line">RUN yum install -y httpd</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD [&quot;sh&quot;,&quot;-c&quot;,&quot;service httpd start;bash&quot;]</span><br></pre></td></tr></table></figure></p>
<h3 id="dockerfile基本语法："><a href="#dockerfile基本语法：" class="headerlink" title="dockerfile基本语法："></a>dockerfile基本语法：</h3><p>Dockfile是一个用于编写docker镜像生成过程的文件，其有特定的语法。在一个文件夹中，如果有一个名字为Dockfile的文件，其内容满足语法要求，在这个文件夹路径下执行命令:docker build –tag name:tag .，就可以按照描述构建一个镜像了。name是镜像的名称，tag是镜像的版本或者是标签号，不写就是lastest。注意后面有一个空格和点。<br>Dockerfile的基本指令有十三个，分别是：FROM、MAINTAINER、RUN、CMD、EXPOSE、ENV、ADD、COPY、ENTRYPOINT、VOLUME、USER、WORKDIR、ONBUILD。下面对这些指令的用法一一说明。</p>
<h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p>用法：FROM <image><br>说明：第一个指令必须是FROM了，其指定一个构建镜像的基础源镜像，如果本地没有就会从公共库中拉取，没有指定镜像的标签会使用默认的latest标签，可以出现多次，如果需要在一个Dockerfile中构建多个镜像。</image></p>
<h4 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h4><p>用法：MAINTAINER <name> <email><br>说明：描述镜像的创建者，名称和邮箱</email></name></p>
<h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p>用法：RUN “command” “param1” “param2”<br>说明：RUN命令是一个常用的命令，执行完成之后会成为一个新的镜像，这里也是指镜像的分层构建。一句RUN就是一层，也相当于一个版本。这就是之前说的缓存的原理。我们知道docker是镜像层是只读的，所以你如果第一句安装了软件，用完在后面一句删除是不可能的。所以这种情况要在一句RUN命令中完成，可以通过&amp;符号连接多个RUN语句。RUN后面的必须是双引号不能是单引号（没引号貌似也不要紧），command是不会调用shell的，所以也不会继承相应变量，要查看输入RUN “sh” “-c” “echo” “$HOME”，而不是RUN “echo” “$HOME”。</p>
<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>用法：CMD command param1 param2<br>说明：CMD在Dockerfile中只能出现一次，有多个，只有最后一个会有效。其作用是在启动容器的时候提供一个默认的命令项。如果用户执行docker run的时候提供了命令项，就会覆盖掉这个命令。没提供就会使用构建时的命令。</p>
<h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p>用法：EXPOSE <port> [<port>…]<br>说明：告诉Docker服务器容器对外映射的容器端口号，在docker run -p的时候生效。</port></port></p>
<h4 id="EVN"><a href="#EVN" class="headerlink" title="EVN"></a>EVN</h4><p>用法：EVN <key> <value> 只能设置一个</value></key></p>
<pre><code>EVN &lt;key&gt;=&lt;value&gt;允许一次设置多个
</code></pre><p>说明：设置容器的环境变量，可以让其后面的RUN命令使用，容器运行的时候这个变量也会保留。</p>
<h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>用法：ADD <src>   <dest><br>说明：复制本机文件或目录或远程文件，添加到指定的容器目录，支持GO的正则模糊匹配。路径是绝对路径，不存在会自动创建。如果源是一个目录，只会复制目录下的内容，目录本身不会复制。ADD命令会将复制的压缩文件夹自动解压，这也是与COPY命令最大的不同。</dest></src></p>
<h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><p>用法：COPY <src> <dest><br>说明：COPY除了不能自动解压，也不能复制网络文件。其它功能和ADD相同。</dest></src></p>
<h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>用法：ENTRYPOINT “command” “param1” “param2”<br>说明：这个命令和CMD命令一样，唯一的区别是不能被docker run命令的执行命令覆盖，如果要覆盖需要带上选项–entrypoint，如果有多个选项，只有最后一个会生效。</p>
<h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p>用法：VOLUME [“path”]<br>说明：在主机上创建一个挂载，挂载到容器的指定路径。docker run -v命令也能完成这个操作，而且更强大。这个命令不能指定主机的需要挂载到容器的文件夹路径。但docker run -v可以，而且其还可以挂载数据容器。</p>
<h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><p>用法：USER daemon<br>说明：指定运行容器时的用户名或UID，后续的RUN、CMD、ENTRYPOINT也会使用指定的用户运行命令。</p>
<h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>用法:WORKDIR path<br>说明：为RUN、CMD、ENTRYPOINT指令配置工作目录。可以使用多个WORKDIR指令，后续参数如果是相对路径，则会基于之前的命令指定的路径。如：WORKDIR  /home　　WORKDIR test 。最终的路径就是/home/test。path路径也可以是环境变量，比如有环境变量HOME=/home，WORKDIR $HOME/test也就是/home/test。</p>
<h4 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h4><p>用法：ONBUILD [INSTRUCTION]<br>说明：配置当前所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。意思就是，这个镜像创建后，如果其它镜像以这个镜像为基础，会先执行这个镜像的ONBUILD命令。</p>
<h3 id="Dockerfile例子"><a href="#Dockerfile例子" class="headerlink" title="Dockerfile例子"></a>Dockerfile例子</h3><p>一个使用安装包安装的tomcat例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER nobody &quot;xx@qq.com&quot;</span><br><span class="line">RUN mkdir -p /opt/jdk/</span><br><span class="line">RUN mkdir -p /opt/tomcat/</span><br><span class="line">ADD jdk1.7.0_79 /opt/jdk/</span><br><span class="line">ADD tomcat  /opt/tomcat/</span><br><span class="line">ENV CATALINA_HOME /opt/tomcat</span><br><span class="line">ENV JAVA_HOME /opt/jdk</span><br><span class="line">EXPOSE 8080</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin</span><br><span class="line">CMD [&quot;/opt/tomcat/bin/catalina.sh&quot;,&quot;run&quot;]</span><br></pre></td></tr></table></figure></p>
<p>更详细的语法说明请参考 <a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></p>
<p>编写完成 Dockerfile 后可以使用 docker build 来生成镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t test/httpd:1.0 .</span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM centos:centos6</span><br><span class="line"> ---&gt; 6a77ab6655b9</span><br><span class="line">Step 2 : MAINTAINER sandywei &lt;sandy@test.tech&gt;</span><br><span class="line"> ---&gt; Running in 1b26493518a7</span><br><span class="line"> ---&gt; 8877ee5f7432</span><br><span class="line">Removing intermediate container 1b26493518a7</span><br><span class="line">Step 3 : RUN yum install -y httpd</span><br><span class="line"> ---&gt; Running in fe5b6f1ef888</span><br><span class="line"></span><br><span class="line"> .....</span><br><span class="line"></span><br><span class="line"> Step 5 : CMD sh -c service httpd start</span><br><span class="line"> ---&gt; Running in b2b94c1601c2</span><br><span class="line"> ---&gt; 5f9aa91b0c9e</span><br><span class="line">Removing intermediate container b2b94c1601c2</span><br><span class="line">Successfully built 5f9aa91b0c9e</span><br></pre></td></tr></table></figure></p>
<p>其中 -t 标记来添加 tag，指定新的镜像的用户信息。 “.” 是 Dockerfile 所在的路径（当前目录），<br>也可以替换为一个具体的 Dockerfile 的路径。注意一个镜像不能超过 127 层。</p>
<p>用docker images 查看镜像列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY                 TAG               IMAGE ID            CREATED             SIZE</span><br><span class="line">test/httpd               1.0               5f9aa91b0c9e        3 minutes ago       292.4 MB</span><br><span class="line">centos                   centos6             6a77ab6655b9        8 weeks ago         194.6 MB</span><br><span class="line">ubuntu                   latest              2fa927b5cdd3        9 weeks ago         122 MB</span><br></pre></td></tr></table></figure></p>
<p>可以发现最后一层的ID（5f9aa91b0c9e）和 image id是一样的</p>
<h2 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h2><p><code>docker push</code><br>用户可以通过 docker push 命令，把自己创建的镜像上传到仓库中来共享。例如，用户在 Docker Hub 上完成注册后，可以推送自己的镜像到仓库中。</p>
<p>运行实例：<br><code>$ docker push test/httpd:1.0</code></p>
<h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><p><code>docker create &lt;image-id&gt;</code><br>docker create 命令为指定的镜像（image）添加了一个可读写层，构成了一个新的容器。注意，这个容器并没有运行。</p>
<p>docker create 命令提供了许多参数选项可以指定名字，硬件资源，网络配置等等。</p>
<p>如：<br>创建一个centos的容器，可以使用仓库＋标签的名字确定image，也可以使用image－id指定image。返回容器id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">＃查看本地images列表</span><br><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line">＃用仓库＋标签</span><br><span class="line">$ docker create -it --name centos6_container centos:centos6</span><br><span class="line"></span><br><span class="line">＃使用image－id</span><br><span class="line">$ docker create -it --name centos6_container 6a77ab6655b9 bash</span><br><span class="line">b3cd0b47fe3db0115037c5e9cf776914bd46944d1ac63c0b753a9df6944c7a67</span><br><span class="line"></span><br><span class="line">#可以使用 docker ps查看一件存在的容器列表,不加参数默认只显示当前运行的容器</span><br><span class="line">$ docker ps -a</span><br></pre></td></tr></table></figure></p>
<p>可以使用 -v 参数将本地目录挂载到容器中。<br><code>$ docker create -it --name centos6_container -v /src/webapp:/opt/webapp centos:centos6</code><br>这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，如果目录不存在 Docker 会自动为你创建它。</p>
<p>docker -v 挂载问题：<br>Docker容器启动的时候，如果要挂载宿主机的一个目录，可以用-v参数指定。<br>譬如我要启动一个centos容器，宿主机的/test目录挂载到容器的/soft目录，可通过以下方式指定：<br><code>docker run -it -v /test:/soft centos /bin/bash</code><br>这样在容器启动后，容器内会自动创建/soft的目录。通过这种方式，我们可以明确一点，即-v参数中，冒号”:”前面的目录是宿主机目录，后面的目录是容器内目录。<br>貌似简单，其实不然，下面我们来验证一下：</p>
<ul>
<li>容器目录不可以为相对路径<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run -it -v /test:soft centos /bin/bash</span><br><span class="line">invalid value &quot;/test:soft&quot; for flag -v: soft is not an absolute path</span><br><span class="line">See &apos;docker run --help&apos;.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>直接报错，提示soft不是一个绝对路径，所谓的绝对路径，必须以下斜线“/”开头。</p>
<ul>
<li>宿主机目录如果不存在，则会自动生成<br>如果宿主机中存在/test目录，首先删除它<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rm -rf /test</span><br><span class="line">[root@localhost ~]# ls /</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>启动容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run -it -v /test:/soft centos /bin/bash</span><br><span class="line">[root@a487a3ca7997 /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  soft  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure></p>
<p>查看宿主机，发现新增了一个/test目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls /</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  test  tmp  usr  var</span><br></pre></td></tr></table></figure></p>
<ul>
<li>宿主机的目录如果为相对路径呢？<br>这次，我们换个目录名test1试试<br><code>docker run -it -v test1:/soft centos /bin/bash</code><br>再到宿主机上查看是否新增了一个/test1目录，结果没有，是不是因为我用的是相对路径，所以生成的test1目录在当前目录下，结果发现还是没有。<br>那容器内的/soft目录挂载到哪里去了？通过docker inspect命令，查看容器“Mounts”那一部分，我们可以得到这个问题的答案。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Name&quot;: &quot;test1&quot;,</span><br><span class="line">            &quot;Source&quot;: &quot;/var/lib/docker/volumes/test1/_data&quot;,</span><br><span class="line">            &quot;Destination&quot;: &quot;/soft&quot;,</span><br><span class="line">            &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">            &quot;Mode&quot;: &quot;z&quot;,</span><br><span class="line">            &quot;RW&quot;: true</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看出，容器内的/soft目录挂载的是宿主机上的/var/lib/docker/volumes/test1/_data目录，原来所谓的相对路径指的是/var/lib/docker/volumes/，与宿主机的当前目录无关。</p>
<ul>
<li>如果只是-v指定一个目录，这个又是如何对应呢？<br>启动一个容器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run -it -v /test2 centos /bin/bash</span><br><span class="line">[root@ea24067bc902 /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  test2  tmp  usr  var</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>同样使用docker inspect命令查看宿主机的挂载目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Name&quot;: &quot;96256232eb74edb139d652746f0fe426e57fbacdf73376963e3acdb411b3d73a&quot;,</span><br><span class="line">            &quot;Source&quot;: &quot;/var/lib/docker/volumes/96256232eb74edb139d652746f0fe426e57fbacdf73376963e3acdb411b3d73a/_data&quot;,</span><br><span class="line">            &quot;Destination&quot;: &quot;/test2&quot;,</span><br><span class="line">            &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">            &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;RW&quot;: true</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure></p>
<p>可以看出，同3中的结果类似，只不过，它不是相对路径的目录名，而是随机生成的一个目录名。</p>
<ul>
<li>如果在容器内修改了目录的属主和属组，那么对应的挂载点是否会修改呢？<br>首先开启一个容器，查看容器内/soft目录的属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run -it -v /test:/soft centos /bin/bash</span><br><span class="line">[root@b5ed8216401f /]# ll -d /soft/</span><br><span class="line">drwxr-xr-x 2 root root 6 Sep 24 03:48 /soft/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>查看宿主机内/test目录的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll -d /test/</span><br><span class="line">drwxr-xr-x 2 root root 6 Sep 24 11:48 /test/</span><br></pre></td></tr></table></figure></p>
<p>在容器内新建用户，修改/soft的属主和属组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@b5ed8216401f /]# useradd victor</span><br><span class="line">[root@b5ed8216401f /]# chown -R victor.victor /soft/</span><br><span class="line">[root@b5ed8216401f /]# ll -d /soft/</span><br><span class="line">drwxr-xr-x 2 victor victor 6 Sep 24 03:48 /soft/</span><br></pre></td></tr></table></figure></p>
<p>再来看看宿主机内/test目录的属主和属组是否会发生变化？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll -d /test/</span><br><span class="line">drwxr-xr-x 2 mycat mycat 6 Sep 24 11:48 /test/</span><br></pre></td></tr></table></figure></p>
<p>竟然变为mycat了。。。<br>原来，这个与UID有关系，UID，即“用户标识号”，是一个整数，系统内部用它来标识用户。一般情况下它与用户名是一一对应的。<br>首先查看容器内victor对应的UID是多少，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@b5ed8216401f /]# cat /etc/passwd | grep victor</span><br><span class="line">victor:x:1000:1000::/home/victor:/bin/bash</span><br></pre></td></tr></table></figure></p>
<p>victor的UID为1000，那么宿主机内1000对应的用户是谁呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/passwd |grep 1000</span><br><span class="line">mycat:x:1000:1000::/home/mycat:/bin/bash</span><br></pre></td></tr></table></figure></p>
<p>可以看出，宿主机内UID 1000对应的用户是mycat。</p>
<ul>
<li>容器销毁了，在宿主机上新建的挂载目录是否会消失？<br>在这里，主要验证两种情况：一、指定了宿主机目录，即 -v /test:/soft。二、没有指定宿主机目录，即-v /soft<br>第一种情况：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rm -rf /test    --首先删除宿主机的/test目录</span><br><span class="line">[root@localhost ~]# ls /    --可以看到，宿主机上无/test目录</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@localhost ~]# docker run -it --name=centos_test -v /test:/soft centos /bin/bash  --启动容器，为了删除方便，我用--name参数指定了容器的名字</span><br><span class="line">[root@82ad7f3a779a /]# exit</span><br><span class="line">exit</span><br><span class="line">[root@localhost ~]# docker rm centos_test   --删除容器</span><br><span class="line">centos_test</span><br><span class="line">[root@localhost ~]# ls /   --发现 /test目录依旧存在</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  test  tmp  usr  var</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看出，即便容器销毁了，新建的挂载目录不会消失。进一步也可验证，如果宿主机目录的属主和属组发生了变化，容器销毁后，宿主机目录的属主和属组不会恢复到挂载之前的状态。</p>
<p>第二种情况，通过上面的验证知道，如果没有指定宿主机的目录，则容器会在/var/lib/docker/volumes/随机配置一个目录，那么我们看看这种情况下的容器销毁是否会导致相应目录的删除<br>首先启动容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run -it --name=centos_test -v /soft centos /bin/bash</span><br><span class="line">[root@6b75579ec934 /]# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></p>
<p>通过docker inspect命令查看容器在宿主机上生成的挂载目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Name&quot;: &quot;b53164cb1c9f1917788638692fb22ad11994cf1fbbc2461b6c390cd3e10ea301&quot;,</span><br><span class="line">            &quot;Source&quot;: &quot;/var/lib/docker/volumes/b53164cb1c9f1917788638692fb22ad11994cf1fbbc2461b6c390cd3e10ea301/_data&quot;,</span><br><span class="line">            &quot;Destination&quot;: &quot;/soft&quot;,</span><br><span class="line">            &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">            &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;RW&quot;: true</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure></p>
<p>对应的是/var/lib/docker/volumes/b53164cb1c9f1917788638692fb22ad11994cf1fbbc2461b6c390cd3e10ea301/_data目录<br>销毁容器，看目录是否存在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker rm centos_test</span><br><span class="line">centos_test</span><br><span class="line">[root@localhost ~]# ll /var/lib/docker/volumes/b53164cb1c9f1917788638692fb22ad11994cf1fbbc2461b6c390cd3e10ea301</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 2 root root 6 Sep 24 14:25 _data</span><br></pre></td></tr></table></figure></p>
<p>发现该目录依旧存在，即便重启了docker服务，该目录依旧存在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# systemctl restart docker</span><br><span class="line">[root@localhost ~]# ll /var/lib/docker/volumes/b53164cb1c9f1917788638692fb22ad11994cf1fbbc2461b6c390cd3e10ea301</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 2 root root 6 Sep 24 14:25 _data</span><br></pre></td></tr></table></figure></p>
<ul>
<li>挂载宿主机已存在目录后，在容器内对其进行操作，报“Permission denied”。<br>可通过两种方式解决：</li>
</ul>
<p>1&gt; 关闭selinux。<br>临时关闭：# setenforce 0<br>永久关闭：修改/etc/sysconfig/selinux文件，将SELINUX的值设置为disabled。</p>
<p>2&gt; 以特权方式启动容器<br>指定–privileged参数<br>如：# docker run -it –privileged=true -v /test:/soft centos /bin/bash</p>
<p><a href="https://www.cnblogs.com/ivictor/p/4834864.html" target="_blank" rel="noopener">docker挂载参考地址</a></p>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p><code>docker start &lt;container-id&gt;</code><br>Docker start命令为容器文件系统创建了一个进程隔离空间。注意，每一个容器只能够有一个进程隔离空间。</p>
<p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#通过名字启动</span><br><span class="line">$ docker start -i centos6_container</span><br><span class="line"></span><br><span class="line">＃通过容器ID启动</span><br><span class="line">$ docker start -i b3cd0b47fe3d</span><br></pre></td></tr></table></figure></p>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p><code>docker exec &lt;container-id&gt;</code></p>
<p>在当前容器中执行新命令，如果增加 -it参数运行bash 就和登录到容器效果一样的。<br><code>docker exec -it centos6_container bash</code></p>
<h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><p><code>docker stop &lt;container-id&gt;</code></p>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p><code>docker rm &lt;container-id&gt;</code></p>
<h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p><code>docker run &lt;image-id&gt;</code></p>
<p>docker run就是docker create和docker start两个命令的组合,支持参数也是一致的，如果指定容器<br>名字是，容器已经存在会报错,可以增加 –rm 参数实现容器退出时自动删除。</p>
<p>如：<br><code>docker create -it --rm --name centos6_container centos:centos6</code></p>
<h2 id="查看容器列表"><a href="#查看容器列表" class="headerlink" title="查看容器列表"></a>查看容器列表</h2><p><code>docker ps</code><br>docker ps 命令会列出所有运行中的容器。这隐藏了非运行态容器的存在，如果想要找出这些容器，增加-a参数。</p>
<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><p><code>docker rmi &lt;image-id&gt;</code></p>
<p>删除构成镜像的一个只读层。你只能够使用docker rmi来移除最顶层（top level layer）<br>（也可以说是镜像），你也可以使用-f参数来强制删除中间的只读层。</p>
<h2 id="commit容器"><a href="#commit容器" class="headerlink" title="commit容器"></a>commit容器</h2><p><code>docker commit &lt;container-id&gt;</code><br>将容器的可读写层转换为一个只读层，这样就把一个容器转换成了不可变的镜像。</p>
<h2 id="镜像保存"><a href="#镜像保存" class="headerlink" title="镜像保存"></a>镜像保存</h2><p><code>docker save &lt;image-id&gt;</code></p>
<p>创建一个镜像的压缩文件，这个文件能够在另外一个主机的Docker上使用。和export命令不同，这个命令<br>为每一个层都保存了它们的元数据。这个命令只能对镜像生效。</p>
<p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#保存centos镜像到centos_images.tar 文件</span><br><span class="line">$ docker save  -o centos_images.tar centos:centos6</span><br><span class="line"></span><br><span class="line">＃或者直接重定向</span><br><span class="line">$ docker save  -o centos_images.tar centos:centos6 &gt; centos_images.tar</span><br></pre></td></tr></table></figure></p>
<h2 id="容器导出"><a href="#容器导出" class="headerlink" title="容器导出"></a>容器导出</h2><p><code>docker export &lt;container-id&gt;</code></p>
<p>创建一个tar文件，并且移除了元数据和不必要的层，将多个层整合成了一个层，只保存了当前统一视角看到<br>的内容。expoxt后的容器再import到Docker中，只有一个容器当前状态的镜像；而save后的镜像则不同，<br>它能够看到这个镜像的历史镜像。</p>
<h2 id="inspect"><a href="#inspect" class="headerlink" title="inspect"></a>inspect</h2><p><code>docker inspect &lt;container-id&gt; or &lt;image-id&gt;</code><br>docker inspect命令会提取出容器或者镜像最顶层的元数据</p>
<h1 id="docker安装指定版本TAG的镜像"><a href="#docker安装指定版本TAG的镜像" class="headerlink" title="docker安装指定版本TAG的镜像"></a>docker安装指定版本TAG的镜像</h1><p>在docker中安装镜像，一般过程是，docker search 软件名称。<br>本文以tomcat为例，讲解下载指定版本TAG的tomcat。</p>
<p>搜索tomcat镜像：<br><code>sudo docker search tomcat</code></p>
<p>发现只有tomcat，而如果docker pull tomcat，下载下来的是最新版的tomcat,也就是tomcat11。假设希望下载的是tomcat:8-jre8。那么该如何做呢？<br>如果search出来的镜像，不是自己想要的版本，可通过在docker hub上搜索好版本TAG，地址如下：<a href="https://hub.docker.com，进入之后，在页面左上角搜索框搜索`tomcat`，" target="_blank" rel="noopener">https://hub.docker.com，进入之后，在页面左上角搜索框搜索`tomcat`，</a><br>搜索出来之后，点详情，点击标签，在下面通过翻页，找到8-jre标签，复制标签名：8-jre8，下载tomcat镜像<br><code>sudo docker pull tomcat:8-jre8</code></p>
<h1 id="var-lib-docker-overlay2-占用过大"><a href="#var-lib-docker-overlay2-占用过大" class="headerlink" title="/var/lib/docker/overlay2 占用过大"></a>/var/lib/docker/overlay2 占用过大</h1><p>查看磁盘使用情况<br><code>sudo du -hs /var/lib/docker/</code></p>
<p>查看Docker的磁盘使用情况<br><code>docker system df</code></p>
<p>清理磁盘，删除关闭的容器、无用的数据卷和网络，以及dangling镜像(即无tag的镜像)<br><code>docker system prune</code></p>
<p>docker system prune -a命令清理得更加彻底，可以将没有容器使用Docker镜像都删掉。注意，这两个命令会把你暂时关闭的容器，以及暂时没有用到的Docker镜像都删掉了…所以使用之前一定要想清楚.。我没用过，因为会清理 没有开启的  Docker 镜像。</p>
<h2 id="迁移-var-lib-docker目录"><a href="#迁移-var-lib-docker目录" class="headerlink" title="迁移 /var/lib/docker目录"></a>迁移 /var/lib/docker目录</h2><p>停止docker服务<br><code>systemctl stop docker</code></p>
<p>创建新的docker目录，执行命令df -h,找一个大的磁盘。 我在 /home目录下面建了 /home/docker/lib目录，执行的命令是：<br><code>mkdir -p /home/docker/lib</code></p>
<p>迁移/var/lib/docker目录下面的文件到 /home/docker/lib<br><code>rsync -avz /var/lib/docker /home/docker/lib/</code></p>
<p>配置 /etc/systemd/system/docker.service.d/devicemapper.conf。查看 devicemapper.conf 是否存在。如果不存在，就新建<br><code>sudo mkdir -p /etc/systemd/system/docker.service.d/</code><br><code>sudo vi /etc/systemd/system/docker.service.d/devicemapper.conf</code></p>
<p>然后在 devicemapper.conf 写入：（同步的时候把父文件夹一并同步过来，实际上的目录应在 /home/docker/lib/docker）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/dockerd  --graph=/home/docker/lib/docker</span><br></pre></td></tr></table></figure></p>
<p>重新加载 docker<br><code>systemctl daemon-reload</code><br><code>systemctl restart docker</code><br><code>systemctl enable docker</code></p>
<p>为了确认一切顺利，运行<br><code>docker info</code></p>
<p>命令检查Docker 的根目录.它将被更改为 /home/docker/lib/docker<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Docker Root Dir: /home/docker/lib/docker</span><br><span class="line">Debug Mode (client): false</span><br><span class="line">Debug Mode (server): false</span><br><span class="line">Registry: https://index.docker.io/v1/</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>启动成功后，再确认之前的镜像还在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">linlf@dacent:~$ docker images</span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">AAA/AAA               v2                  7331b8651bcc        27 hours ago        3.85GB</span><br><span class="line">BBB/BBB               v1                  da4a80dd8424        28 hours ago        3.47GB</span><br></pre></td></tr></table></figure></p>
<p>确定容器没问题后删除/var/lib/docker/目录中的文件。</p>
<h1 id="Docker和K8S"><a href="#Docker和K8S" class="headerlink" title="Docker和K8S"></a>Docker和K8S</h1><p><a href="https://my.oschina.net/jamesview/blog/2994112" target="_blank" rel="noopener">参考地址</a></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/部署/" rel="tag"># 部署</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/15/multithreading-synchronized/" rel="next" title="multithreading-synchronized">
                <i class="fa fa-chevron-left"></i> multithreading-synchronized
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/05/linux基础/" rel="prev" title="linux基础">
                linux基础 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">王靖尧</p>
              <div class="site-description motion-element" itemprop="description">一晃而过的时间，都做了些什么</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">104</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">34</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么使用docker"><span class="nav-number">2.</span> <span class="nav-text">为什么使用docker</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker引擎"><span class="nav-number">3.</span> <span class="nav-text">docker引擎</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker架构"><span class="nav-number">4.</span> <span class="nav-text">docker架构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#核心概念"><span class="nav-number">5.</span> <span class="nav-text">核心概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker安装部署"><span class="nav-number">6.</span> <span class="nav-text">docker安装部署</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#删除docker"><span class="nav-number">7.</span> <span class="nav-text">删除docker</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker常用命令"><span class="nav-number">8.</span> <span class="nav-text">docker常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#获取镜像"><span class="nav-number">8.1.</span> <span class="nav-text">获取镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查看镜像列表"><span class="nav-number">8.2.</span> <span class="nav-text">查看镜像列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用dockerfile来创建镜像"><span class="nav-number">8.3.</span> <span class="nav-text">利用dockerfile来创建镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dockerfile基本语法："><span class="nav-number">8.3.1.</span> <span class="nav-text">dockerfile基本语法：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FROM"><span class="nav-number">8.3.1.1.</span> <span class="nav-text">FROM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MAINTAINER"><span class="nav-number">8.3.1.2.</span> <span class="nav-text">MAINTAINER</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RUN"><span class="nav-number">8.3.1.3.</span> <span class="nav-text">RUN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMD"><span class="nav-number">8.3.1.4.</span> <span class="nav-text">CMD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EXPOSE"><span class="nav-number">8.3.1.5.</span> <span class="nav-text">EXPOSE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EVN"><span class="nav-number">8.3.1.6.</span> <span class="nav-text">EVN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ADD"><span class="nav-number">8.3.1.7.</span> <span class="nav-text">ADD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#COPY"><span class="nav-number">8.3.1.8.</span> <span class="nav-text">COPY</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ENTRYPOINT"><span class="nav-number">8.3.1.9.</span> <span class="nav-text">ENTRYPOINT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VOLUME"><span class="nav-number">8.3.1.10.</span> <span class="nav-text">VOLUME</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#USER"><span class="nav-number">8.3.1.11.</span> <span class="nav-text">USER</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WORKDIR"><span class="nav-number">8.3.1.12.</span> <span class="nav-text">WORKDIR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ONBUILD"><span class="nav-number">8.3.1.13.</span> <span class="nav-text">ONBUILD</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dockerfile例子"><span class="nav-number">8.3.2.</span> <span class="nav-text">Dockerfile例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#上传镜像"><span class="nav-number">8.4.</span> <span class="nav-text">上传镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建容器"><span class="nav-number">8.5.</span> <span class="nav-text">创建容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启动容器"><span class="nav-number">8.6.</span> <span class="nav-text">启动容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进入容器"><span class="nav-number">8.7.</span> <span class="nav-text">进入容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#停止容器"><span class="nav-number">8.8.</span> <span class="nav-text">停止容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除容器"><span class="nav-number">8.9.</span> <span class="nav-text">删除容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行容器"><span class="nav-number">8.10.</span> <span class="nav-text">运行容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查看容器列表"><span class="nav-number">8.11.</span> <span class="nav-text">查看容器列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除镜像"><span class="nav-number">8.12.</span> <span class="nav-text">删除镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#commit容器"><span class="nav-number">8.13.</span> <span class="nav-text">commit容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#镜像保存"><span class="nav-number">8.14.</span> <span class="nav-text">镜像保存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器导出"><span class="nav-number">8.15.</span> <span class="nav-text">容器导出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#inspect"><span class="nav-number">8.16.</span> <span class="nav-text">inspect</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#docker安装指定版本TAG的镜像"><span class="nav-number">9.</span> <span class="nav-text">docker安装指定版本TAG的镜像</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#var-lib-docker-overlay2-占用过大"><span class="nav-number">10.</span> <span class="nav-text">/var/lib/docker/overlay2 占用过大</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#迁移-var-lib-docker目录"><span class="nav-number">10.1.</span> <span class="nav-text">迁移 /var/lib/docker目录</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker和K8S"><span class="nav-number">11.</span> <span class="nav-text">Docker和K8S</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王靖尧</span>

  

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>




  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  



  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/algolia-search.js?v=7.1.0"></script>



  
  
  <script>
    
    function addCount(Counter) {
      var $visitors = $('.leancloud_visitors');
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', '/classes/Counter/' + counter.objectId, JSON.stringify({ time: { '__op': 'Increment', 'amount': 1 } }))
            
              .done(function() {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.time + 1);
              })
            
              .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
              })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1 }))
                .done(function() {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function() {
                  console.log('Failed to create');
                });
            
          }
        })
        .fail(function ({ responseJSON }) {
          console.log('LeanCloud Counter Error: ' + responseJSON.code + ' ' + responseJSON.error);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'DFKH5YVSHsNt0wDOVISahMVx-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: 'https://' + api_server + '/1.1' + url,
              headers: {
                'X-LC-Id': 'DFKH5YVSHsNt0wDOVISahMVx-gzGzoHsz',
                'X-LC-Key': 'ILHc2Y6O0p9xfqi3iAWMwnuv',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
          
            addCount(Counter);
          
        });
    });
  </script>



  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
