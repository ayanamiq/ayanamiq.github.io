<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="一晃而过的时间，都做了些什么">
<meta name="keywords" content="JAVA">
<meta property="og:type" content="website">
<meta property="og:title" content="王靖尧的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="王靖尧的博客">
<meta property="og:description" content="一晃而过的时间，都做了些什么">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="王靖尧的博客">
<meta name="twitter:description" content="一晃而过的时间，都做了些什么">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>王靖尧的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">王靖尧的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            日程表
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            站点地图
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/06/日常/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王靖尧">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王靖尧的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/日常/" itemprop="url">日常</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-06T18:28:27+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-input设置为disabled，后台无法接受到数据"><a href="#1-input设置为disabled，后台无法接受到数据" class="headerlink" title="1.input设置为disabled，后台无法接受到数据"></a>1.input设置为disabled，后台无法接受到数据</h3><p> W3C的规范，<br>disabled=”disabled” 不能想后台提交<br> 改为 readonly = “readonly” 即可</p>
<h3 id="2-两种收集表单数据的方式"><a href="#2-两种收集表单数据的方式" class="headerlink" title="2.两种收集表单数据的方式"></a>2.两种收集表单数据的方式</h3><p>1.$(“#addForm”).serialize<br>将表单数据收集成json字符串，name=小红&amp;age=25    的形式</p>
<p>2.$(“#addForm”).serializeArray();<br>以数组形式收集表单数据，这个方法可以通过push方法向结果集中添加数据<br>如果想提交表单之外的数据，可以用这种方式。<br>dataParam.push({“name”: “specName”, “value”: specName});<br>另外：需要在ajax的中设置参数<br>traditional: true,</p>
<h3 id="3-idea-断点问题"><a href="#3-idea-断点问题" class="headerlink" title="3.idea 断点问题"></a>3.idea 断点问题</h3><p>当前项目处于分布式环境，在其中一个服务 打上断点后，如果debug选项卡切换到其他提供者上，<br>注意是debug的选项卡，会发现断点失效了，f8和f9都不好用<br>正常的断点标识是：一个小红圈，中间有个对勾，表明当前断点生效。<br>失效后的断点:红圈内的对勾没有了。<br>此时切回断点所在服务的debug选项卡即可。坑啊</p>
<h3 id="4-Js实现返回上一页并刷新"><a href="#4-Js实现返回上一页并刷新" class="headerlink" title="4.Js实现返回上一页并刷新"></a>4.Js实现返回上一页并刷新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.location=document.referrer</span><br></pre></td></tr></table></figure>
<h3 id="5-复选框全选，全不选"><a href="#5-复选框全选，全不选" class="headerlink" title="5.复选框全选，全不选"></a>5.复选框全选，全不选</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#checkAll&apos;).click(function()&#123; </span><br><span class="line">	    $(&quot;.checkSon&quot;).prop(&quot;checked&quot;,this.checked); </span><br><span class="line">	&#125;);</span><br><span class="line">//用attr不行,因为jq版本问题,复选框最好用prop</span><br></pre></td></tr></table></figure>
<h3 id="6-限制input框输入只能为非负数且不能有小数点"><a href="#6-限制input框输入只能为非负数且不能有小数点" class="headerlink" title="6.限制input框输入只能为非负数且不能有小数点"></a>6.限制input框输入只能为非负数且不能有小数点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;number&quot; name=&quot;quantity&quot; value=&quot;1&quot; min=&apos;1&apos; onkeyup=&quot;onlyNonNegative(this)&quot;/&gt;</span><br><span class="line">//通过2步做到输入的为非负数</span><br><span class="line">//1.去掉多余的小数点</span><br><span class="line">//2.保证只能输入小数点或数字</span><br><span class="line">function onlyNonNegative(obj) &#123;</span><br><span class="line">    var inputChar = event.keyCode;</span><br><span class="line">    //alert(event.keyCode);</span><br><span class="line">    //1.判断是否有多于一个小数点</span><br><span class="line">    if (inputChar == 190) &#123;//输入的是否为.</span><br><span class="line">        var index1 = obj.value.indexOf(&quot;.&quot;) + 1;//取第一次出现.的后一个位置</span><br><span class="line">        if (index1 == 1) &#123;//如果第一个值就是点</span><br><span class="line">            obj.value = obj.value.replace(/[^\d]/g, &apos;&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">        var index2 = obj.value.indexOf(&quot;.&quot;, index1);</span><br><span class="line">        while (index2 != -1) &#123;</span><br><span class="line">            //alert(&quot;有多个.&quot;);</span><br><span class="line">            obj.value = obj.value.substring(0, index2);</span><br><span class="line">            index2 = obj.value.indexOf(&quot;.&quot;, index1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //2.如果输入的不是.或者不是数字，替换 g:全局替换</span><br><span class="line">    obj.value = obj.value.replace(/[^\d]/g, &apos;&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-使用Iterator在遍历的时候删除List里的元素"><a href="#7-使用Iterator在遍历的时候删除List里的元素" class="headerlink" title="7.使用Iterator在遍历的时候删除List里的元素"></a>7.使用Iterator在遍历的时候删除List里的元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void iteratorRemove() &#123;</span><br><span class="line">        List&lt;Student&gt; students = this.getStudents();</span><br><span class="line">        System.out.println(students);</span><br><span class="line">        Iterator&lt;Student&gt; stuIter = students.iterator();</span><br><span class="line">        while (stuIter.hasNext()) &#123;</span><br><span class="line">            Student student = stuIter.next();</span><br><span class="line">            if (student.getId() % 2 == 0)</span><br><span class="line">                stuIter.remove();//这里要使用Iterator的remove方法移除当前对象，如果使用List的remove方法，则同样会出现ConcurrentModificationException</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(students);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-选中颜色添加边框-相邻的去除边框"><a href="#8-选中颜色添加边框-相邻的去除边框" class="headerlink" title="8.选中颜色添加边框,相邻的去除边框"></a>8.选中颜色添加边框,相邻的去除边框</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getColor(obj)&#123;</span><br><span class="line">			$(obj).siblings(&apos;div&apos;).removeClass(&apos;selected&apos;);</span><br><span class="line">			$(obj).addClass(&apos;selected&apos;);</span><br><span class="line">		&#125;</span><br><span class="line">规定一个css属性</span><br><span class="line">.selected&#123;</span><br><span class="line">		      border:3px solid #339999 !important;</span><br><span class="line">		   &#125;	</span><br><span class="line">Html</span><br><span class="line">&lt;div onclick=&quot;getColor(this)&quot;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="9-pagehelper有的时候有效果-有时候没有效果"><a href="#9-pagehelper有的时候有效果-有时候没有效果" class="headerlink" title="9.pagehelper有的时候有效果,有时候没有效果"></a>9.pagehelper有的时候有效果,有时候没有效果</h3><p>pagehelper只对紧跟着的第一个sql语句起作用<br>所以直接把PageHelper.startPage(pageNum,pageSize)放在需要分页的语句后面</p>
<h3 id="10-JQ获取选中复选框的值"><a href="#10-JQ获取选中复选框的值" class="headerlink" title="10.JQ获取选中复选框的值"></a>10.JQ获取选中复选框的值</h3><p>本以为：<br><code>var arr = $(&#39;input[name=&quot;ck&quot;]:checked&#39;).val();</code><br>返回的直接是一个数组，错了。必须<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var checkArr = [];</span><br><span class="line">$(&apos;input[name=&quot;ck&quot;]:checked&apos;).each(function(index,i)&#123;</span><br><span class="line">      checkArr.push(i);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&quot;选中的&quot;+checkArr.length);</span><br></pre></td></tr></table></figure></p>
<p>选中之后遍历，向数组中push</p>
<h3 id="11-vue给input绑定value值"><a href="#11-vue给input绑定value值" class="headerlink" title="11.vue给input绑定value值"></a>11.vue给input绑定value值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr v-for=&quot;business in businessList.list&quot;&gt;</span><br><span class="line">      &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;ck&quot; :value=&quot;business.id&quot;&gt;&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;&#123;&#123;business.businessName&#125;&#125;&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;&#123;&#123;business.businessMobile&#125;&#125;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure>
<h3 id="12-JQ-ajax向后台传递数组"><a href="#12-JQ-ajax向后台传递数组" class="headerlink" title="12.JQ ajax向后台传递数组"></a>12.JQ ajax向后台传递数组</h3><p>因为jQuery需要调用jQuery.param序列化参数，jQuery.param( obj, traditional )，<br>默认的话，traditional为false，即jquery会深度序列化参数对象，我们可以通过设置traditional 为true阻止深度序列化，然后序列化结果如下：<br>p: [“123”, “456”, “789”]    =&gt;    p=123&amp;p=456&amp;p=456<br>随即，我们就可以在后台通过request.getParameterValues()来获取参数的值数组了，<br>所以，比如我们前台有多个checkbox，前台的代码可以写成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var values = $(&quot;input[type=checkbox]&quot;).map(function()&#123;</span><br><span class="line">      return $(this).val();</span><br><span class="line">&#125;).get();</span><br><span class="line">$.ajax&#123;</span><br><span class="line">      url:&quot;xxxx&quot;,</span><br><span class="line">      traditional: true,</span><br><span class="line">      data:&#123;</span><br><span class="line">            p: values </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="13-td中的内容，超出长度显示省略号"><a href="#13-td中的内容，超出长度显示省略号" class="headerlink" title="13.td中的内容，超出长度显示省略号"></a>13.td中的内容，超出长度显示省略号</h3><p>内容必须包在p标签中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.msg&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">&#125;</span><br><span class="line">&lt;td&gt;</span><br><span class="line">    &lt;p class=&quot;msg&quot;&gt;</span><br><span class="line">         $&#123;(i.message)!&apos;&apos;&#125;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/td&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="14-ajax-提交富文本-数据截断"><a href="#14-ajax-提交富文本-数据截断" class="headerlink" title="14.ajax 提交富文本 数据截断"></a>14.ajax 提交富文本 数据截断</h3><p>富文本中有特殊符号，如：&amp;，富文本的字符串会被截断。<br>解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var data = $(&quot;#addForm&quot;).serializeArray();</span><br><span class="line">var content =  $.trim($(&apos;#summernote&apos;).summernote(&apos;code&apos;));</span><br><span class="line">data.push(&#123;&quot;name&quot;: &quot;content&quot;, &quot;value&quot;: content&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="15-DTO内部类的问题"><a href="#15-DTO内部类的问题" class="headerlink" title="15.DTO内部类的问题"></a>15.DTO内部类的问题</h3><p>在使用DTO的时候，为了简洁，使用了静态内部类。<br><img src="https://user-images.githubusercontent.com/21356733/47355981-697e0c00-d6f5-11e8-8878-297e0e5cb5fe.png" alt="default"></p>
<p>但是由于内部类中的属性是私有的，所以无法在外部访问。<br>这样，如果我们使用ModelAndView返回数据，页面使用诸如el表达式访问数据，<br>会出现无法访问的问题。</p>
<p>解决办法：不使用静态内部类</p>
<h3 id="16-MyBatis的xml判断"><a href="#16-MyBatis的xml判断" class="headerlink" title="16.MyBatis的xml判断"></a>16.MyBatis的xml判断</h3><p><img src="https://user-images.githubusercontent.com/21356733/47829740-de230b80-ddc3-11e8-8a1a-df6fba37eaae.png" alt="_20181101104948"></p>
<p>mybatis判断int类型时，不可以加  != ‘’  非空判断。<br>否则判断会失效，不会进入到判断中</p>
<h3 id="17-Mybatis报错"><a href="#17-Mybatis报错" class="headerlink" title="17.Mybatis报错"></a>17.Mybatis报错</h3><p><code>The content of element type &quot;resultMap&quot; must match &quot;(constructor?,id*,result*,association*,collection*,discriminator?)&quot;</code></p>
<p>resultMap中各元素的顺序修改为和错误信息中属性出现的顺序<br>( constructor ,  id   result  association …..)一致<br>一对一映射必须写在一对多映射前边</p>
<h3 id="18-npm-install-报错"><a href="#18-npm-install-报错" class="headerlink" title="18.npm install 报错"></a>18.npm install 报错</h3><p>今天在使用npm安装hexo时，因为刚开始初始化hexo时文件夹位置错误，于是把错误的文件夹删掉，之后在新的文件夹中初始化hexo<br><code>hexo init hexoBlog</code><br>报如下错误：<br><img src="https://user-images.githubusercontent.com/21356733/49430154-40b56000-f7e5-11e8-890e-b4a7574b0382.png" alt="_20181204165236"><br>百度多种方法无果，最终解决办法：<br>1.安装指令<br><code>npm install --registry=https://registry.npm.taobao.org --loglevel=silly</code><br>2.清除缓存<br>‘2.npm cache clean –force’</p>
<p>然后ok~<br>总结：遇到报错，要先从第一个错误开始逐一排查，不要从下面开始，往往下面的错误就是上面的错误导致的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/06/Lambda表达式入门/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王靖尧">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王靖尧的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/Lambda表达式入门/" itemprop="url">Lambda表达式入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-06T18:26:54+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##简介<br>其实Lambda表达式的本质只是一个”语法糖”，由编译器推断并帮你转换包装为常见的代码，因此可以使用更少的代码来实现同样的功能。<br>(建议不要乱用,因为这就和某些很高级的黑客写的代码一样,简洁,难懂,难以调试,维护人员想骂娘)<br>Lambda表达式是Java SE 8中一个重要的新特性。lambda表达式允许你通过表达式来代替功能接口。<br>lambda表达式就和方法一样,它提供了一个正常的参数列表和一个使用这些参数的主体(body,可以是一个表达式或一个代码块)。<br>Lambda表达式还增强了集合库。<br>Java SE 8添加了2个对集合数据进行批量操作的包: java.util.function 包以及 java.util.stream 包。<br>流(stream)就如同迭代器(iterator),但附加了许多额外的功能。<br> 总的来说,lambda表达式和 stream 是自Java语言添加泛型(Generics)和注解(annotation)以来最大的变化。<br>在本文中,我们将从简单到复杂的示例中见认识lambda表达式和stream的强悍。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>必须安装jdk1.8以上版本..</p>
<h3 id="Lambda表达式的语法"><a href="#Lambda表达式的语法" class="headerlink" title="Lambda表达式的语法"></a>Lambda表达式的语法</h3><p>基本语法:<br>(parameters) -&gt; expression<br>或<br>(parameters) -&gt;{ statements; }</p>
<p>简单例子：<br>// 1. 不需要参数,返回值为 5<br>() -&gt; 5</p>
<p>// 2. 接收一个参数(数字类型),返回其2倍的值<br>x -&gt; 2 * x</p>
<p>// 3. 接受2个参数(数字),并返回他们的差值<br>(x, y) -&gt; x – y</p>
<p>// 4. 接收2个int型整数,返回他们的和<br>(int x, int y) -&gt; x + y</p>
<p>// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)<br>(String s) -&gt; System.out.print(s)</p>
<h3 id="基本的Lambda例子"><a href="#基本的Lambda例子" class="headerlink" title="基本的Lambda例子"></a>基本的Lambda例子</h3><p>假设有一个玩家List ,程序员可以使用 for 语句 (“for 循环”)来遍历,在Java SE 8中可以转换为另一种形式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String[] atp = &#123;&quot;小明&quot;,&quot;小红&quot;, &quot;小黑&quot;, &quot;小白&quot;,&quot;小兰&quot;, &quot;小强&quot;,&quot;小绿&quot;, &quot;小小&quot;&#125;;</span><br><span class="line">        List&lt;String&gt; players =  Arrays.asList(atp);</span><br><span class="line"></span><br><span class="line">        // 以前的循环方式</span><br><span class="line">//        for (String player : players) &#123;</span><br><span class="line">//            System.out.print(player + &quot;; &quot;);</span><br><span class="line">//        &#125;</span><br><span class="line"></span><br><span class="line">        //使用lambda表达式以及函数操作(functional operation)</span><br><span class="line">        //players.forEach((player) -&gt; System.out.println(player + &quot;;&quot;));</span><br><span class="line"></span><br><span class="line">        //在JAVA 8 中使用双冒号操作符(double colon operator)</span><br><span class="line">        //players.forEach(System.out::println);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//下面是使用lambdas 来实现 Runnable接口 的示例:</span><br><span class="line">        // 1.1使用匿名内部类</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;Hello world !&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        // 1.2使用 lambda expression</span><br><span class="line">        new Thread(() -&gt; System.out.println(&quot;Hello world !&quot;)).start();</span><br><span class="line"></span><br><span class="line">        // 2.1使用匿名内部类</span><br><span class="line">        Runnable race1 = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;Hello world !&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        // 2.2使用 lambda expression</span><br><span class="line">        Runnable race2 = () -&gt; System.out.println(&quot;Hello world !&quot;);</span><br><span class="line"></span><br><span class="line">        // 直接调用 run 方法(没开新线程哦!)</span><br><span class="line">        race1.run();</span><br><span class="line">        race2.run();</span><br></pre></td></tr></table></figure>
<h3 id="使用Lambda对集合进行排序"><a href="#使用Lambda对集合进行排序" class="headerlink" title="使用Lambda对集合进行排序"></a>使用Lambda对集合进行排序</h3><p>在java中，Comparator 类被用来排序集合，<br>在下面的例子中,我们将根据球员的 name, surname, name 长度 以及最后一个字母。 和前面的示例一样,先使用匿名内部类来排序,然后再使用lambda表达式精简我们的代码。<br>在第一个例子中,我们将根据name来排序list。 使用旧的方式,代码如下所示:</p>
<p>String[] atp = {“小明”,”小红”, “小黑”, “小白”,”小兰”, “小强”,”小绿”, “小小”};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1.1 使用匿名内部类根据 name 排序 players  </span><br><span class="line">Arrays.sort(players, new Comparator&lt;String&gt;() &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public int compare(String s1, String s2) &#123;  </span><br><span class="line">        return (s1.compareTo(s2));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>使用lambdas,可以通过下面的代码实现同样的功能:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1.2 使用 lambda expression 排序 players  </span><br><span class="line">Comparator&lt;String&gt; sortByName = (String s1, String s2) -&gt; (s1.compareTo(s2));  </span><br><span class="line">Arrays.sort(players, sortByName);  </span><br><span class="line">  </span><br><span class="line">// 1.3 也可以采用如下形式:  </span><br><span class="line">Arrays.sort(players, (String s1, String s2) -&gt; (s1.compareTo(s2)));</span><br></pre></td></tr></table></figure></p>
<p>其他的排序如下所示。 和上面的示例一样,代码分别通过匿名内部类和一些lambda表达式来实现Comparator :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 1.1 使用匿名内部类根据 surname 排序 players  </span><br><span class="line">Arrays.sort(players, new Comparator&lt;String&gt;() &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public int compare(String s1, String s2) &#123;  </span><br><span class="line">        return (s1.substring(s1.indexOf(&quot; &quot;)).compareTo(s2.substring(s2.indexOf(&quot; &quot;))));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line">// 1.2 使用 lambda expression 排序,根据 surname  </span><br><span class="line">Comparator&lt;String&gt; sortBySurname = (String s1, String s2) -&gt;   </span><br><span class="line">    ( s1.substring(s1.indexOf(&quot; &quot;)).compareTo( s2.substring(s2.indexOf(&quot; &quot;)) ) );  </span><br><span class="line">Arrays.sort(players, sortBySurname);  </span><br><span class="line">  </span><br><span class="line">// 1.3 或者这样,怀疑原作者是不是想错了,括号好多...  </span><br><span class="line">Arrays.sort(players, (String s1, String s2) -&gt;   </span><br><span class="line">      ( s1.substring(s1.indexOf(&quot; &quot;)).compareTo( s2.substring(s2.indexOf(&quot; &quot;)) ) )   </span><br><span class="line">    );  </span><br><span class="line">  </span><br><span class="line">// 2.1 使用匿名内部类根据 name lenght 排序 players  </span><br><span class="line">Arrays.sort(players, new Comparator&lt;String&gt;() &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public int compare(String s1, String s2) &#123;  </span><br><span class="line">        return (s1.length() - s2.length());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line">// 2.2 使用 lambda expression 排序,根据 name lenght  </span><br><span class="line">Comparator&lt;String&gt; sortByNameLenght = (String s1, String s2) -&gt; (s1.length() - s2.length());  </span><br><span class="line">Arrays.sort(players, sortByNameLenght);  </span><br><span class="line">  </span><br><span class="line">// 2.3 or this  </span><br><span class="line">Arrays.sort(players, (String s1, String s2) -&gt; (s1.length() - s2.length()));  </span><br><span class="line">  </span><br><span class="line">// 3.1 使用匿名内部类排序 players, 根据最后一个字母  </span><br><span class="line">Arrays.sort(players, new Comparator&lt;String&gt;() &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public int compare(String s1, String s2) &#123;  </span><br><span class="line">        return (s1.charAt(s1.length() - 1) - s2.charAt(s2.length() - 1));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line">// 3.2 使用 lambda expression 排序,根据最后一个字母  </span><br><span class="line">Comparator&lt;String&gt; sortByLastLetter =   </span><br><span class="line">    (String s1, String s2) -&gt;   </span><br><span class="line">        (s1.charAt(s1.length() - 1) - s2.charAt(s2.length() - 1));  </span><br><span class="line">Arrays.sort(players, sortByLastLetter);  </span><br><span class="line">  </span><br><span class="line">// 3.3 or this  </span><br><span class="line">Arrays.sort(players, (String s1, String s2) -&gt; (s1.charAt(s1.length() - 1) - s2.charAt(s2.length() - 1)));</span><br></pre></td></tr></table></figure></p>
<p>就是这样,简洁又直观。 在下一节中我们将探索更多lambdas的能力,并将其与 stream 结合起来使用。</p>
<h3 id="使用Lambdas和Streams"><a href="#使用Lambdas和Streams" class="headerlink" title="使用Lambdas和Streams"></a>使用Lambdas和Streams</h3><p>Stream是对集合的包装,通常和lambda一起使用。<br> 使用lambdas可以支持许多操作,如 map, filter, limit, sorted, count, min, max, sum, collect 等等。<br>同样,Stream使用懒运算,他们并不会真正地读取所有数据,遇到像getFirst() 这样的方法就会结束链式语法。<br>在接下来的例子中,我们将探索lambdas和streams 能做什么。<br>我们创建了一个Person类并使用这个类来添加一些数据到list中,将用于进一步流操作。<br>Person 只是一个简单的POJO类:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;  </span><br><span class="line">  </span><br><span class="line">private String firstName, lastName, job, gender;  </span><br><span class="line">private int salary, age;  </span><br><span class="line">  </span><br><span class="line">public Person(String firstName, String lastName, String job,  </span><br><span class="line">                String gender, int age, int salary)       &#123;  </span><br><span class="line">          this.firstName = firstName;  </span><br><span class="line">          this.lastName = lastName;  </span><br><span class="line">          this.gender = gender;  </span><br><span class="line">          this.age = age;  </span><br><span class="line">          this.job = job;  </span><br><span class="line">          this.salary = salary;  </span><br><span class="line">&#125;  </span><br><span class="line">// Getter and Setter   </span><br><span class="line">// . . . . .  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来,我们将创建两个list,都用来存放Person对象:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; javaProgrammers = new ArrayList&lt;Person&gt;() &#123;  </span><br><span class="line">  &#123;  </span><br><span class="line">    add(new Person(&quot;Elsdon&quot;, &quot;Jaycob&quot;, &quot;Java programmer&quot;, &quot;male&quot;, 43, 2000));  </span><br><span class="line">    add(new Person(&quot;Tamsen&quot;, &quot;Brittany&quot;, &quot;Java programmer&quot;, &quot;female&quot;, 23, 1500));  </span><br><span class="line">    add(new Person(&quot;Floyd&quot;, &quot;Donny&quot;, &quot;Java programmer&quot;, &quot;male&quot;, 33, 1800));  </span><br><span class="line">    add(new Person(&quot;Sindy&quot;, &quot;Jonie&quot;, &quot;Java programmer&quot;, &quot;female&quot;, 32, 1600));  </span><br><span class="line">    add(new Person(&quot;Vere&quot;, &quot;Hervey&quot;, &quot;Java programmer&quot;, &quot;male&quot;, 22, 1200));  </span><br><span class="line">    add(new Person(&quot;Maude&quot;, &quot;Jaimie&quot;, &quot;Java programmer&quot;, &quot;female&quot;, 27, 1900));  </span><br><span class="line">    add(new Person(&quot;Shawn&quot;, &quot;Randall&quot;, &quot;Java programmer&quot;, &quot;male&quot;, 30, 2300));  </span><br><span class="line">    add(new Person(&quot;Jayden&quot;, &quot;Corrina&quot;, &quot;Java programmer&quot;, &quot;female&quot;, 35, 1700));  </span><br><span class="line">    add(new Person(&quot;Palmer&quot;, &quot;Dene&quot;, &quot;Java programmer&quot;, &quot;male&quot;, 33, 2000));  </span><br><span class="line">    add(new Person(&quot;Addison&quot;, &quot;Pam&quot;, &quot;Java programmer&quot;, &quot;female&quot;, 34, 1300));  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">List&lt;Person&gt; phpProgrammers = new ArrayList&lt;Person&gt;() &#123;  </span><br><span class="line">  &#123;  </span><br><span class="line">    add(new Person(&quot;Jarrod&quot;, &quot;Pace&quot;, &quot;PHP programmer&quot;, &quot;male&quot;, 34, 1550));  </span><br><span class="line">    add(new Person(&quot;Clarette&quot;, &quot;Cicely&quot;, &quot;PHP programmer&quot;, &quot;female&quot;, 23, 1200));  </span><br><span class="line">    add(new Person(&quot;Victor&quot;, &quot;Channing&quot;, &quot;PHP programmer&quot;, &quot;male&quot;, 32, 1600));  </span><br><span class="line">    add(new Person(&quot;Tori&quot;, &quot;Sheryl&quot;, &quot;PHP programmer&quot;, &quot;female&quot;, 21, 1000));  </span><br><span class="line">    add(new Person(&quot;Osborne&quot;, &quot;Shad&quot;, &quot;PHP programmer&quot;, &quot;male&quot;, 32, 1100));  </span><br><span class="line">    add(new Person(&quot;Rosalind&quot;, &quot;Layla&quot;, &quot;PHP programmer&quot;, &quot;female&quot;, 25, 1300));  </span><br><span class="line">    add(new Person(&quot;Fraser&quot;, &quot;Hewie&quot;, &quot;PHP programmer&quot;, &quot;male&quot;, 36, 1100));  </span><br><span class="line">    add(new Person(&quot;Quinn&quot;, &quot;Tamara&quot;, &quot;PHP programmer&quot;, &quot;female&quot;, 21, 1000));  </span><br><span class="line">    add(new Person(&quot;Alvin&quot;, &quot;Lance&quot;, &quot;PHP programmer&quot;, &quot;male&quot;, 38, 1600));  </span><br><span class="line">    add(new Person(&quot;Evonne&quot;, &quot;Shari&quot;, &quot;PHP programmer&quot;, &quot;female&quot;, 40, 1800));  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在我们使用forEach方法来迭代输出上述列表:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;所有程序员的姓名:&quot;);  </span><br><span class="line">javaProgrammers.forEach((p) -&gt; System.out.printf(&quot;%s %s; &quot;, p.getFirstName(), p.getLastName()));  </span><br><span class="line">phpProgrammers.forEach((p) -&gt; System.out.printf(&quot;%s %s; &quot;, p.getFirstName(), p.getLastName()));</span><br></pre></td></tr></table></figure></p>
<p>我们同样使用forEach方法,增加程序员的工资5%:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;给程序员加薪 5% :&quot;);  </span><br><span class="line">Consumer&lt;Person&gt; giveRaise = e -&gt; e.setSalary(e.getSalary() / 100 * 5 + e.getSalary());  </span><br><span class="line">  </span><br><span class="line">javaProgrammers.forEach(giveRaise);  </span><br><span class="line">phpProgrammers.forEach(giveRaise);</span><br></pre></td></tr></table></figure></p>
<p>另一个有用的方法是过滤器filter() ,让我们显示月薪超过1400美元的PHP程序员:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;下面是月薪超过 $1,400 的PHP程序员:&quot;)  </span><br><span class="line">phpProgrammers.stream()  </span><br><span class="line">          .filter((p) -&gt; (p.getSalary() &gt; 1400))  </span><br><span class="line">          .forEach((p) -&gt; System.out.printf(&quot;%s %s; &quot;, p.getFirstName(), p.getLastName()));</span><br></pre></td></tr></table></figure></p>
<p>我们也可以定义过滤器,然后重用它们来执行其他操作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 定义 filters  </span><br><span class="line">Predicate&lt;Person&gt; ageFilter = (p) -&gt; (p.getAge() &gt; 25);  </span><br><span class="line">Predicate&lt;Person&gt; salaryFilter = (p) -&gt; (p.getSalary() &gt; 1400);  </span><br><span class="line">Predicate&lt;Person&gt; genderFilter = (p) -&gt; (&quot;female&quot;.equals(p.getGender()));  </span><br><span class="line">  </span><br><span class="line">System.out.println(&quot;下面是年龄大于 24岁且月薪在$1,400以上的女PHP程序员:&quot;);  </span><br><span class="line">phpProgrammers.stream()  </span><br><span class="line">          .filter(ageFilter)  </span><br><span class="line">          .filter(salaryFilter)  </span><br><span class="line">          .filter(genderFilter)  </span><br><span class="line">          .forEach((p) -&gt; System.out.printf(&quot;%s %s; &quot;, p.getFirstName(), p.getLastName()));  </span><br><span class="line">  </span><br><span class="line">// 重用filters  </span><br><span class="line">System.out.println(&quot;年龄大于 24岁的女性 Java programmers:&quot;);  </span><br><span class="line">javaProgrammers.stream()  </span><br><span class="line">          .filter(ageFilter)  </span><br><span class="line">          .filter(genderFilter)  </span><br><span class="line">          .forEach((p) -&gt; System.out.printf(&quot;%s %s; &quot;, p.getFirstName(), p.getLastName()));</span><br></pre></td></tr></table></figure></p>
<p>使用limit方法,可以限制结果集的个数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;最前面的3个 Java programmers:&quot;);  </span><br><span class="line">javaProgrammers.stream()  </span><br><span class="line">          .limit(3)  </span><br><span class="line">          .forEach((p) -&gt; System.out.printf(&quot;%s %s; &quot;, p.getFirstName(), p.getLastName()));  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">System.out.println(&quot;最前面的3个女性 Java programmers:&quot;);  </span><br><span class="line">javaProgrammers.stream()  </span><br><span class="line">          .filter(genderFilter)  </span><br><span class="line">          .limit(3)  </span><br><span class="line">          .forEach((p) -&gt; System.out.printf(&quot;%s %s; &quot;, p.getFirstName(), p.getLastName()));</span><br></pre></td></tr></table></figure></p>
<p>排序呢? 我们在stream中能处理吗? 答案是肯定的。 在下面的例子中,我们将根据名字和薪水排序Java程序员,放到一个list中,然后显示列表:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;根据 name 排序,并显示前5个 Java programmers:&quot;);  </span><br><span class="line">List&lt;Person&gt; sortedJavaProgrammers = javaProgrammers  </span><br><span class="line">          .stream()  </span><br><span class="line">          .sorted((p, p2) -&gt; (p.getFirstName().compareTo(p2.getFirstName())))  </span><br><span class="line">          .limit(5)  </span><br><span class="line">          .collect(toList());  </span><br><span class="line">  </span><br><span class="line">sortedJavaProgrammers.forEach((p) -&gt; System.out.printf(&quot;%s %s; %n&quot;, p.getFirstName(), p.getLastName()));  </span><br><span class="line">   </span><br><span class="line">System.out.println(&quot;根据 salary 排序 Java programmers:&quot;);  </span><br><span class="line">sortedJavaProgrammers = javaProgrammers  </span><br><span class="line">          .stream()  </span><br><span class="line">          .sorted( (p, p2) -&gt; (p.getSalary() - p2.getSalary()) )  </span><br><span class="line">          .collect( toList() );  </span><br><span class="line">  </span><br><span class="line">sortedJavaProgrammers.forEach((p) -&gt; System.out.printf(&quot;%s %s; %n&quot;, p.getFirstName(), p.getLastName()));</span><br></pre></td></tr></table></figure></p>
<p>如果我们只对最低和最高的薪水感兴趣,比排序后选择第一个/最后一个 更快的是min和max方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;工资最低的 Java programmer:&quot;);  </span><br><span class="line">Person pers = javaProgrammers  </span><br><span class="line">          .stream()  </span><br><span class="line">          .min((p1, p2) -&gt; (p1.getSalary() - p2.getSalary()))  </span><br><span class="line">          .get()  </span><br><span class="line">  </span><br><span class="line">System.out.printf(&quot;Name: %s %s; Salary: $%,d.&quot;, pers.getFirstName(), pers.getLastName(), pers.getSalary())  </span><br><span class="line">  </span><br><span class="line">System.out.println(&quot;工资最高的 Java programmer:&quot;);  </span><br><span class="line">Person person = javaProgrammers  </span><br><span class="line">          .stream()  </span><br><span class="line">          .max((p, p2) -&gt; (p.getSalary() - p2.getSalary()))  </span><br><span class="line">          .get()  </span><br><span class="line">  </span><br><span class="line">System.out.printf(&quot;Name: %s %s; Salary: $%,d.&quot;, person.getFirstName(), person.getLastName(), person.getSalary())</span><br></pre></td></tr></table></figure></p>
<p>上面的例子中我们已经看到 collect 方法是如何工作的。 结合 map 方法,我们可以使用 collect 方法来将我们的结果集放到一个字符串,一个 Set 或一个TreeSet中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;将 PHP programmers 的 first name 拼接成字符串:&quot;);  </span><br><span class="line">String phpDevelopers = phpProgrammers  </span><br><span class="line">          .stream()  </span><br><span class="line">          .map(Person::getFirstName)  </span><br><span class="line">          .collect(joining(&quot; ; &quot;)); // 在进一步的操作中可以作为标记(token)     </span><br><span class="line">  </span><br><span class="line">System.out.println(&quot;将 Java programmers 的 first name 存放到 Set:&quot;);  </span><br><span class="line">Set&lt;String&gt; javaDevFirstName = javaProgrammers  </span><br><span class="line">          .stream()  </span><br><span class="line">          .map(Person::getFirstName)  </span><br><span class="line">          .collect(toSet());  </span><br><span class="line">  </span><br><span class="line">System.out.println(&quot;将 Java programmers 的 first name 存放到 TreeSet:&quot;);  </span><br><span class="line">TreeSet&lt;String&gt; javaDevLastName = javaProgrammers  </span><br><span class="line">          .stream()  </span><br><span class="line">          .map(Person::getLastName)  </span><br><span class="line">          .collect(toCollection(TreeSet::new));</span><br></pre></td></tr></table></figure></p>
<p>Streams 还可以是并行的(parallel)。 示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;计算付给 Java programmers 的所有money:&quot;);  </span><br><span class="line">int totalSalary = javaProgrammers  </span><br><span class="line">          .parallelStream()  </span><br><span class="line">          .mapToInt(p -&gt; p.getSalary())  </span><br><span class="line">          .sum();</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用summaryStatistics方法获得stream 中元素的各种汇总数据。 接下来,我们可以访问这些方法,比如getMax, getMin, getSum或getAverage:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//计算 count, min, max, sum, and average for numbers  </span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);  </span><br><span class="line">IntSummaryStatistics stats = numbers  </span><br><span class="line">          .stream()  </span><br><span class="line">          .mapToInt((x) -&gt; x)  </span><br><span class="line">          .summaryStatistics();  </span><br><span class="line">  </span><br><span class="line">System.out.println(&quot;List中最大的数字 : &quot; + stats.getMax());  </span><br><span class="line">System.out.println(&quot;List中最小的数字 : &quot; + stats.getMin());  </span><br><span class="line">System.out.println(&quot;所有数字的总和   : &quot; + stats.getSum());  </span><br><span class="line">System.out.println(&quot;所有数字的平均值 : &quot; + stats.getAverage());</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/06/Spring的一些概念/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王靖尧">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王靖尧的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/Spring的一些概念/" itemprop="url">Spring的一些概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-06T18:22:43+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-aop面向切面编程"><a href="#1-aop面向切面编程" class="headerlink" title="1.aop面向切面编程"></a>1.aop面向切面编程</h3><p>AOP可以说是OOP(面向对象编程)的补充和完善。<br>OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。<br>当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。<br>也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系，例如日志功能。</p>
<p>日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。<br>对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。<br>这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。<br>所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</p>
<p>AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。</p>
<p>使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。<br>业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。<br>横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。<br>Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。<br>正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”</p>
<h4 id="实现AOP的技术，主要分为两大类："><a href="#实现AOP的技术，主要分为两大类：" class="headerlink" title="实现AOP的技术，主要分为两大类："></a>实现AOP的技术，主要分为两大类：</h4><p>1.采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；<br>2.采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>1.Authentication 权限<br>2.Caching 缓存<br>3.Context passing 内容传递<br>4.Error handling 错误处理<br>5.Lazy loading　懒加载<br>6.Debugging　　调试<br>7.logging, tracing, profiling and monitoring　记录跟踪　优化　校准<br>8.Performance optimization　性能优化<br>9.Persistence　　持久化<br>10.Resource pooling　资源池<br>11.Synchronization　同步<br>12.Transactions 事务</p>
<h3 id="AOP相关概念"><a href="#AOP相关概念" class="headerlink" title="AOP相关概念"></a>AOP相关概念</h3><p>方面（Aspect）：一个关注点的模块化，这个关注点实现可能另外横切多个对象。<br>事务管理是J2EE应用中一个很好的横切关注点例子。方面用Spring的 Advisor或拦截器实现。</p>
<p>连接点（Joinpoint）: 程序执行过程中明确的点，如方法的调用或特定的异常被抛出。</p>
<p> 通知（Advice）: 在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”和“throws”通知。通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。Spring中定义了四个advice: BeforeAdvice, AfterAdvice, ThrowAdvice和DynamicIntroductionAdvice</p>
<p> 切入点（Pointcut）: 指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。 Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解， MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上</p>
<p> 引入（Introduction）: 添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。Spring中要使用Introduction, 可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口</p>
<p> 目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象。POJO</p>
<p> AOP代理（AOP Proxy）: AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</p>
<p> 织入（Weaving）: 组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</p>
<h3 id="StringAOP组件"><a href="#StringAOP组件" class="headerlink" title="StringAOP组件"></a>StringAOP组件</h3><p><img src="https://github.com/ayanamiq/images/blob/master/StringAOP.png?raw=true" alt=""></p>
<h3 id="如何使用AOP"><a href="#如何使用AOP" class="headerlink" title="如何使用AOP"></a>如何使用AOP</h3><p>可以通过配置文件或者编程的方式来使用Spring AOP。</p>
<p> 配置可以通过xml文件来进行，大概有四种方式：</p>
<ol>
<li>配置ProxyFactoryBean，显式地设置advisors, advice, target等</li>
</ol>
<p>2.配置AutoProxyCreator，这种方式下，还是如以前一样使用定义的bean，但是从容器中获得的其实已经是代理对象</p>
<p>3.通过<a href="aop:config" target="_blank" rel="noopener">aop:config</a>来配置</p>
<p>4.通过&lt;aop: aspectj-autoproxy&gt;来配置，使用AspectJ的注解来标识通知及切入点</p>
<p> 也可以直接使用ProxyFactory来以编程的方式使用Spring AOP，通过ProxyFactory提供的方法可以设置target对象, advisor等相关配置，最终通过 getProxy()方法来获取代理对象</p>
<p> 具体使用的示例可以google. 这里略去</p>
<h3 id="Spring-AOP代理对象的生成"><a href="#Spring-AOP代理对象的生成" class="headerlink" title="Spring AOP代理对象的生成"></a>Spring AOP代理对象的生成</h3><p>Spring提供了两种方式来生成代理对象: JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。下面我们来研究一下Spring如何使用JDK来生成代理对象，具体的生成代码放在JdkDynamicAopProxy这个类中，直接上相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * &lt;ol&gt;</span><br><span class="line">    * &lt;li&gt;获取代理类要实现的接口,除了Advised对象中配置的,还会加上SpringProxy, Advised(opaque=false)</span><br><span class="line">    * &lt;li&gt;检查上面得到的接口中有没有定义 equals或者hashcode的接口</span><br><span class="line">    * &lt;li&gt;调用Proxy.newProxyInstance创建代理对象</span><br><span class="line">    * &lt;/ol&gt;</span><br><span class="line">    */</span><br><span class="line">   public Object getProxy(ClassLoader classLoader) &#123;</span><br><span class="line">       if (logger.isDebugEnabled()) &#123;</span><br><span class="line">           logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; +this.advised.getTargetSource());</span><br><span class="line">       &#125;</span><br><span class="line">       Class[] proxiedInterfaces =AopProxyUtils.completeProxiedInterfaces(this.advised);</span><br><span class="line">       findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">       return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那这个其实很明了，注释上我也已经写清楚了，不再赘述。</p>
<p>下面的问题是，代理对象生成了，那切面是如何织入的？</p>
<p>我们知道InvocationHandler是JDK动态代理的核心，生成的代理对象的方法调用都会委托到InvocationHandler.invoke()方法。而通过JdkDynamicAopProxy的签名我们可以看到这个类其实也实现了InvocationHandler，下面我们就通过分析这个类中实现的invoke()方法来具体看下Spring AOP是如何织入切面的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">publicObject invoke(Object proxy, Method method, Object[] args) throwsThrowable &#123;</span><br><span class="line">       MethodInvocation invocation = null;</span><br><span class="line">       Object oldProxy = null;</span><br><span class="line">       boolean setProxyContext = false;</span><br><span class="line"> </span><br><span class="line">       TargetSource targetSource = this.advised.targetSource;</span><br><span class="line">       Class targetClass = null;</span><br><span class="line">       Object target = null;</span><br><span class="line"> </span><br><span class="line">       try &#123;</span><br><span class="line">           //eqauls()方法，具目标对象未实现此方法</span><br><span class="line">           if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method))&#123;</span><br><span class="line">                return (equals(args[0])? Boolean.TRUE : Boolean.FALSE);</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">           //hashCode()方法，具目标对象未实现此方法</span><br><span class="line">           if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method))&#123;</span><br><span class="line">                return newInteger(hashCode());</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">           //Advised接口或者其父接口中定义的方法,直接反射调用,不应用通知</span><br><span class="line">           if (!this.advised.opaque &amp;&amp;method.getDeclaringClass().isInterface()</span><br><span class="line">                    &amp;&amp;method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">                // Service invocations onProxyConfig with the proxy config...</span><br><span class="line">                return AopUtils.invokeJoinpointUsingReflection(this.advised,method, args);</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">           Object retVal = null;</span><br><span class="line"> </span><br><span class="line">           if (this.advised.exposeProxy) &#123;</span><br><span class="line">                // Make invocation available ifnecessary.</span><br><span class="line">                oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">                setProxyContext = true;</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">           //获得目标对象的类</span><br><span class="line">           target = targetSource.getTarget();</span><br><span class="line">           if (target != null) &#123;</span><br><span class="line">                targetClass = target.getClass();</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">           //获取可以应用到此方法上的Interceptor列表</span><br><span class="line">           List chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method,targetClass);</span><br><span class="line"> </span><br><span class="line">           //如果没有可以应用到此方法的通知(Interceptor)，此直接反射调用 method.invoke(target, args)</span><br><span class="line">           if (chain.isEmpty()) &#123;</span><br><span class="line">                retVal = AopUtils.invokeJoinpointUsingReflection(target,method, args);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">                //创建MethodInvocation</span><br><span class="line">                invocation = newReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">                retVal = invocation.proceed();</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line">           // Massage return value if necessary.</span><br><span class="line">           if (retVal != null &amp;&amp; retVal == target &amp;&amp;method.getReturnType().isInstance(proxy)</span><br><span class="line">                    &amp;&amp;!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">                // Special case: it returned&quot;this&quot; and the return type of the method</span><br><span class="line">                // is type-compatible. Notethat we can&apos;t help if the target sets</span><br><span class="line">                // a reference to itself inanother returned object.</span><br><span class="line">                retVal = proxy;</span><br><span class="line">           &#125;</span><br><span class="line">           return retVal;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (target != null &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">                // Must have come fromTargetSource.</span><br><span class="line">               targetSource.releaseTarget(target);</span><br><span class="line">           &#125;</span><br><span class="line">           if (setProxyContext) &#123;</span><br><span class="line">                // Restore old proxy.</span><br><span class="line">                AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>主流程可以简述为：获取可以应用到此方法上的通知链（Interceptor Chain）,如果有,则应用通知,并执行joinpoint; 如果没有,则直接反射执行joinpoint。而这里的关键是通知链是如何获取的以及它又是如何执行的，下面逐一分析下。</p>
<p>首先，从上面的代码可以看到，通知链是通过Advised.getInterceptorsAndDynamicInterceptionAdvice()这个方法来获取的,我们来看下这个方法的实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Object&gt;getInterceptorsAndDynamicInterceptionAdvice(Method method, Class targetClass) &#123;  </span><br><span class="line">                   MethodCacheKeycacheKey = new MethodCacheKey(method);  </span><br><span class="line">                   List&lt;Object&gt;cached = this.methodCache.get(cacheKey);  </span><br><span class="line">                   if(cached == null) &#123;  </span><br><span class="line">                            cached= this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(  </span><br><span class="line">                                               this,method, targetClass);  </span><br><span class="line">                            this.methodCache.put(cacheKey,cached);  </span><br><span class="line">                   &#125;  </span><br><span class="line">                   returncached;  </span><br><span class="line">         &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">可以看到实际的获取工作其实是由AdvisorChainFactory. getInterceptorsAndDynamicInterceptionAdvice()这个方法来完成的，获取到的结果会被缓存。</span><br><span class="line"></span><br><span class="line">下面来分析下这个方法的实现：</span><br></pre></td></tr></table></figure></p>
<p>/**</p>
<pre><code>* 从提供的配置实例config中获取advisor列表,遍历处理这些advisor.如果是IntroductionAdvisor,
* 则判断此Advisor能否应用到目标类targetClass上.如果是PointcutAdvisor,则判断
* 此Advisor能否应用到目标方法method上.将满足条件的Advisor通过AdvisorAdaptor转化成Interceptor列表返回.
*/
publicList getInterceptorsAndDynamicInterceptionAdvice(Advised config, Methodmethod, Class targetClass) {
   // This is somewhat tricky... we have to process introductions first,
   // but we need to preserve order in the ultimate list.
   List interceptorList = new ArrayList(config.getAdvisors().length);

   //查看是否包含IntroductionAdvisor
   boolean hasIntroductions = hasMatchingIntroductions(config,targetClass);

   //这里实际上注册一系列AdvisorAdapter,用于将Advisor转化成MethodInterceptor
   AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();

   Advisor[] advisors = config.getAdvisors();
    for (int i = 0; i &lt;advisors.length; i++) {
       Advisor advisor = advisors[i];
       if (advisor instanceof PointcutAdvisor) {
            // Add it conditionally.
            PointcutAdvisor pointcutAdvisor= (PointcutAdvisor) advisor;
            if(config.isPreFiltered() ||pointcutAdvisor.getPointcut().getClassFilter().matches(targetClass)) {
                //TODO: 这个地方这两个方法的位置可以互换下
                //将Advisor转化成Interceptor
                MethodInterceptor[]interceptors = registry.getInterceptors(advisor);

                //检查当前advisor的pointcut是否可以匹配当前方法
                MethodMatcher mm =pointcutAdvisor.getPointcut().getMethodMatcher();

                if (MethodMatchers.matches(mm,method, targetClass, hasIntroductions)) {
                    if(mm.isRuntime()) {
                        // Creating a newobject instance in the getInterceptors() method
                        // isn&apos;t a problemas we normally cache created chains.
                        for (intj = 0; j &lt; interceptors.length; j++) {
                           interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptors[j],mm));
                        }
                    } else {
                        interceptorList.addAll(Arrays.asList(interceptors));
                    }
                }
            }
       } else if (advisor instanceof IntroductionAdvisor){
            IntroductionAdvisor ia =(IntroductionAdvisor) advisor;
            if(config.isPreFiltered() || ia.getClassFilter().matches(targetClass)) {
                Interceptor[] interceptors= registry.getInterceptors(advisor);
                interceptorList.addAll(Arrays.asList(interceptors));
            }
       } else {
            Interceptor[] interceptors =registry.getInterceptors(advisor);
            interceptorList.addAll(Arrays.asList(interceptors));
       }
   }
   return interceptorList;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这个方法执行完成后，Advised中配置能够应用到连接点或者目标类的Advisor全部被转化成了MethodInterceptor.</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">接下来我们再看下得到的拦截器链是怎么起作用的。</span><br></pre></td></tr></table></figure></p>
<p>if (chain.isEmpty()) {<br>                retVal = AopUtils.invokeJoinpointUsingReflection(target,method, args);<br>            } else {<br>                //创建MethodInvocation<br>                invocation = newReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);<br>                retVal = invocation.proceed();<br>            }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">从这段代码可以看出，如果得到的拦截器链为空，则直接反射调用目标方法，否则创建MethodInvocation，调用其proceed方法，触发拦截器链的执行，来看下具体代码</span><br></pre></td></tr></table></figure></p>
<p>public Object proceed() throws Throwable {<br>       //  We start with an index of -1and increment early.<br>       if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size()- 1) {<br>           //如果Interceptor执行完了，则执行joinPoint<br>           return invokeJoinpoint();<br>       }</p>
<pre><code>Object interceptorOrInterceptionAdvice =
    this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);

//如果要动态匹配joinPoint
if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher){
    // Evaluate dynamic method matcher here: static part will already have
    // been evaluated and found to match.
    InterceptorAndDynamicMethodMatcher dm =
         (InterceptorAndDynamicMethodMatcher)interceptorOrInterceptionAdvice;
    //动态匹配：运行时参数是否满足匹配条件
    if (dm.methodMatcher.matches(this.method, this.targetClass,this.arguments)) {
         //执行当前Intercetpor
         returndm.interceptor.invoke(this);
    }
    else {
         //动态匹配失败时,略过当前Intercetpor,调用下一个Interceptor
         return proceed();
    }
}
else {
    // It&apos;s an interceptor, so we just invoke it: The pointcutwill have
    // been evaluated statically before this object was constructed.
    //执行当前Intercetpor
    return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);
}
</code></pre><p>}<br><code>`</code><br>代码也比较简单，这里不再赘述。</p>
<p>END</p>
<p>面向对象编程更多的操作是在纵向部分(即继承，接口实现之类)，这就导致一些需要在横向上(即业务代码方法中的前后)嵌入的非核心代码得在每一个方法上都要去写(比如日志，权限，异常处理等）。<br>它们散布在各方法的横切面上，造成代码重复，也不利于各个模块的重用（毕竟，不同方法还是有所区别）。<br>AOP就是为了解决这种男题而生的 从AOP这个英文缩写来看就好。。。A是一把刀，把P的突出部分切出来（类比于围绕方法设定的日志，权限等需求，它们都是属于核心方法外的通用服务），<br>它们有一个共性—-圆溜溜的（就像一个工具箱中的扳手，钳子，螺丝刀之类的），所以能把它们集合成一块儿（它们都具有’工具‘的属性），就是中间的O。重新给接回去的时候，就着不同的需求，<br>用O中不同的工具就好(通过不同的方法或注解指明)。 概念陈列： 目标对象，AOP代理对象，连接点，切入点，拦截器，通知，织入， 假设有一个对象A（目标对象），外部的请求人B要想访问到A，<br>需要通过一个安检过程(连接点，比如验证权限m1，登录密码m2，身份识别m3等)。B开始访问后，首先得经过第一层的安检（准备走谁（introductionInterceptor）的哪一层安检（PointCut–》指定到具体的安检流程），<br>由你定义的interceptor拦截器决定），即权限验证m1(切入点)。通过这一层后，监控整个访问过程的你可以决定是否要向大家伙儿通报外部请求的访问情况<br>【像：B那孙子进来啦 OR B那孙子带着贪玩蓝月系来嘞 OR B那小子是渣渣辉的部下】(在访问开始前，还是结束后，还是全程播报—-&gt;这就是’通知‘)。<br>于A而言，他觉得直接跟B接触可能不太安全，所以A把自己的一些权限给到了代理对象Proxy_A，并让Proxy_A去正面’刚（也即织入，A间接的给自己加持了一副铠甲）‘B(或许是来者不善乜)。Proxy_A是怎样产生的呢？<br>这就是AOP动态代理的辅助了。简单来讲，不论你是什么代理—》Proxy_某个目标对象，只要是通过JDK或者CGLib的代理副本传送门（类比于抽象）进入到刚B的’对战场景‘中，<br>那么，他都算是A（或者其他目标对象）的代言人。</p>
<h3 id="IOC是什么"><a href="#IOC是什么" class="headerlink" title="IOC是什么"></a>IOC是什么</h3><p>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。<br>在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。<br>如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：</p>
<p>　　●谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</p>
<p>　　●为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</p>
<p>用图例说明一下，传统程序设计如下图，都是主动去创建相关对象然后再组合起来：<br><img src="https://github.com/ayanamiq/images/blob/master/images/SpringIOC.jpg?raw=true" alt=""></p>
<p>当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如下图所示:<br><img src="https://github.com/ayanamiq/images/blob/master/images/SpringIOC2.JPG?raw=true" alt=""></p>
<h3 id="IOC能做什么"><a href="#IOC能做什么" class="headerlink" title="IOC能做什么"></a>IOC能做什么</h3><p>IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p>
<p>　　其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。</p>
<p>　　IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p>
<h3 id="IOC和DI"><a href="#IOC和DI" class="headerlink" title="IOC和DI"></a>IOC和DI</h3><p>DI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>
<p>　　理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：</p>
<p>　　●谁依赖于谁：当然是应用程序依赖于IoC容器；</p>
<p>　　●为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源；</p>
<p>　　●谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；</p>
<p>　　●注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</p>
<p>　　IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</p>
<p>　　看过很多对Spring的Ioc理解的文章，好多人对Ioc和DI的解释都晦涩难懂，反正就是一种说不清，道不明的感觉，读完之后依然是一头雾水，感觉就是开涛这位技术牛人写得特别通俗易懂，他清楚地解释了IoC(控制反转) 和DI(依赖注入)中的每一个字，读完之后给人一种豁然开朗的感觉。我相信对于初学Spring框架的人对Ioc的理解应该是有很大帮助的。</p>
<h3 id="再抄一点别人写的："><a href="#再抄一点别人写的：" class="headerlink" title="再抄一点别人写的："></a>再抄一点别人写的：</h3><p>2.1、IoC(控制反转)<br>　　首先想说说IoC（Inversion of Control，控制反转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。</p>
<p>　　那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</p>
<p>2.2、DI(依赖注入)<br>　　IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p>
<p>　　理解了IoC和DI的概念后，一切都将变得简单明了，剩下的工作只是在spring的框架中堆积木而已。</p>
<h3 id="我对IoC-控制反转-和DI-依赖注入-的理解"><a href="#我对IoC-控制反转-和DI-依赖注入-的理解" class="headerlink" title="我对IoC(控制反转)和DI(依赖注入)的理解"></a>我对IoC(控制反转)和DI(依赖注入)的理解</h3><p>在平时的java应用开发中，我们要实现某一个功能或者说是完成某个业务逻辑时至少需要两个或以上的对象来协作完成。<br>在没有使用Spring的时候，每个对象在需要使用他的合作对象时，自己均要使用像new object() 这样的语法来将合作对象创建出来，这个合作对象是由自己主动创建出来的，创建合作对象的主动权在自己手上，自己需要哪个合作对象，就主动去创建。<br>创建合作对象的主动权和创建时机是由自己把控的，而这样就会使得对象间的耦合度高了，A对象需要使用合作对象B来共同完成一件事，A要使用B，那么A就对B产生了依赖，也就是A和B之间存在一种耦合关系，并且是紧密耦合在一起。<br>而使用了Spring之后就不一样了，创建合作对象B的工作是由Spring来做的，Spring创建好B对象，然后存储到一个容器里面。<br>当A对象需要使用B对象时，Spring就从存放对象的那个容器里面取出A要使用的那个B对象，然后交给A对象使用。<br>至于Spring是如何创建那个对象，以及什么时候创建好对象的，A对象不需要关心这些细节问题(你是什么时候生的，怎么生出来的我可不关心，能帮我干活就行)，A得到Spring给我们的对象之后，两个人一起协作完成要完成的工作即可。</p>
<p>　　所以控制反转IoC(Inversion of Control)是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，比如转移交给了IoC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了 IoC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IoC容器了，通过IoC容器来建立它们之间的关系。</p>
<p>  　这是我对Spring的IoC(控制反转)的理解。<br>      DI(依赖注入)其实就是IOC的另外一种说法，DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。<br>他总结：控制的什么被反转了？<br>就是：获得   依赖对象   的方式   反转了。</p>
<p>其实我觉得依赖注入，翻译成<code>依赖的注入</code>更贴切，因为依赖注入是IOC的一个过程，<br>我们使用了IOC容器，现在，对象是被动的等待IoC容器来创建并注入它所需要的资源了，<br>依赖注入，是程序(对象)变为了依赖注入这种状态，而依赖注入是一种行为，以前是我们主动的去创建对象，现在对象等待IOC容器来创建并注入它所需的资源，现在的对象是<strong>依赖注入的</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/06/Collection/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王靖尧">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王靖尧的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/Collection/" itemprop="url">Collection</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-06T18:21:41+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="集合-Collection"><a href="#集合-Collection" class="headerlink" title="集合(Collection)"></a>集合(Collection)</h1><p>为了方便对多个对象进行操作，集合是存储对象的最常用的一种方式<br>集合的出现就是为了存储对象，可以存储任意类型的对象，而且长度可变。<br>集合和数组的区别?<br>.都是容器<br>.数组长度固定，集合长度可变<br>.数组可以存储基本数据类型，集合只能存对象<br>.数组存储的数据类型是单一的，集合可以存储任意类型的对象</p>
<h4 id="集合的三个特点："><a href="#集合的三个特点：" class="headerlink" title="集合的三个特点："></a>集合的三个特点：</h4><p>1.用于存储对象<br>2.长度可变<br>3.可以存储不同类型的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">---|Collection:(包含list和set子接口)</span><br><span class="line">	---|List: 有存储顺序, 可重复</span><br><span class="line">		---|ArrayList：数组实现, 查找快, 增删慢</span><br><span class="line">			由于是数组实现, 在增和删的时候会牵扯到数组</span><br><span class="line">			增容, 以及拷贝元素. 所以慢。数组是可以直接</span><br><span class="line">			按索引查找, 所以查找时较快</span><br><span class="line">		---|LinkedList：链表实现, 增删快, 查找慢</span><br><span class="line">			由于链表实现, 增加时只要让前一个元素记住自</span><br><span class="line">			己就可以, 删除时让前一个元素记住后一个元</span><br><span class="line">			素, 后一个元素记住前一个元素. 这样的增删效</span><br><span class="line">			率较高但查询时需要一个一个的遍历, 所以效率</span><br><span class="line">			较低</span><br><span class="line">		---|Vector：和ArrayList原理相同, 但线程安全, 效率略低</span><br><span class="line">				</span><br><span class="line">	---|Set: 无存储顺序, 不可重复</span><br><span class="line">		---|HashSet:线程不安全，存取速度快，底层以哈希表实现</span><br><span class="line">		---|TreeSet:红黑二叉树结构，默认对元素进行自然排序，</span><br><span class="line">		---|LinkedHashSet:会保存插入的顺序</span><br><span class="line"></span><br><span class="line">---| Map:键值对(不允许重复的键)null可以作为键，这样的键只有一个</span><br><span class="line">	注:map和collection没有关系</span><br><span class="line">		---|HashMap:根据键的hashCode值存储数据，根据键可以直接获取它的值，查询快(存入的值在取的时候也是随机的)</span><br><span class="line">		---|TreeMap:取出来后是排序后的键值对(如果需要按照自然排序或自定义排序,用这个)</span><br><span class="line">		---|HashTable:和hashMap实现原理一样,区别在于线程安全</span><br><span class="line">		---|LinkedHashMap:输出的顺序和输入的顺序是相同的</span><br><span class="line">		---|ConcurrentHashMap：采用了分段锁的设计，并发map</span><br></pre></td></tr></table></figure></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1.list和set的区别<br>list允许重复对象，set不允许重复对象<br>list是有序容器，保留了每个元素的插入顺序，输出顺序就是插入顺序。<br>set是无序容器，无法保证每个元素的存储顺序.<br>list可以插入多个null元素，set只允许一个null元素.</p>
<p>什么时候该使用什么样的集合<br>Collection    我们需要保存若干个对象的时候使用集合。<br>List<br>如果我们需要保留存储顺序, 并且保留重复元素, 使用List.<br>    如果查询较多, 那么使用ArrayList<br>    如果存取较多, 那么使用LinkedList<br>    如果需要线程安全, 那么使用Vector</p>
<p>Set<br>如果我们不需要保留存储顺序, 并且需要去掉重复元素, 使用Set.<br>    如果我们需要将元素排序, 那么使用TreeSet<br>    如果我们不需要排序, 使用HashSet, HashSet比TreeSet效率高.<br>    如果我们需要保留存储顺序, 又要过滤重复元素, 那么使用LinkedHashSet</p>
<p>看到array，就要想到角标。<br>看到link，就要想到first，last。<br>看到hash，就要想到hashCode,equals.<br>看到tree，就要想到两个接口。Comparable，Comparator。</p>
<p>集合方法<br>Collection接口的共性方法<br>1.add():将指定对象存储到容器中<br>  addAll():直接添加一整个集合 </p>
<p>2.remove():将指定对象从集合中删除<br>  removeAll():直接删除一个集合</p>
<p>3.clear():清空集合中的所有元素</p>
<p>4.contains():判断集合中是否包含指定对象</p>
<p>5.collection.size():返回集合的大小</p>
<p>6.toArray():集合转换成数组</p>
<p>List特有的方法：<br>1.增加：List.add(1,”指定元素”);在指定位置添加元素<br>2.删除：List.remove(1,”指定元素”);删除指定位置的元素<br>3.修改：List.set(1,”指定元素”);修改指定位置的元素<br>4.查找：List.get(1,”指定元素”);查找指定位置的元素<br>5.求子集合:List<e> subList(int fromIndex, int toIndex) // 不包含toIndex</e></p>
<p>LinkedList特有方法：<br>1.addFirst():在集合的第一个位置添加元素<br>  addLast(): 最后<br>2.getFirst():返回此集合的第一个元素<br>  getLast():最后<br>3.removeFirst():移除集合的第一个元素<br>  removeLast():最后</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/06/JAVA基础-2/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王靖尧">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王靖尧的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/JAVA基础-2/" itemprop="url">JAVA基础-2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-06T18:20:53+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"><a href="#1-什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？" class="headerlink" title="1.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？"></a>1.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h3><p>Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。<br>Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。<br>Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p>
<h3 id="2-JDK和JRE的区别是什么？"><a href="#2-JDK和JRE的区别是什么？" class="headerlink" title="2.JDK和JRE的区别是什么？"></a>2.JDK和JRE的区别是什么？</h3><p>JRE:Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。<br>JDK:Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。</p>
<h3 id="3-是否可以在static环境中访问非static变量？-不可以"><a href="#3-是否可以在static环境中访问非static变量？-不可以" class="headerlink" title="3.是否可以在static环境中访问非static变量？(不可以)"></a>3.是否可以在static环境中访问非static变量？(不可以)</h3><p>static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。<br>如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p>
<h3 id="4-Java支持的数据类型有哪些？什么是自动拆装箱？"><a href="#4-Java支持的数据类型有哪些？什么是自动拆装箱？" class="headerlink" title="4.Java支持的数据类型有哪些？什么是自动拆装箱？"></a>4.Java支持的数据类型有哪些？什么是自动拆装箱？</h3><p>Java语言支持的8中基本数据类型是：<br>byte,short,int,long,float,double,boolean,char<br>自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。<br>Integer  a=1;//这就是一个自动装箱，如果没有自动装箱的话，需要这样Integer  a=new Integer(1)<br>int b=a;//这就是一个自动拆箱，如果没有自动拆箱的话，需要这样：int b=a.intValue()<br>自动装箱和自动拆箱是简化了基本数据类型和相对应对象的转化步骤</p>
<h3 id="5-什么是值传递和引用传递？"><a href="#5-什么是值传递和引用传递？" class="headerlink" title="5.什么是值传递和引用传递？"></a>5.什么是值传递和引用传递？</h3><p>对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。<br>对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。</p>
<h3 id="6-进程和线程的区别是什么？"><a href="#6-进程和线程的区别是什么？" class="headerlink" title="6.进程和线程的区别是什么？"></a>6.进程和线程的区别是什么？</h3><p>进程是执行着的应用程序，而线程是进程内部的一个执行序列<br>一个进程可以有多个线程。线程又叫做轻量级进程。</p>
<h3 id="7-什么是死锁-deadlock-？"><a href="#7-什么是死锁-deadlock-？" class="headerlink" title="7.什么是死锁(deadlock)？"></a>7.什么是死锁(deadlock)？</h3><p>两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。</p>
<h3 id="8-如何确保N个线程可以访问N个资源同时又不导致死锁？"><a href="#8-如何确保N个线程可以访问N个资源同时又不导致死锁？" class="headerlink" title="8.如何确保N个线程可以访问N个资源同时又不导致死锁？"></a>8.如何确保N个线程可以访问N个资源同时又不导致死锁？</h3><p>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</p>
<h3 id="9-什么是迭代器-Iterator-？"><a href="#9-什么是迭代器-Iterator-？" class="headerlink" title="9.什么是迭代器(Iterator)？"></a>9.什么是迭代器(Iterator)？</h3><p>Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。</p>
<h3 id="10-Iterator和ListIterator的区别是什么？"><a href="#10-Iterator和ListIterator的区别是什么？" class="headerlink" title="10.Iterator和ListIterator的区别是什么？"></a>10.Iterator和ListIterator的区别是什么？</h3><p>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。<br>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。<br>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p>
<h3 id="11-Java中的HashMap的工作原理是什么？"><a href="#11-Java中的HashMap的工作原理是什么？" class="headerlink" title="11.Java中的HashMap的工作原理是什么？"></a>11.Java中的HashMap的工作原理是什么？</h3><p>Java中的HashMap是以键值对(key-value)的形式存储元素的。<br>HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。<br>当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。<br>如果key已经存在了，value会被更新成新值。<br>HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。</p>
<h4 id="12-Java中HashMap遍历的四种方式"><a href="#12-Java中HashMap遍历的四种方式" class="headerlink" title="12.Java中HashMap遍历的四种方式"></a>12.Java中HashMap遍历的四种方式</h4><p>1.entrySet().iterator()<br>效率高,以后一定要使用此种方式！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map map = new HashMap();</span><br><span class="line">　　Iterator iter = map.entrySet().iterator();</span><br><span class="line">　　while (iter.hasNext()) &#123;</span><br><span class="line">　　Map.Entry entry = (Map.Entry) iter.next();</span><br><span class="line">　　Object key = entry.getKey();</span><br><span class="line">　　Object val = entry.getValue();</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.keySet().iterator()<br>效率低,以后尽量少使用！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map map = new HashMap();</span><br><span class="line">　　Iterator iter = map.keySet().iterator();</span><br><span class="line">　　while (iter.hasNext()) &#123;</span><br><span class="line">　　Object key = iter.next();</span><br><span class="line">　　Object val = map.get(key);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.entrySet遍历key和value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(Map.Entry&lt;String, String&gt; entry: map.entrySet())&#123;</span><br><span class="line">    Object key = entry.getKey();</span><br><span class="line">　Object val = entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="13-数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用Array而不是ArrayList？"><a href="#13-数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用Array而不是ArrayList？" class="headerlink" title="13.数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？"></a>13.数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？</h3><p>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。<br>Array大小是固定的，ArrayList的大小是动态变化的。</p>
<h3 id="14-ArrayList和LinkedList有什么区别？"><a href="#14-ArrayList和LinkedList有什么区别？" class="headerlink" title="14.ArrayList和LinkedList有什么区别？"></a>14.ArrayList和LinkedList有什么区别？</h3><p>ArrayList和LinkedList都实现了List接口，他们有以下的不同点：<br>1.ArrayList数组实现，增删慢(增删元素时，需要重新计算大小或更新数组索引)，查找快<br>LinkedList链表实现，增删快，查找慢。<br>2.LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</p>
<h3 id="15-System-gc-和Runtime-gc-会做什么事情？"><a href="#15-System-gc-和Runtime-gc-会做什么事情？" class="headerlink" title="15.System.gc()和Runtime.gc()会做什么事情？"></a>15.System.gc()和Runtime.gc()会做什么事情？</h3><p>这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。</p>
<h3 id="16-堆栈区别？"><a href="#16-堆栈区别？" class="headerlink" title="16.堆栈区别？"></a>16.堆栈区别？</h3><p>1.栈区:编译器自动分配,存放函数的参数值，局部变量等<br>2.2.堆区:手动分配释放</p>
<h3 id="17-什么是线程安全和不安全？"><a href="#17-什么是线程安全和不安全？" class="headerlink" title="17.什么是线程安全和不安全？"></a>17.什么是线程安全和不安全？</h3><p>1.线程安全:a,b线程同时操作一个变量,a操作的时候，b不能操作,相当于单线程<br>2.线程不安全:a,b线程同时操作一个变量,可同时操作</p>
<h3 id="18-同步和异步？"><a href="#18-同步和异步？" class="headerlink" title="18.同步和异步？"></a>18.同步和异步？</h3><p>同步:发送一个请求,等待返回结果，然后再发送下一个请求<br>特点:需要等待,避免出现死锁，脏读数据的发生<br>异步:发送一个请求,不等待返回,随时可以再发送下一个请求<br>特点:无需等待,提高效率，但是会出现死锁，脏读数据</p>
<h3 id="19-九种基本数据类型的大小，以及他们的封装类-一个字节是8位"><a href="#19-九种基本数据类型的大小，以及他们的封装类-一个字节是8位" class="headerlink" title="19.九种基本数据类型的大小，以及他们的封装类(一个字节是8位)"></a>19.九种基本数据类型的大小，以及他们的封装类(一个字节是8位)</h3><table>
<thead>
<tr>
<th>基本类型</th>
<th>大小(字节)</th>
<th>默认值</th>
<th>封装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>1</td>
<td>(byte)0</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>(short)0</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>0</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>0L</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>0.0f</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>0.0d</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>-</td>
<td>false</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
<td>\u0000(null)</td>
<td>Character</td>
</tr>
<tr>
<td>void</td>
<td>-</td>
<td>-</td>
<td>Void</td>
</tr>
</tbody>
</table>
<h3 id="20-equals、-、hashcode-区别"><a href="#20-equals、-、hashcode-区别" class="headerlink" title="20.equals、==、hashcode  区别"></a>20.equals、==、hashcode  区别</h3><p>1.基本数据类型<br>byte/int/double/boolean等，用==，比较的是他们的值<br>2.引用类型(对象)<br>用==比较的是内存地址，同一个new出来的对象，为true，反之为false<br>(对象是存放在堆中的，栈中存放的是对象的引用(地址),由此可见==比较的是栈中的值<br>如果要比较堆中的对象是否相同，要重写equals方法)</p>
<p>equals:比较对象的内容(就是最表面的值)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;1&quot;;</span><br><span class="line">String b = &quot;1&quot;;</span><br><span class="line">String c = new String(&quot;1&quot;);</span><br><span class="line">System.out.println(a==b);//true,是一块内存地址</span><br><span class="line">System.out.println(a==c);//false,不是一块内存地址</span><br><span class="line">System.out.println(a.equals(b));//true,比较的是值</span><br></pre></td></tr></table></figure>
<h3 id="21-Java的四种引用，强弱软虚，用到的场景"><a href="#21-Java的四种引用，强弱软虚，用到的场景" class="headerlink" title="21.Java的四种引用，强弱软虚，用到的场景"></a>21.Java的四种引用，强弱软虚，用到的场景</h3><p>1.强引用:如果一个对象具有强引用，那垃圾回收器绝不会回收它<br>Object o=new Object();   //  强引用<br>2.软引用:内存够，不会被回收(垃圾回收器),反之会被回收.<br>引用可用来实现内存敏感的高速缓存。<br>3.弱引用:垃圾回收器一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存<br>4.虚引用：任何时候都可能被垃圾回收器回收</p>
<h3 id="22-Hashcode的作用"><a href="#22-Hashcode的作用" class="headerlink" title="22.Hashcode的作用"></a>22.Hashcode的作用</h3><p>1.生成一个hash码,表示对象存储的物理地址<br>2.可以用来用来鉴定2个对象是否相等</p>
<h3 id="23-String、StringBuffer与StringBuilder的区别。"><a href="#23-String、StringBuffer与StringBuilder的区别。" class="headerlink" title="23.String、StringBuffer与StringBuilder的区别。"></a>23.String、StringBuffer与StringBuilder的区别。</h3><p>string:字符串常量，不可改变的对象<br>StringBuffer:字符串变量,可变对象,线程安全，效率低<br>StringBuilder:字符串变量,可变对象,线程不安全，效率高</p>
<h3 id="24-HashMap和HashTable的区别"><a href="#24-HashMap和HashTable的区别" class="headerlink" title="24.HashMap和HashTable的区别"></a>24.HashMap和HashTable的区别</h3><p>HashMap:异步的，线程不安全<br>HashTable:同步的，线程安全</p>
<h3 id="25-token"><a href="#25-token" class="headerlink" title="25.token"></a>25.token</h3><p> 一、我们先解释一下他的含义：<br>1.token的引入<br>token是客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，token便应运而生<br>2、Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。<br>3、使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。<br>二、如何使用Token？<br>1、用设备号/设备mac地址作为Token（推荐）<br>客户端：客户端在登录的时候获取设备的设备号/mac地址，并将其作为参数传递到服务端。<br> 服务端：服务端接收到该参数后，便用一个变量来接收同时将其作为Token保存在数据库，并将该Token设置到session中，客户端每次请求的时候都要统一拦截，并将客户端传递的token和服务器端session中的token进行对比，如果相同则放行，不同则拒绝。<br>分析：此刻客户端和服务器端就统一了一个唯一的标识Token，而且保证了每一个设备拥有了一个唯一的会话。<br>该方法的缺点是客户端需要带设备号/mac地址作为参数传递，而且服务器端还需要保存；优点是客户端不需重新登录，只要登录一次以后一直可以使用，至于超时的问题是有服务器这边来处理，如何处理？若服务器的Token超时后，服务器只需将客户端传递的Token向数据库中查询，同时并赋值给变量Token，如此，Token的超时又重新计时。<br>2、用session值作为Token<br>客户端：客户端只需携带用户名和密码登陆即可。<br>客户端：客户端接收到用户名和密码后并判断，如果正确了就将本地获取sessionID作为Token返回给客户端，客户端以后只需带上请求数据即可。<br>分析：这种方式使用的好处是方便，不用存储数据，但是缺点就是当session过期后，客户端必须重新登录才能进行访问数据。<br>三、使用过程中出现的问题以及解决方案？<br>刚才我们轻松介绍了Token的两种使用方式，但是在使用过程中我们还出现各种问题，Token第一种方法中我们隐藏了一个在网络不好或者并发请求时会导致多次重复提交数据的问题。</p>
<p>该问题的解决方案：将session和Token套用，如此便可解决，如何套用呢？请看这段解释：<br><img src="https://github.com/ayanamiq/images/blob/master/token.png?raw=true" alt=""><br>这就是解决重复提交的方案。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/06/JAVA基础/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王靖尧">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王靖尧的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/JAVA基础/" itemprop="url">JAVA基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-06T18:18:52+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>this 表示当前函数，所属对象的引用<br>super用于调用父类方法</p>
<h3 id="1-static"><a href="#1-static" class="headerlink" title="1.static"></a>1.static</h3><p>static可修饰属性、方法和代码块<br>static 修饰属性：是一个类的共享变量，属于整个类，在不实例化对象的情况下就能访问。<br>static 修饰方法：不需要实例化对象，可以使用类名调用，静态方法不能访问非静态成员，包括成员的方法和变量。因为此时用类调用，没有对象的概念，this是不可用的。<br>static 修饰代码块：一般静态代码块用来初始化静态成员。<br>因为静态优先于对象存在，静态方法不可以出现this.<br>非静态函数中可以访问静态成员变量</p>
<p>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。<br>公有puclic:公有变量，外部也可以调用的变量<br>私有private：私有变量,只能在对象内部调用，外部调用需要设置get(),set()方法，get用于获取对象的属性，set用于设置对象的属性</p>
<h3 id="2-final"><a href="#2-final" class="headerlink" title="2.final"></a>2.final</h3><p>final修饰符可修饰 类，属性，方法<br>final 修饰类：此类不可被继承，即final没有子类，这样可以保证用户调用时动作的一致性，防止子类覆盖情况的发生<br>final 修饰变量：此时的属性为常量，常量的地址不可变，但在地址中保存的值(即对象的属性)，是可以改变的<br>final 修饰方法：此方法不可覆盖<br>问题：final, finally, finalize 的区别<br>1.final–修饰符(关键字),如果一个类被声明为final,意味着它不能再派生出新的子类，不能作为父类被继承<br>2.finally是在异常处理时提供finally块来执行任何清除操作,不管有没有异常被抛出、捕获，finally块都会被执行<br>3.finalize方法来自于java.lang.Object，用于回收资源。在实际应用中，不要依赖使用该方法回收任何短缺的资源，这是因为很难知道这个方法什么时候被调用。</p>
<h3 id="3-什么是函数的重载？"><a href="#3-什么是函数的重载？" class="headerlink" title="3.什么是函数的重载？"></a>3.什么是函数的重载？</h3><p>重载是同一个类中，有两个及以上的方法，拥有相同的方法名，但是参数不同，方法体也不同<br>系统会根据传入的参数类型和参数个数来判断要用到的方法</p>
<h3 id="4-函数的重写？"><a href="#4-函数的重写？" class="headerlink" title="4. 函数的重写？"></a>4. 函数的重写？</h3><p>重写指的是子类方法覆盖父类方法，要求方法名和参数都相同，但修饰符和返回值可能不同，构造方法无法覆盖</p>
<h3 id="5-什么是构造方法？"><a href="#5-什么是构造方法？" class="headerlink" title="5.什么是构造方法？"></a>5.什么是构造方法？</h3><p>构造方法主要作用是完成对象的初始化工作，能够把定义对象时的参数传递给对象的域<br>1.构造方法名称必须与类名相同<br>2.没有返回类型，也不能定义void，方法前不声明方法类型<br>3.一个类可以定义多个构造方法，如在定义类时没有定义构造方法，系统会自动插入一个无参数的默认构造器，这个构造器不执行任何代码<br>4.构造方法可以重载</p>
<h3 id="6-封装"><a href="#6-封装" class="headerlink" title="6.封装"></a>6.封装</h3><p>把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口<br>封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口<br>java中提供四个修饰符来进行对象属性和方法的访问权限控制：<br>private ：类内部可见<br>default ：包内部可见<br>protected ：包内部或子类可见<br>public ：所有可见<br>好处:<br>.通过隐藏对象的属性来保护对象内部的状态。<br>.提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。<br>.禁止对象之间的不良交，互提高模块化。</p>
<h3 id="7-继承"><a href="#7-继承" class="headerlink" title="7.继承"></a>7.继承</h3><p>继承是从已有类得到继承信息创建新类的过程。<br>提供继承信息的类被称为父类，得到继承信息的类被称为子类<br>.父类非私有化的属性和方法可以继承到子类<br>.父类的构造方法子类不可以继承，更不存在覆盖<br>.java中不允许多继承，一个类只有一个父类<br>.super()表示调用父类的构造方法，super()和this()一样，必须放在第一行。<br>.this()用于调用本类的构造方法</p>
<h3 id="8-多态"><a href="#8-多态" class="headerlink" title="8.多态"></a>8.多态</h3><p>多态性是指允许不同子类型的对象对同一消息作出不同的响应<br>多态分为:编译时多态和运行时多态<br>.编译时多态：编译时动态加载(方法的重载)<br>.运行时多态：一个对象可以有多个类型(子类重写父类方法),父类引用指向子类对象</p>
<p>运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事<br>1.方法重写（子类继承父类并重写父类中已有的或抽象的方法）<br>2.父类引用指向子类对象,这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为    </p>
<p>.如果子类中重写了父类中的方法，那么在调用这个方法的时候，将会调用子类中的这个方法<br>.变量不能被重写(覆盖)，重写只针对方法，如果在子类中重写了父类中的变量，那么编译会报错<br>.如果继承的子类继承父类的一个方法后加以重载，则该父类引用不能使用重载后的那个方法</p>
<p>体现：父类引用指向子类对象<br>前提：    要有继承，要有方法重写，父类引用指向子类对象<br>好处：把不同的子类对象都当做父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码。</p>
<p>例: 游戏中有不同的角色，它们都有一个父类，它们做相同动作时表现出来的效果就会不一样，比如跑，魔法师的跑跟战士的跑就不会一样，<br>这就是俩者都覆盖了父类中的跑方法，各自有自己的现实，表现出来多态。<br>如果有一天你想再加个角色，只用再写一个类继承该父类，覆盖其中的跑方法就行了，其他代码不用怎么改，所以可维护性也很好。</p>
<h3 id="9-接口、抽象类区别"><a href="#9-接口、抽象类区别" class="headerlink" title="9.接口、抽象类区别:"></a>9.接口、抽象类区别:</h3><p>1.方法实现：抽象类可以有默认的方法实现，接口完全是抽象的。它根本不存在方法的实现<br>2.构造方法：抽象类可以有构造器，接口不能有构造方法。<br>3.多继承：子类只能继承一个抽象类(java单继承，子类-&gt;(继承extend)抽象类)，<br>子类可以实现多个接口(子类-&gt;(实现implements)接口)<br>4.声明: 接口：public inerface Person,<br>抽象类：abstract class Person:<br>5.访问修饰符：抽象方法可以有public/default等修饰符，接口方法默认修饰符是public，不能用其他修饰<br>6.实现：<br>抽象类：子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供接口中所有声明的方法的实现抽象类中所有声明的方法的实现。<br>接口：子类使用关键字implements来实现接口，它需要提供接口中所有声明的方法的实现</p>
<h3 id="10-内部类"><a href="#10-内部类" class="headerlink" title="10.内部类"></a>10.内部类</h3><p>注：所有使用内部类的地方都可以不用内部类，使用内部类可以使程序更加的简洁，便于命名规范和划分层次结构。<br>内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。<br>内部类是指在一个外部类的内部再定义一个类。内部类作为外部类的一个成员，并且依附于外部类而存在的。<br>内部类的分类：<br>.成员内部类:作为外部类的一个成员存在，与外部类的属性、方法并列<br>.局部内部类:在方法中定义的内部类<br>.静态内部类:静态内部类只能访问外部类的静态成员<br>.匿名内部类:通过匿名接口实现，是一种特殊的局部内部类</p>
<h3 id="11-正向和反向代理"><a href="#11-正向和反向代理" class="headerlink" title="11.正向和反向代理"></a>11.正向和反向代理</h3><p>正向：代理服务器在客户端(client)那边就是正向代理,正向代理需要客户端配置，客户端是知道自己通过代理方式去访问服务器的，例如：vpn，ssr</p>
<p>反向：代理服务器在原始服务器(server)那边就是反向代理，反向代理，客户端根本就不知道，是服务端配置的。例如：nginx</p>
<h3 id="12-get和post的区别？"><a href="#12-get和post的区别？" class="headerlink" title="12.get和post的区别？"></a>12.get和post的区别？</h3><p>1.get是从服务器上获取数据，post是向服务器传送数据。<br>2.get地址栏明文传输数据，post通过http header传输<br>3.get传输的数据量很小，post较大<br>4.get安全性教差，post安全性较高<br>5.get产生一个TCP数据包,post产生两个TCP数据包。</p>
<h3 id="13-session和cookie的区别"><a href="#13-session和cookie的区别" class="headerlink" title="13.session和cookie的区别"></a>13.session和cookie的区别</h3><p>1.session保存在服务器，客户端不知道其中信息；cookie保存在客户端，服务器可以知道其中信息<br>2.session保存的是对象，cookie保存的是字符串<br>3.cookie不安全，考虑安全应当用session<br>4.访问量增多会占用服务器性能，考虑到这应当用cookie</p>
<h3 id="14-session的分布式处理"><a href="#14-session的分布式处理" class="headerlink" title="14.session的分布式处理"></a>14.session的分布式处理</h3><p>1.粘性session：<br>负载均衡器设置了粘性Session，用户的每次请求都会转发到同一台服务器上，<br>相当于把用户和服务器黏在了一起<br>缺点：容错性低,如果当前服务器故障，用户被转移到另一台服务器上，session信息会失效<br>实现：nginx通过ip_hash属性即可实现粘性session</p>
<p>2.服务器session复制：<br>任何一个服务器上的session发生改变，该节点会把这个session的所有内容序列化，<br>然后广播给其他节点，不管其他服务器是否需要，以此来实现session同步<br>缺点：降低服务器性能，对网络造成压力<br>实现：tomcat中，server.xml开启tomcat集群功能</p>
<p>3.redis实现session共享<br>4.session入库</p>
<h3 id="15-jdbc基本流程"><a href="#15-jdbc基本流程" class="headerlink" title="15.jdbc基本流程"></a>15.jdbc基本流程</h3><p>1.加载数据库驱动<br>2.获取数据库连接<br>3.创建sql对象<br>4.执行sql语句<br>5.处理ResultSet<br>6.释放资源</p>
<h3 id="16-反射"><a href="#16-反射" class="headerlink" title="16. 反射"></a>16. 反射</h3><p>反射</p>
<p>首先我们了解一下JVM，什么是JVM，Java的虚拟机，java之所以能跨平台就是因为这个东西，<br>你可以理解成一个进程，程序，只不过他的作用是用来跑你的代码的。<br>假如你写了一段代码：Object o=new Object();  运行了起来！</p>
<p>1.首先JVM会启动，你的代码会编译成一个.class文件<br>2.然后被类加载器加载进jvm的内存中，你的类Object加载到方法区中，创建了Object类的class对象到堆中，注意这个不是new出来的对象，而是类的类型对象，每个类只有一个class对象，作为方法区类的数据结构的接口。</p>
<p>jvm创建对象前，会先检查类是否加载，寻找类对应的class对象，若加载好，则为你的对象分配内存，<br>初始化也就是代码:new Object()。<br>上面的流程就是你自己写好的代码扔给jvm去跑，跑完就over了，jvm关闭，你的程序也停止了。<br>为什么要讲这个呢？因为要理解反射必须知道它在什么场景下使用。</p>
<p>想想上面的程序对象是自己new的，程序相当于写死了给jvm去跑。<br>假如一个服务器上突然遇到某个请求要用到某个类，<br>但没加载进jvm，是不是要停下来自己写段代码，new一下，再启动一下服务器？错~~</p>
<p>反射是什么呢？当我们的程序在运行时，<br>需要动态的加载一些类这些类可能之前用不到所以不用加载到jvm。</p>
<p>举个例子我们的项目底层有时是用mysql，有时用oracle，<br>需要动态地根据实际情况加载驱动类，这个时候反射就有用了，<br>假设 com.java.dbtest.myqlConnection，com.java.dbtest.oracleConnection<br>这两个类我们要用，这时候我们的程序就写得比较动态化，<br>通过Class tc = Class.forName(“com.java.dbtest.TestConnection”);<br>通过类的全类名让jvm在服务器中找到并加载这个类，<br>而如果是oracle则传入的参数就变成另一个了。<br>这时候就可以看到反射的好处了，这个动态性就体现出java的特性了！<br>当然这里只是举了反射的一个应用，实际还有其他作用，只是这个例子能更好地理解！</p>
<p>一.概念<br>主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，<br>并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。</p>
<p>程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。<br>所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。<br>反射的核心是JVM在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁</p>
<p>Java反射框架主要提供以下功能：</p>
<p>1.在运行时判断任意一个对象所属的类；<br>2.在运行时构造任意一个类的对象；<br>3.在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；<br>4.在运行时调用任意一个对象的方法<br>重点：是运行时而不是编译时</p>
<p>当我们在使用IDE(如Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。<br>很多框架（比如Spring）都是配置化的（比如通过XML文件配置JavaBean,Action之类的），<br>为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象.</p>
<p>二，反射机制的作用：<br>    1.反编译：.class–&gt;.java<br>    2.通过反射机制访问java对象的属性，方法，构造方法等；</p>
<p>三，在这里先看一下sun为我们提供了那些反射机制中的类：<br>    java.lang.Class;<br>    java.lang.reflect.Constructor;<br>    java.lang.reflect.Field;<br>    java.lang.reflect.Method;<br>    java.lang.reflect.Modifier;<br>    很多反射中的方法，属性等操作我们可以从这四个类中查询。</p>
<p>四.具体功能实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">1.反射机制获取类有三种方法，我们来获取Employee类型</span><br><span class="line">//第一种方式：  (注意要包名+类名)</span><br><span class="line">Class c1 = Class.forName(&quot;demo.Employee&quot;);</span><br><span class="line"></span><br><span class="line">//第二种方式：  </span><br><span class="line">//java中每个类型都有class属性.  </span><br><span class="line">Class c2 = Employee.class;</span><br><span class="line"></span><br><span class="line">//第三种方式：  </span><br><span class="line">//java语言中任何一个java对象都有getClass 方法  </span><br><span class="line">Employee e = new Employee();</span><br><span class="line">Class c3 = e.getClass(); //c3是运行时类 (e的运行时类是Employee)</span><br><span class="line">    </span><br><span class="line">2.创建对象：获取类以后我们来创建它的对象，利用newInstance：</span><br><span class="line">Class c =Class.forName(&quot;demo.Employee&quot;);</span><br><span class="line"></span><br><span class="line">//创建此Class 对象所表示的类的一个新实例  </span><br><span class="line">Object o = c.newInstance(); //调用了Employee的无参数构造方法</span><br><span class="line">    </span><br><span class="line">3.获取属性：分为所有的属性和指定的属性：</span><br><span class="line">b，获取特定的属性，对比着传统的方法来学习：</span><br><span class="line">//Student类</span><br><span class="line">public class Student &#123;</span><br><span class="line">    private String name ;</span><br><span class="line">    int age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//传统方法：</span><br><span class="line">Student s = new Student();</span><br><span class="line">s.age = 12; //set </span><br><span class="line">        System.out.println(s.age);//get </span><br><span class="line">//但是无法获取private的属性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//反射方法</span><br><span class="line">Class&lt;?&gt; c1 = Class.forName(&quot;reflect.Student&quot;);//取得对象</span><br><span class="line">Object o = c1.newInstance();//实例化对象 </span><br><span class="line">Field nameF = c1.getDeclaredField(&quot;name&quot;);//获取name属性</span><br><span class="line">        nameF.setAccessible(true); //使用反射机制可以打破封装性，导致了java对象的属性不安全。  </span><br><span class="line">        nameF.set(o,&quot;钢铁侠&quot;);//给属性赋值</span><br><span class="line">        System.out.println(nameF.get(o));</span><br><span class="line">            </span><br><span class="line">4，获取方法，和构造方法，不再详细描述，只来看一下关键字：</span><br><span class="line">方法和关键字:</span><br><span class="line">getDeclaredMethods():获取所有的方法</span><br><span class="line">getReturnType():获得方法的放回类型</span><br><span class="line">getParameterTypes():获得方法的传入参数类型</span><br><span class="line">getDeclaredMethod(&quot;方法名&quot;,参数类型.class,……):获得特定的方法</span><br><span class="line">        构造方法关键字</span><br><span class="line">getDeclaredConstructors():获取所有的构造方法</span><br><span class="line">getDeclaredConstructor(参数类型.class,……):获取特定的构造方法</span><br><span class="line"></span><br><span class="line">父类和父接口:</span><br><span class="line">getSuperclass():获取某类的父类</span><br><span class="line">getInterfaces():获取某类实现的接口</span><br></pre></td></tr></table></figure></p>
<p>这样我们就可以获得类的各种内容，进行了反编译。<br>对于JAVA这种先编译再运行的语言来说，反射机制可以使代码更加灵活，更加容易实现面向对象。</p>
<p>最后:<br>JAVA反射的再次学习，灵活的运用它，能够使我们的代码更加灵活，但是它也有它的缺点，<br>就是运用它会使我们的软件的性能降低，复杂度增加，所以还要我们慎重的使用它。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/06/idea快捷键/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王靖尧">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王靖尧的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/idea快捷键/" itemprop="url">idea快捷键</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-06T18:17:26+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="部分快捷键不好用时，注意与其他软件的热键冲突"><a href="#部分快捷键不好用时，注意与其他软件的热键冲突" class="headerlink" title="部分快捷键不好用时，注意与其他软件的热键冲突"></a>部分快捷键不好用时，注意与其他软件的热键冲突</h3><table>
<thead>
<tr>
<th>ctrl</th>
<th>`</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + F</td>
<td>在当前文件进行文本查找 （必备）</td>
</tr>
<tr>
<td>Ctrl + R</td>
<td>在当前文件进行文本替换 （必备）</td>
</tr>
<tr>
<td>Ctrl + Z</td>
<td>撤销 （必备）</td>
</tr>
<tr>
<td>Ctrl + Y</td>
<td>删除光标所在行 或 删除选中的行 （必备）</td>
</tr>
<tr>
<td>Ctrl + X</td>
<td>剪切光标所在行 或 剪切选择内容</td>
</tr>
<tr>
<td>Ctrl + C</td>
<td>复制光标所在行 或 复制选择内容</td>
</tr>
<tr>
<td>Ctrl + D</td>
<td>复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备）</td>
</tr>
<tr>
<td>Ctrl + W</td>
<td>递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备）</td>
</tr>
<tr>
<td>Ctrl + E</td>
<td>显示最近打开的文件记录列表</td>
</tr>
<tr>
<td>Ctrl + N</td>
<td>根据输入的 类名 查找类文件</td>
</tr>
<tr>
<td>Ctrl + G</td>
<td>在当前文件跳转到指定行处</td>
</tr>
<tr>
<td>Ctrl + J</td>
<td>插入自定义动态代码模板</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>方法参数提示显示</td>
</tr>
<tr>
<td>Ctrl + Q</td>
<td>光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td>
</tr>
<tr>
<td>Ctrl + U</td>
<td>前往当前光标所在的方法的父类的方法 / 接口定义</td>
</tr>
<tr>
<td>Ctrl + B</td>
<td>进入光标所在的方法/变量的接口或是定义出，等效于 Ctrl + 左键单击</td>
</tr>
<tr>
<td>Ctrl + K</td>
<td>版本控制提交项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td>Ctrl + T</td>
<td>版本控制更新项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td>Ctrl + H</td>
<td>显示当前类的层次结构</td>
</tr>
<tr>
<td>Ctrl + O</td>
<td>选择可重写的方法</td>
</tr>
<tr>
<td>Ctrl + I</td>
<td>选择可继承的方法</td>
</tr>
<tr>
<td>Ctrl + +</td>
<td>展开代码</td>
</tr>
<tr>
<td>Ctrl + -</td>
<td>折叠代码</td>
</tr>
<tr>
<td>Ctrl + /</td>
<td>注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备）</td>
</tr>
<tr>
<td>Ctrl + [</td>
<td>移动光标到当前所在代码的花括号开始位置</td>
</tr>
<tr>
<td>Ctrl + ]</td>
<td>移动光标到当前所在代码的花括号结束位置</td>
</tr>
<tr>
<td>Ctrl + F1</td>
<td>在光标所在的错误代码出显示错误信息</td>
</tr>
<tr>
<td>Ctrl + F3</td>
<td>调转到所选中的词的下一个引用位置</td>
</tr>
<tr>
<td>Ctrl + F4</td>
<td>关闭当前编辑文件</td>
</tr>
<tr>
<td>Ctrl + F8</td>
<td>在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td>
</tr>
<tr>
<td>Ctrl + F9</td>
<td>执行 Make Project 操作</td>
</tr>
<tr>
<td>Ctrl + F11</td>
<td>选中文件 / 文件夹，使用助记符设定 / 取消书签</td>
</tr>
<tr>
<td>Ctrl + F12</td>
<td>弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td>
</tr>
<tr>
<td>Ctrl + Tab</td>
<td>编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td>
</tr>
<tr>
<td>Ctrl + Enter</td>
<td>智能分隔行</td>
</tr>
<tr>
<td>Ctrl + End</td>
<td>跳到文件尾</td>
</tr>
<tr>
<td>Ctrl + Home</td>
<td>跳到文件头</td>
</tr>
<tr>
<td>Ctrl + Space</td>
<td>基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备）</td>
</tr>
<tr>
<td>Ctrl + Delete</td>
<td>删除光标后面的单词或是中文句</td>
</tr>
<tr>
<td>Ctrl + BackSpace</td>
<td>删除光标前面的单词或是中文句</td>
</tr>
<tr>
<td>Ctrl + 1,2,3…9</td>
<td>定位到对应数值的书签位置</td>
</tr>
<tr>
<td>Ctrl + 左键单击</td>
<td>在打开的文件标题上，弹出该文件路径</td>
</tr>
<tr>
<td>Ctrl + 光标定位</td>
<td>按 Ctrl 不要松开，会显示光标所在的类信息摘要</td>
</tr>
<tr>
<td>Ctrl + 左方向键</td>
<td>光标跳转到当前单词 / 中文句的左侧开头位置</td>
</tr>
<tr>
<td>Ctrl + 右方向键</td>
<td>光标跳转到当前单词 / 中文句的右侧开头位置</td>
</tr>
<tr>
<td>Ctrl + 前方向键</td>
<td>等效于鼠标滚轮向前效果</td>
</tr>
<tr>
<td>Ctrl + 后方向键</td>
<td>等效于鼠标滚轮向后效果</td>
</tr>
</tbody>
</table>
<h2 id="ALT"><a href="#ALT" class="headerlink" title="ALT"></a>ALT</h2><table>
<thead>
<tr>
<th>键位</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alt + `</td>
<td>显示版本控制常用操作菜单弹出层</td>
</tr>
<tr>
<td>Alt + Q</td>
<td>弹出一个提示，显示当前类的声明 / 上下文信息</td>
</tr>
<tr>
<td>Alt + F1</td>
<td>显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td>
</tr>
<tr>
<td>Alt + F2</td>
<td>对于前面页面，显示各类浏览器打开目标选择弹出层</td>
</tr>
<tr>
<td>Alt + F3</td>
<td>选中文本，逐个往下查找相同文本，并高亮显示</td>
</tr>
<tr>
<td>Alt + F7</td>
<td>查找光标所在的方法 / 变量 / 类被调用的地方</td>
</tr>
<tr>
<td>Alt + F8</td>
<td>在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td>
</tr>
<tr>
<td>Alt + Home</td>
<td>定位 / 显示到当前文件的 Navigation Bar</td>
</tr>
<tr>
<td>Alt + Enter</td>
<td>IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备）</td>
</tr>
<tr>
<td>Alt + Insert</td>
<td>代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</td>
</tr>
<tr>
<td>Alt + 左方向键</td>
<td>按左方向切换当前已打开的文件视图</td>
</tr>
<tr>
<td>Alt + 右方向键</td>
<td>按右方向切换当前已打开的文件视图</td>
</tr>
<tr>
<td>Alt + 前方向键</td>
<td>当前光标跳转到当前文件的前一个方法名位置</td>
</tr>
<tr>
<td>Alt + 后方向键</td>
<td>当前光标跳转到当前文件的后一个方法名位置</td>
</tr>
<tr>
<td>Alt + 1,2,3…9</td>
<td>显示对应数值的选项卡，其中 1 是   Project 用得最多</td>
</tr>
</tbody>
</table>
<h2 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h2><table>
<thead>
<tr>
<th>键位</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>Shift + F1</td>
<td>如果有外部文档可以连接外部文档</td>
</tr>
<tr>
<td>Shift + F2</td>
<td>跳转到上一个高亮错误 或 警告位置</td>
</tr>
<tr>
<td>Shift + F3</td>
<td>在查找模式下，查找匹配上一个</td>
</tr>
<tr>
<td>Shift + F4</td>
<td>对当前打开的文件，使用新Windows窗口打开，旧窗口保留</td>
</tr>
<tr>
<td>Shift + F6</td>
<td>对文件 / 文件夹 重命名</td>
</tr>
<tr>
<td>Shift + F7</td>
<td>在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td>
</tr>
<tr>
<td>Shift + F8</td>
<td>在 Debug 模式下，跳出，表现出来的效果跟 F9 一样</td>
</tr>
<tr>
<td>Shift + F9</td>
<td>等效于点击工具栏的 Debug 按钮</td>
</tr>
<tr>
<td>Shift + F10</td>
<td>等效于点击工具栏的 Run 按钮</td>
</tr>
<tr>
<td>Shift + F11</td>
<td>弹出书签显示层</td>
</tr>
<tr>
<td>Shift + Tab</td>
<td>取消缩进</td>
</tr>
<tr>
<td>Shift + ESC</td>
<td>隐藏当前 或 最后一个激活的工具窗口</td>
</tr>
<tr>
<td>Shift + End</td>
<td>选中光标到当前行尾位置</td>
</tr>
<tr>
<td>Shift + Home</td>
<td>选中光标到当前行头位置</td>
</tr>
<tr>
<td>Shift + Enter</td>
<td>开始新一行。光标所在行下空出一行，光标定位到新行位置</td>
</tr>
<tr>
<td>Shift + 左键单击</td>
<td>在打开的文件名上按此快捷键，可以关闭当前打开文件</td>
</tr>
<tr>
<td>Shift + 滚轮前后滚动</td>
<td>当前文件的横向滚动轴滚动</td>
</tr>
</tbody>
</table>
<h2 id="Ctrl-Alt"><a href="#Ctrl-Alt" class="headerlink" title="Ctrl + Alt"></a>Ctrl + Alt</h2><table>
<thead>
<tr>
<th>键位</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + Alt + L</td>
<td>格式化代码，可以对当前文件和整个包目录使用 （必备）</td>
</tr>
<tr>
<td>Ctrl + Alt + O</td>
<td>优化导入的类，可以对当前文件和整个包目录使用 （必备）</td>
</tr>
<tr>
<td>Ctrl + Alt + I</td>
<td>光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td>
</tr>
<tr>
<td>Ctrl + Alt + T</td>
<td>对选中的代码弹出环绕选项弹出层</td>
</tr>
<tr>
<td>Ctrl + Alt + J</td>
<td>弹出模板选择窗口，讲选定的代码加入动态模板中</td>
</tr>
<tr>
<td>Ctrl + Alt + H</td>
<td>调用层次</td>
</tr>
<tr>
<td>Ctrl + Alt + B</td>
<td>在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</td>
</tr>
<tr>
<td>Ctrl + Alt + V</td>
<td>快速引进变量</td>
</tr>
<tr>
<td>Ctrl + Alt + Y</td>
<td>同步、刷新</td>
</tr>
<tr>
<td>Ctrl + Alt + S</td>
<td>打开 IntelliJ IDEA 系统设置</td>
</tr>
<tr>
<td>Ctrl + Alt + F7</td>
<td>显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</td>
</tr>
<tr>
<td>Ctrl + Alt + F11</td>
<td>切换全屏模式</td>
</tr>
<tr>
<td>Ctrl + Alt + Enter</td>
<td>光标所在行上空出一行，光标定位到新行</td>
</tr>
<tr>
<td>Ctrl + Alt + Home</td>
<td>弹出跟当前文件有关联的文件弹出层</td>
</tr>
<tr>
<td>Ctrl + Alt + Space</td>
<td>类名自动完成</td>
</tr>
<tr>
<td>Ctrl + Alt + 左方向键</td>
<td>退回到上一个操作的地方 （必备）</td>
</tr>
<tr>
<td>Ctrl + Alt + 右方向键</td>
<td>前进到上一个操作的地方 （必备）</td>
</tr>
<tr>
<td>Ctrl + Alt + 前方向键</td>
<td>在查找模式下，跳到上个查找的文件</td>
</tr>
<tr>
<td>Ctrl + Alt + 后方向键</td>
<td>在查找模式下，跳到下个查找的文件</td>
</tr>
</tbody>
</table>
<h2 id="Ctrl-Shift"><a href="#Ctrl-Shift" class="headerlink" title="Ctrl + Shift"></a>Ctrl + Shift</h2><table>
<thead>
<tr>
<th>键位</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + Shift + F</td>
<td>根据输入内容查找整个项目 或 指定目录内文件 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + R</td>
<td>根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + J</td>
<td>自动将下一行合并到当前行末尾 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + Z</td>
<td>取消撤销 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + W</td>
<td>递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + N</td>
<td>通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + U</td>
<td>对选中的代码进行大 / 小写轮流转换 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + T</td>
<td>对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</td>
</tr>
<tr>
<td>Ctrl + Shift + C</td>
<td>复制当前文件磁盘路径到剪贴板</td>
</tr>
<tr>
<td>Ctrl + Shift + V</td>
<td>弹出缓存的最近拷贝的内容管理器弹出层</td>
</tr>
<tr>
<td>Ctrl + Shift + E</td>
<td>显示最近修改的文件列表的弹出层</td>
</tr>
<tr>
<td>Ctrl + Shift + H</td>
<td>显示方法层次结构</td>
</tr>
<tr>
<td>Ctrl + Shift + B</td>
<td>跳转到类型声明处</td>
</tr>
<tr>
<td>Ctrl + Shift + I</td>
<td>快速查看光标所在的方法 或 类的定义</td>
</tr>
<tr>
<td>Ctrl + Shift + A</td>
<td>查找动作 / 设置</td>
</tr>
<tr>
<td>Ctrl + Shift + /</td>
<td>代码块注释 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + [</td>
<td>选中从光标所在位置到它的顶部中括号位置</td>
</tr>
<tr>
<td>Ctrl + Shift + ]</td>
<td>选中从光标所在位置到它的底部中括号位置</td>
</tr>
<tr>
<td>Ctrl + Shift + +</td>
<td>展开所有代码</td>
</tr>
<tr>
<td>Ctrl + Shift + -</td>
<td>折叠所有代码</td>
</tr>
<tr>
<td>Ctrl + Shift + F7</td>
<td>高亮显示所有该选中文本，按Esc高亮消失</td>
</tr>
<tr>
<td>Ctrl + Shift + F8</td>
<td>在 Debug 模式下，指定断点进入条件</td>
</tr>
<tr>
<td>Ctrl + Shift + F9</td>
<td>编译选中的文件 / 包 /   Module</td>
</tr>
<tr>
<td>Ctrl + Shift + F12</td>
<td>编辑器最大化</td>
</tr>
<tr>
<td>Ctrl + Shift + Space</td>
<td>智能代码提示</td>
</tr>
<tr>
<td>Ctrl + Shift + Enter</td>
<td>自动结束代码，行末自动添加分号 （必备）</td>
</tr>
<tr>
<td>Ctrl + Shift + Backspace</td>
<td>退回到上次修改的地方</td>
</tr>
<tr>
<td>Ctrl + Shift + 1,2,3…9</td>
<td>快速添加指定数值的书签</td>
</tr>
<tr>
<td>Ctrl + Shift + 左方向键</td>
<td>在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句</td>
</tr>
<tr>
<td>Ctrl + Shift + 右方向键</td>
<td>在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句</td>
</tr>
<tr>
<td>Ctrl + Shift + 左方向键</td>
<td>在光标焦点是在工具选项卡上，缩小选项卡区域</td>
</tr>
<tr>
<td>Ctrl + Shift + 右方向键</td>
<td>在光标焦点是在工具选项卡上，扩大选项卡区域</td>
</tr>
<tr>
<td>Ctrl + Shift + 前方向键</td>
<td>光标放在方法名上，将方法移动到上一个方法前面，调整方法排序</td>
</tr>
<tr>
<td>Ctrl + Shift + 后方向键</td>
<td>光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</td>
</tr>
</tbody>
</table>
<h2 id="Alt-Shift"><a href="#Alt-Shift" class="headerlink" title="Alt + Shift"></a>Alt + Shift</h2><table>
<thead>
<tr>
<th>键位</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alt + Shift + N</td>
<td>选择 / 添加 task</td>
</tr>
<tr>
<td>Alt + Shift + F</td>
<td>显示添加到收藏夹弹出层</td>
</tr>
<tr>
<td>Alt + Shift + C</td>
<td>查看最近操作项目的变化情况列表</td>
</tr>
<tr>
<td>Alt + Shift + F</td>
<td>添加到收藏夹</td>
</tr>
<tr>
<td>Alt + Shift + I</td>
<td>查看项目当前文件</td>
</tr>
<tr>
<td>Alt + Shift + F7</td>
<td>在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td>
</tr>
<tr>
<td>Alt + Shift + F9</td>
<td>弹出 Debug 的可选择菜单</td>
</tr>
<tr>
<td>Alt + Shift + F10</td>
<td>弹出 Run 的可选择菜单</td>
</tr>
<tr>
<td>Alt + Shift + 左键双击</td>
<td>选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句</td>
</tr>
<tr>
<td>Alt + Shift + 前方向键</td>
<td>移动光标所在行向上移动</td>
</tr>
<tr>
<td>Alt + Shift + 后方向键</td>
<td>移动光标所在行向下移动</td>
</tr>
</tbody>
</table>
<h2 id="Ctrl-Shift-Alt"><a href="#Ctrl-Shift-Alt" class="headerlink" title="Ctrl + Shift + Alt"></a>Ctrl + Shift + Alt</h2><table>
<thead>
<tr>
<th>键位</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl + Shift + Alt + V</td>
<td>无格式黏贴</td>
</tr>
<tr>
<td>Ctrl + Shift + Alt + N</td>
<td>前往指定的变量 / 方法</td>
</tr>
<tr>
<td>Ctrl + Shift + Alt + S</td>
<td>打开当前项目设置</td>
</tr>
<tr>
<td>Ctrl + Shift + Alt + C</td>
<td>复制参考信息</td>
</tr>
</tbody>
</table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table>
<thead>
<tr>
<th>键位</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>F2</td>
<td>跳转到下一个高亮错误 或 警告位置 （必备）</td>
</tr>
<tr>
<td>F3</td>
<td>在查找模式下，定位到下一个匹配处</td>
</tr>
<tr>
<td>F4</td>
<td>编辑源</td>
</tr>
<tr>
<td>F7</td>
<td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td>
</tr>
<tr>
<td>F8</td>
<td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td>
</tr>
<tr>
<td>F9</td>
<td>在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td>
</tr>
<tr>
<td>F11</td>
<td>添加书签</td>
</tr>
<tr>
<td>F12</td>
<td>回到前一个工具窗口</td>
</tr>
<tr>
<td>Tab</td>
<td>缩进</td>
</tr>
<tr>
<td>ESC</td>
<td>从工具窗口进入代码文件窗口</td>
</tr>
<tr>
<td>连按两次Shift</td>
<td>弹出 Search Everywhere 弹出层</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/06/深入理解JAVA虚拟机/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王靖尧">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王靖尧的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/深入理解JAVA虚拟机/" itemprop="url">深入理解JAVA虚拟机</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-06T18:16:18+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-虚拟机内存结构"><a href="#1-虚拟机内存结构" class="headerlink" title="1.虚拟机内存结构"></a>1.虚拟机内存结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程私有：虚拟机栈，本地方法栈，程序计数器</span><br><span class="line">线程共享：堆，方法区（包括运行时常量池）</span><br></pre></td></tr></table></figure>
<h3 id="1-1程序计数器"><a href="#1-1程序计数器" class="headerlink" title="1.1程序计数器"></a>1.1程序计数器</h3><p><code>当前程序锁执行的字节码行号指示器，记录下一条需要执行的指令。</code></p>
<h3 id="1-2虚拟机栈"><a href="#1-2虚拟机栈" class="headerlink" title="1.2虚拟机栈"></a>1.2虚拟机栈</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">生命周期与线程相同，每个方法在执行时都会创建一个栈帧。</span><br><span class="line">方法执行的过程，就是栈帧入栈到出栈的过程。</span><br><span class="line">栈帧用于存放局部变量表，操作数栈，动态链接，方法出口等信息。</span><br><span class="line">局部变量表存放了编译期可知的基本数据类型和对象引用。</span><br></pre></td></tr></table></figure>
<h3 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为虚拟机使用到的Native方法服务。</span><br><span class="line">目前HotSpot虚拟机将本地方法栈和虚拟机栈合二为一。</span><br></pre></td></tr></table></figure>
<h3 id="1-4-堆"><a href="#1-4-堆" class="headerlink" title="1.4 堆"></a>1.4 堆</h3><p><code>存放对象实例，所有线程共享。</code></p>
<h3 id="1-5-方法区（永久代）"><a href="#1-5-方法区（永久代）" class="headerlink" title="1.5 方法区（永久代）"></a>1.5 方法区（永久代）</h3><p><code>存放被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等。</code></p>
<h3 id="1-6-运行时常量池"><a href="#1-6-运行时常量池" class="headerlink" title="1.6 运行时常量池"></a>1.6 运行时常量池</h3><p><code>方法区的一部分，用于存放编译期生成的各种字面量和符号引用。</code></p>
<h3 id="1-7-字面量，符号引用，直接引用"><a href="#1-7-字面量，符号引用，直接引用" class="headerlink" title="1.7 字面量，符号引用，直接引用"></a>1.7 字面量，符号引用，直接引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">字面量：通俗解释就是一个变量的值，但是这个值不能超过范围。</span><br><span class="line">int a = 1; 1是a的字面量</span><br><span class="line">213738648则不能是int的字面量，因为超出了int的范围。</span><br><span class="line">符号引用：以一组符号来描述引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。</span><br><span class="line">直接引用：直接指向目标的指针（类变量，类方法）。</span><br><span class="line">相对偏移量（实例变量，实例方法）。</span><br><span class="line">一个能间接定位到目标的句柄。</span><br></pre></td></tr></table></figure>
<h2 id="2-对象在内存中的布局"><a href="#2-对象在内存中的布局" class="headerlink" title="2.对象在内存中的布局"></a>2.对象在内存中的布局</h2><p><code>对象头（哈希码，GC分代年龄，数据指针，如果是数组还会有数组长度），实例数据，对齐填充</code></p>
<h2 id="3-判断对象是否死亡"><a href="#3-判断对象是否死亡" class="headerlink" title="3.判断对象是否死亡"></a>3.判断对象是否死亡</h2><h3 id="3-1引用计数算法"><a href="#3-1引用计数算法" class="headerlink" title="3.1引用计数算法"></a>3.1引用计数算法</h3><p><code>每个对象添加一个计数器，引用它加1，引用失效减1，为0则死亡，很难解决循环引用问题。</code></p>
<h3 id="3-2可达性分析算法"><a href="#3-2可达性分析算法" class="headerlink" title="3.2可达性分析算法"></a>3.2可达性分析算法</h3><p><code>从gc root节点开始向下搜索，不可达则已死。</code></p>
<p>可作为gc root节点的情况：</p>
<h4 id="3-2-1：虚拟机栈本地变量表引用的对象"><a href="#3-2-1：虚拟机栈本地变量表引用的对象" class="headerlink" title="3.2.1：虚拟机栈本地变量表引用的对象"></a>3.2.1：虚拟机栈本地变量表引用的对象</h4><h4 id="3-2-2：方法区中类静态属性引用的对象"><a href="#3-2-2：方法区中类静态属性引用的对象" class="headerlink" title="3.2.2：方法区中类静态属性引用的对象"></a>3.2.2：方法区中类静态属性引用的对象</h4><h4 id="3-2-3：方法区中常量引用的对象"><a href="#3-2-3：方法区中常量引用的对象" class="headerlink" title="3.2.3：方法区中常量引用的对象"></a>3.2.3：方法区中常量引用的对象</h4><h4 id="3-2-4：本地方法栈native方法引用的对象"><a href="#3-2-4：本地方法栈native方法引用的对象" class="headerlink" title="3.2.4：本地方法栈native方法引用的对象"></a>3.2.4：本地方法栈native方法引用的对象</h4><h2 id="4-引用的4中情况"><a href="#4-引用的4中情况" class="headerlink" title="4.引用的4中情况"></a>4.引用的4中情况</h2><p><code>强引用，软引用，弱引用，虚引用（幽灵引用）</code></p>
<h3 id="4-1强引用"><a href="#4-1强引用" class="headerlink" title="4.1强引用"></a>4.1强引用</h3><p><code>new 关键字，强引用还在，则不会被回收</code></p>
<h3 id="4-2软引用"><a href="#4-2软引用" class="headerlink" title="4.2软引用"></a>4.2软引用</h3><p><code>发生内存溢出钱，会把这些软引用对象列入回收范围，进行第二次回收时会将他们回收</code></p>
<h3 id="4-3：弱引用"><a href="#4-3：弱引用" class="headerlink" title="4.3：弱引用"></a>4.3：弱引用</h3><p><code>只能存活到下一次垃圾回收之前</code></p>
<h3 id="4-4：虚引用"><a href="#4-4：虚引用" class="headerlink" title="4.4：虚引用"></a>4.4：虚引用</h3><p><code>与对象的生存时间不发生关系，作用是在这个对象被回收的时候，收到一个系统通知</code></p>
<h2 id="5-垃圾收集算法"><a href="#5-垃圾收集算法" class="headerlink" title="5.垃圾收集算法"></a>5.垃圾收集算法</h2><h3 id="5-1：标记—清除-Mark-Sweep"><a href="#5-1：标记—清除-Mark-Sweep" class="headerlink" title="5.1：标记—清除 Mark-Sweep"></a>5.1：标记—清除 Mark-Sweep</h3><p><code>过程：标记可回收对象，进行清除
    缺点：标记和清除效率低，清除后会产生内存碎片</code></p>
<h3 id="5-2：复制算法"><a href="#5-2：复制算法" class="headerlink" title="5.2：复制算法"></a>5.2：复制算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">过程：将内存划分为相等的两块，将存活的对象复制到另一块内存，把已经使用的内存清理掉</span><br><span class="line">缺点：使用的内存变为了原来的一半</span><br><span class="line">进化：将一块内存按8:1的比例分为一块Eden区（80%）和两块Survivor区（10%）</span><br><span class="line">每次使用Eden和一块Survivor，回收时，将存活的对象一次性复制到另一块Survivor上，如果另一块Survivor空间不足，则使用分配担保机制存入老年代</span><br></pre></td></tr></table></figure>
<h3 id="5-3：标记—整理-Mark—Compact"><a href="#5-3：标记—整理-Mark—Compact" class="headerlink" title="5.3：标记—整理 Mark—Compact"></a>5.3：标记—整理 Mark—Compact</h3><p><code>过程：所有存活的对象向一端移动，然后清除掉边界以外的内存</code></p>
<h3 id="5-4：分代收集算法"><a href="#5-4：分代收集算法" class="headerlink" title="5.4：分代收集算法"></a>5.4：分代收集算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">过程：将堆分为新生代和老年代，根据区域特点选用不同的收集算法，如果新生代朝生夕死，则采用复制算法，老年代采用标记清除，或标记整理</span><br></pre></td></tr></table></figure>
<h2 id="6-HotSpot虚拟机算法实现"><a href="#6-HotSpot虚拟机算法实现" class="headerlink" title="6.HotSpot虚拟机算法实现"></a>6.HotSpot虚拟机算法实现</h2><h3 id="6-1枚举根节点"><a href="#6-1枚举根节点" class="headerlink" title="6.1枚举根节点"></a>6.1枚举根节点</h3><p><code>回收时如果逐个检查引用（可达性分析）效率低下，通过OopMap数据结构来得知哪些地方存放着引用</code></p>
<h3 id="6-2安全点"><a href="#6-2安全点" class="headerlink" title="6.2安全点"></a>6.2安全点</h3><p><code>不会为所有指令都生成OopMap，只会在特定位置生成，这些位置成为安全点。
方法调用，循环跳转，异常跳转等会产生安全点</code></p>
<h2 id="7-如何在GC发生时让所有线程都要附近的安全点停下"><a href="#7-如何在GC发生时让所有线程都要附近的安全点停下" class="headerlink" title="7.如何在GC发生时让所有线程都要附近的安全点停下"></a>7.如何在GC发生时让所有线程都要附近的安全点停下</h2><h3 id="7-1抢先式中断"><a href="#7-1抢先式中断" class="headerlink" title="7.1抢先式中断"></a>7.1抢先式中断</h3><p><code>中断全部线程，如果发现有线程不在安全点上，    那么恢复线程，让它跑到安全点上（几乎不使用）</code></p>
<h3 id="7-2主动式中断"><a href="#7-2主动式中断" class="headerlink" title="7.2主动式中断"></a>7.2主动式中断</h3><p><code>设置一个标志，线程执行时去轮询这个标志，标志为true则线程挂起。标志和安全点是重合的</code></p>
<h3 id="7-3安全区域"><a href="#7-3安全区域" class="headerlink" title="7.3安全区域"></a>7.3安全区域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一段代码片段，在这个区域中的任意地方开始GC都是安全的。为了解决处于Sleep或Blocked线程达到安全点的问题。</span><br><span class="line">过程：如果进入到了安全区域，那么标识自己已经进入，GC时不用管已经标识过的。如果离开，则检查是否完成了节点枚举或者整个GC，如果未完成，则必须等待离开信号。</span><br></pre></td></tr></table></figure>
<h2 id="8-垃圾收集器"><a href="#8-垃圾收集器" class="headerlink" title="8.垃圾收集器"></a>8.垃圾收集器</h2><h3 id="8-1-Serial"><a href="#8-1-Serial" class="headerlink" title="8.1 Serial"></a>8.1 Serial</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单线程新生代收集器，只会用一条线程完成收集工作</span><br><span class="line">	在Client模式下的虚拟机可以选择</span><br><span class="line">	新生代：复制算法</span><br><span class="line">	老年代：标记—整理</span><br></pre></td></tr></table></figure>
<h3 id="8-2-ParNew"><a href="#8-2-ParNew" class="headerlink" title="8.2 ParNew"></a>8.2 ParNew</h3><p><code>Serial的多线程版本，收集过程以及算法与Serival一致，可与CMS老年代收集器配合</code></p>
<h3 id="8-3-Parallel-Scavenge"><a href="#8-3-Parallel-Scavenge" class="headerlink" title="8.3 Parallel Scavenge"></a>8.3 Parallel Scavenge</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新生代收集器，多线程，主要关注吞吐量</span><br><span class="line">适合在后台运算不需要太多交互的任务</span><br><span class="line">采用复制算法</span><br></pre></td></tr></table></figure>
<h3 id="8-4-Serial-Old"><a href="#8-4-Serial-Old" class="headerlink" title="8.4 Serial Old"></a>8.4 Serial Old</h3><p><code>Serial 的老年代版本，采用 标记—整理</code></p>
<h3 id="8-5-Parallel-Old"><a href="#8-5-Parallel-Old" class="headerlink" title="8.5 Parallel Old"></a>8.5 Parallel Old</h3><p><code>Parallel Scavenge的老年代版本，采用多线程标记—整理</code></p>
<h3 id="8-6-CMS"><a href="#8-6-CMS" class="headerlink" title="8.6 CMS"></a>8.6 CMS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">老年代收集器，关注停顿时间，采用标记—清除</span><br><span class="line">4个过程，初始标记，并发标记，重新标记，并发清除</span><br><span class="line">收集过程与用户线程并发执行</span><br><span class="line">缺点：并发收集占用CPU资源，降低吞吐率。</span><br><span class="line">		浮动垃圾，程序不断运行会产生新的垃圾。</span><br><span class="line">JDK1.5老年代占用达到68%会触发，JDK1.6老年代占用达到92%会触发，触发的阈值可以设置，设置不当会导致FuLL GC 降低性能。</span><br><span class="line">会出现内存碎片，可设置参数，多少次不压缩的Full GC之后，进行一次压缩的，默认0，每次都会压缩。</span><br></pre></td></tr></table></figure>
<h3 id="8-7-G1-垃圾收集器"><a href="#8-7-G1-垃圾收集器" class="headerlink" title="8.7 G1 垃圾收集器"></a>8.7 G1 垃圾收集器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">特点：并行与并发，分代手机，空间整合，可预测的停顿</span><br><span class="line">将Java堆分为多个大小相等的独立区域，跟踪每个区域里垃圾的价值，维护一个优先列表，优先回收价值最大的。</span><br><span class="line">区域空间对象的引用使用Remembered Set记录，如果引用的对象处于不同的区域，通过Card Table把引用信息记录到被引用对象的Remembered Set中。</span><br><span class="line">过程：初始标记，并发标记，最终标记，筛选回收</span><br></pre></td></tr></table></figure>
<h2 id="9-GC日志"><a href="#9-GC日志" class="headerlink" title="9.GC日志"></a>9.GC日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[DefNew:3324k -&gt; 1527k (3712k) ,0.025secs] 3324k152k(11904k) 0.03 secs</span><br><span class="line">	DefNew表示GC发生的区域，区域名字与使用的收集器有关</span><br><span class="line">	中括号内部 3324k1527k(3712k) </span><br><span class="line">	GC前该区域已使用—&gt;GC后已使用（该区域总容量）</span><br><span class="line">	中括号外表示堆信息</span><br><span class="line">	secs表示GC花费时间</span><br></pre></td></tr></table></figure>
<h2 id="10-内存分配"><a href="#10-内存分配" class="headerlink" title="10.内存分配"></a>10.内存分配</h2><h3 id="10-1优先在Eden分配，"><a href="#10-1优先在Eden分配，" class="headerlink" title="10.1优先在Eden分配，"></a>10.1优先在Eden分配，</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果Eden空间不足，会发生一次MinorGC（新生代GC），GC时如果所剩空间不足以存放新对象，Survivor空间又无法存入原有存活对象，那么会将原有对象移入老年代，新对象分配在Eden区</span><br></pre></td></tr></table></figure>
<h3 id="10-2-Serival和ParNew收集器可以通过设置来保证打对象直接进入老年代"><a href="#10-2-Serival和ParNew收集器可以通过设置来保证打对象直接进入老年代" class="headerlink" title="10.2 Serival和ParNew收集器可以通过设置来保证打对象直接进入老年代"></a>10.2 Serival和ParNew收集器可以通过设置来保证打对象直接进入老年代</h3><h3 id="10-3-长期存活的对象进入老年代，"><a href="#10-3-长期存活的对象进入老年代，" class="headerlink" title="10.3 长期存活的对象进入老年代，"></a>10.3 长期存活的对象进入老年代，</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MinorGC时如果有存活对象能被Survivor容纳，那么年龄为1，每熬过一次MinorGC年龄加1，默认15岁会晋升到老年代</span><br><span class="line">-XX：MaxTenuringThreshold 设置晋升年龄</span><br></pre></td></tr></table></figure>
<h3 id="10-4"><a href="#10-4" class="headerlink" title="10.4"></a>10.4</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果Survivor空间中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代。</span><br></pre></td></tr></table></figure>
<h3 id="10-5"><a href="#10-5" class="headerlink" title="10.5"></a>10.5</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">空间分配担保，老年代的连续空间大于新生代的对象总大小，或者两次晋升的平均大小，就会进行MinorGC，否则将进行FULLGC。</span><br></pre></td></tr></table></figure>
<h2 id="11-Class类文件的结构"><a href="#11-Class类文件的结构" class="headerlink" title="11.Class类文件的结构"></a>11.Class类文件的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8位字节为基础单位的二进制流文件</span><br><span class="line">8位字节以上的数据项，按照高位在前的方式存储</span><br><span class="line">主要组成部分：无符号数和表</span><br></pre></td></tr></table></figure>
<h3 id="11-1-无符号数"><a href="#11-1-无符号数" class="headerlink" title="11.1 无符号数"></a>11.1 无符号数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u1,u2,u4,u8 代表1字节，2字节，4字节和8字节</span><br><span class="line">可以描述数字，索引引用，数量值，按照UTF-8构成的字符串值。</span><br></pre></td></tr></table></figure>
<h3 id="11-2-表"><a href="#11-2-表" class="headerlink" title="11.2 表"></a>11.2 表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">由多个无符号数或者其他表构成的复合数据类型，</span><br><span class="line">以_info结尾</span><br></pre></td></tr></table></figure>
<h3 id="11-3-Class文件内容顺序"><a href="#11-3-Class文件内容顺序" class="headerlink" title="11.3 Class文件内容顺序"></a>11.3 Class文件内容顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1-4字节，魔数，0xCAFEBABE</span><br><span class="line">5-6字节，次版本号</span><br><span class="line">7-8字节，主版本号</span><br><span class="line">常量池</span><br><span class="line">访问标志</span><br><span class="line">类索引</span><br><span class="line">父类索引</span><br><span class="line">接口索引</span><br><span class="line">字段表集合</span><br><span class="line">方法表集合</span><br><span class="line">属性表集合</span><br><span class="line">常量池：</span><br><span class="line">Class文件中第一个表类型的数据，0x0016 =22 代表21项常量，索引为1-21，第0项表示“不引用任何一个常量池项目”</span><br><span class="line">池中两大类常量：字面量和符号引用</span><br><span class="line">字面量：文本字符串，声明为final的常量。</span><br><span class="line">符号引用：</span><br><span class="line">1.类和接口的全限定名</span><br><span class="line">2.字段名称和描述符</span><br><span class="line">3.方法名称和描述符</span><br><span class="line">访问标志：</span><br><span class="line">两个字节，类或者接口的访问信息，包括是类还是接口，是否是public,是否是abstract，是否是final（类）</span><br><span class="line">类索引：</span><br><span class="line">类的全限定名，u2</span><br><span class="line">父类索引：</span><br><span class="line">父类的全限定名，单根继承，所以只有一个，除了Object之外，其他父类索引都不为0，u2</span><br><span class="line">	接口索引：</span><br><span class="line">u2类型集合，实现了哪些接口，顺序是implements关键字后从左至右</span><br><span class="line">	字段表集合：</span><br><span class="line">		类级变量（static）以及实例变量，不包括局部变量</span><br><span class="line">	方法表集合：</span><br><span class="line">		类中的方法</span><br><span class="line">	属性表集合：</span><br><span class="line">		描述某些专有信息，如方法的代码</span><br></pre></td></tr></table></figure>
<h2 id="12-类的生命周期"><a href="#12-类的生命周期" class="headerlink" title="12.类的生命周期"></a>12.类的生命周期</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加载，验证，准备，解析，初始化，使用，卸载，验证，准备，解析统称为连接</span><br></pre></td></tr></table></figure>
<h3 id="12-1-五种初始化情况"><a href="#12-1-五种初始化情况" class="headerlink" title="12.1 五种初始化情况"></a>12.1 五种初始化情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：使用new，读取或者设置一个类的静态字段，调用一个类的静态方法。被final修饰，编译器把结果放入常量池的静态字段除外。</span><br><span class="line">2：对类进行反射调用的时候。</span><br><span class="line">3：初始化一个类的时候，如果父类还没有初始化，先初始化父类。</span><br><span class="line">4：初始化main方法的类。</span><br><span class="line">5：java.lang.invoke.MethodHandle实例，解析结果为REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄</span><br></pre></td></tr></table></figure>
<h3 id="12-2-加载"><a href="#12-2-加载" class="headerlink" title="12.2 加载"></a>12.2 加载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">加载过程要完成3件事</span><br><span class="line">1：获取此类的二进制字节流</span><br><span class="line">2：将字节流转化为方法区的运行时数据结构</span><br><span class="line">3：在内存中生成一个对应的Class对象，作为方法区各种数据的访问入口</span><br></pre></td></tr></table></figure>
<h3 id="12-3-验证"><a href="#12-3-验证" class="headerlink" title="12.3 验证"></a>12.3 验证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">确保字节流符合要求，并且不会危害虚拟机安全，4个阶段</span><br><span class="line">文件格式验证，元数据验证，字节码验证，符号引用验证</span><br></pre></td></tr></table></figure>
<h3 id="12-4-准备"><a href="#12-4-准备" class="headerlink" title="12.4 准备"></a>12.4 准备</h3><p><code>为类变量（static）分配内存并设置初始值</code></p>
<h3 id="12-5-解析"><a href="#12-5-解析" class="headerlink" title="12.5 解析"></a>12.5 解析</h3><p><code>将常量池内的符号引用替换为直接引用</code></p>
<h3 id="12-6初始化"><a href="#12-6初始化" class="headerlink" title="12.6初始化"></a>12.6初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">执行类构造器的&lt;clinit&gt;方法的过程</span><br><span class="line">clinit方法：由类中的所有类变量（static）的赋值动作和静态语句块合并产生。</span><br><span class="line">静态语句块可为语句块之后的变量赋值，但不能访问。</span><br><span class="line">虚拟机保证在子类的clinit方法执行之前，父类的clinit方法已经执行完毕，所以第一个被执行的clinit方法肯定是java.lang.Object。</span><br><span class="line">父类的静态语句块优先于子类的变量赋值操作。</span><br><span class="line">没有静态语句块也没有变量赋值操作，则不会生成clinit方法。</span><br><span class="line">执行接口的clinit方法不需要执行父接口的clinit方法。</span><br><span class="line">只有一个线程会执行到类的clinit方法。</span><br></pre></td></tr></table></figure>
<h2 id="13-类加载器"><a href="#13-类加载器" class="headerlink" title="13.类加载器"></a>13.类加载器</h2><p><code>即使两个类来源于同一个class文件，被同一个虚拟机加载，只要他们的类加载器不同，那这两个类必定不相等。</code></p>
<h3 id="13-1-三种系统提供的类加载器"><a href="#13-1-三种系统提供的类加载器" class="headerlink" title="13.1 三种系统提供的类加载器"></a>13.1 三种系统提供的类加载器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">启动类加载器：加载存放在JAVA_HOME\lib目录中的，仅按照文件名识别，如rt.jar。</span><br><span class="line">	扩展类加载器：加载JAVA_HOME\lib\ext目录中的。</span><br><span class="line">应用程序类加载器：加载用户类路径（classpath）上指定的类库，如果没有自定义的加载器，则这个为默认。</span><br></pre></td></tr></table></figure>
<h3 id="13-2-双亲委派模型"><a href="#13-2-双亲委派模型" class="headerlink" title="13.2 双亲委派模型"></a>13.2 双亲委派模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">图为双亲委派模型，除了顶层的启动类加载器外，其余的加载器都应当有自己的父类加载器，父子关系使用组合关系，复用父加载器的代码。</span><br><span class="line">工作过程：如果要加载一个类，把这个请求委派给父类加载器，每一个都如此，所以最终都是由顶层启动类加载器加载，如果无法加载，则由自己去加载。</span><br><span class="line">如Object类，所有加载器都要加载，会委派给顶层去加载，所以Object类在环境中都是同一个。</span><br></pre></td></tr></table></figure>
<h2 id="14-运行时栈帧的结构"><a href="#14-运行时栈帧的结构" class="headerlink" title="14.运行时栈帧的结构"></a>14.运行时栈帧的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每一个方法从调用开始至执行完成都一应着一个栈帧在虚拟机栈中入栈到出站的过程。</span><br><span class="line">栈帧包括：局部变量表，操作数栈，动态连接，方法返回地址和附加信息。</span><br><span class="line">位于栈顶的栈帧才是有效的，与这个栈帧相关联的方法称为当前方法。</span><br></pre></td></tr></table></figure>
<h3 id="14-1局部变量表"><a href="#14-1局部变量表" class="headerlink" title="14.1局部变量表"></a>14.1局部变量表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用于存放方法参数，方法内部的局部变量。以Slot为单位，一个Slot可以存放32位以内的数据类型，long和double用两个Slot来存储。</span><br><span class="line">变量表索引从0开始，如果执行的是非static方法，第0位索引表示方法所属对象的实例引用，即this关键字，从1开始按参数顺序占用Slot，在根据方法体内部定义的变量顺序分配其余的Slot。</span><br></pre></td></tr></table></figure>
<h3 id="14-2操作数栈"><a href="#14-2操作数栈" class="headerlink" title="14.2操作数栈"></a>14.2操作数栈</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">后入先出的栈</span><br><span class="line">方法刚开始执行的时候，这个操作数栈是空的，执行过程中会发生出栈，入栈的操作。</span><br></pre></td></tr></table></figure>
<h3 id="14-3-动态连接"><a href="#14-3-动态连接" class="headerlink" title="14.3 动态连接"></a>14.3 动态连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，一部分符号引用会在运行期间转换为直接引用，成为动态连接。</span><br></pre></td></tr></table></figure>
<h3 id="14-4-方法的返回地址"><a href="#14-4-方法的返回地址" class="headerlink" title="14.4 方法的返回地址"></a>14.4 方法的返回地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">两种方式退出方法</span><br><span class="line">1.遇到方法返回的字节码指令，为正常出口</span><br><span class="line">2.遇到了异常，并且在异常表中没有匹配的异常处理器（异常未被处理），称为异常出口，不会产生任何返回值。</span><br><span class="line">方法正常退出时，调用者的PC计数器的值作为返回地址</span><br><span class="line">异常退出时，通过异常处理器表来确定返回地址</span><br><span class="line">退出方法执行的操作：恢复上层方法的局部变量表和操作数栈，把返回值（如果有）压入调用者的操作数栈，调整PC计数器的值，指向后一条指令（字节码）</span><br></pre></td></tr></table></figure>
<h2 id="15-方法调用"><a href="#15-方法调用" class="headerlink" title="15. 方法调用"></a>15. 方法调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">唯一任务，确定要调用哪一个方法。</span><br><span class="line">解析：在类加载的解析阶段，会将一部分符号引用转化为直接引用。条件为：编译器可知，运行期不可变。</span><br><span class="line">例如：静态方法，私有方法，实例构造器，父类方法，final方法。</span><br></pre></td></tr></table></figure>
<h2 id="16-分派"><a href="#16-分派" class="headerlink" title="16. 分派"></a>16. 分派</h2><h3 id="16-1-静态分派"><a href="#16-1-静态分派" class="headerlink" title="16.1 静态分派"></a>16.1 静态分派</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Human man = new Man();</span><br><span class="line">Human 称为变量的静态类型，Man为变量的实际类型。</span><br><span class="line">静态分派的典型应用是方法重载，重载是根据参数的静态类型作为判定依据。</span><br></pre></td></tr></table></figure>
<h3 id="16-2-动态分派"><a href="#16-2-动态分派" class="headerlink" title="16.2 动态分派"></a>16.2 动态分派</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主要体现在重写上，根据变量的实际类型来确定。</span><br><span class="line">静态分派属于多分派类型，动态分派属于单分派类型。</span><br></pre></td></tr></table></figure>
<h2 id="17-虚方法表"><a href="#17-虚方法表" class="headerlink" title="17.虚方法表"></a>17.虚方法表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在方法区中建立一个虚方法表，在连接阶段进行初始化，用于存放方法的实际入口。如果方法的在子类没有被重写，那么地址入口与父类一致，如果重写了，则指向子类实现的入口地址。</span><br></pre></td></tr></table></figure>
<h2 id="18-Java内存模型（JMM）"><a href="#18-Java内存模型（JMM）" class="headerlink" title="18.Java内存模型（JMM）"></a>18.Java内存模型（JMM）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">定义程序中各个变量的访问规则，实例字段，静态字段，构成数组对象的元素。</span><br><span class="line">不包括局部变量和方法参数，因为是线程私有。</span><br><span class="line">所有变量存储在主内存，对应Java堆中的实例数据部分，每条线程有自己的工作内存，对应着虚拟机栈中的部分区域。</span><br><span class="line">工作内存中保存了该线程使用到的变量（主内存的副本拷贝），对变量的所有操作都在工作内存中进行，工作内存中变量只对该线程可见，线程间变量值的传递通过主内存完成。</span><br></pre></td></tr></table></figure>
<h2 id="19-内存间的交互"><a href="#19-内存间的交互" class="headerlink" title="19.内存间的交互"></a>19.内存间的交互</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">8种操作</span><br><span class="line">	lock：将主内存变量标识为一条线程占用，即上锁。</span><br><span class="line">	unlock：将主内存lock状态的变量释放，其他线程可锁定，即</span><br><span class="line">	解锁。</span><br><span class="line">	read：将主内存变量的值传送到工作内存中，为load准备。</span><br><span class="line">	load：将read获取到的值放入工作内存的变量副本。</span><br><span class="line">	use：将工作内存中的变量值传递给执行引擎。</span><br><span class="line">	assign：将执行引擎接收到的值赋值给工作内存的变量。</span><br><span class="line">	store：将工作内存的变量值传递到主内存，为write准备。</span><br><span class="line">	write：将store获取到的值放入主内存。</span><br></pre></td></tr></table></figure>
<h2 id="20-volatile变量"><a href="#20-volatile变量" class="headerlink" title="20.volatile变量"></a>20.volatile变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">作用：保证此变量对所有线程的可见性。禁止指令的重排序优化。</span><br><span class="line">效率：volatile变量读操作性能与普通变量差别不大，写操作会慢一些。</span><br><span class="line">因为需要在本地代码中插入许多内存屏障来保证不会发生乱序执行，开销一般来讲比锁要低。</span><br><span class="line">规则：每次使用变量前都必须从主内存中刷新值，保证能看见其线程对变量的修改。</span><br><span class="line">每次修改变量后都必须同步回主内存中，保证其他线程可以看到自己的修改。</span><br><span class="line">变量不会被指令重排序优化，保证代码的执行顺序与程序顺序相同。</span><br><span class="line">非原子性协定：</span><br><span class="line">允许虚拟机将没有被volatile修改的64位数据分为两次32位操作来进行。long和double</span><br><span class="line">目前虚拟机几乎都将64位数据读写操作做为原子操作，所以long和double一般不需要用volatile修饰。</span><br></pre></td></tr></table></figure>
<h2 id="21-原子性"><a href="#21-原子性" class="headerlink" title="21.原子性"></a>21.原子性</h2><p><code>基本数据类型的读写具备原子性，同步块中的也具备原子性。</code></p>
<h2 id="22-可见性"><a href="#22-可见性" class="headerlink" title="22.可见性"></a>22.可见性</h2><p><code>一个线程修改了共享变量的值，其他线程立即得知。
普通变量和volatile变量都是如此，volatile变量是立即刷新主内存，普通变量则不会。</code></p>
<h2 id="23-有序性"><a href="#23-有序性" class="headerlink" title="23.有序性"></a>23.有序性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果在本线程内观察，所有操作都是有序的，一个线程中观察另一个线程，所有操作都是无序的。</span><br><span class="line">前半句：线程内表现都是串行。</span><br><span class="line">后半句：指令重排序，工作内存与主内存同步延迟的现象。</span><br></pre></td></tr></table></figure>
<h2 id="24-先行发生原则"><a href="#24-先行发生原则" class="headerlink" title="24.先行发生原则"></a>24.先行发生原则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">操作A先行发生与操作B，A发生在B操作之前，A产生的影响（赋值，方法调用等）可以被B观察到。</span><br><span class="line">Java中天然的先行发生关系：</span><br><span class="line">1程序次序规则：一个线程内，按照控制流程顺序，前面的操作，先行发生与后面的操作。</span><br><span class="line">2 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作，时间先后。</span><br><span class="line">3 volatile变量规则：对变量的写操作先行发生于后面的读操作，时间先后。</span><br><span class="line">4 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。</span><br><span class="line">5 线程终止规则：线程中所有操作都先行发生于此线程的终止检测。</span><br><span class="line">6 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</span><br><span class="line">7 对象终结规则：一个对象的初始化完成先行发生于它的finalsize()方法开始。</span><br><span class="line">8 传递性规则：操作A先行发生于操作B，B先C，可以得出，A先行发生于C的结论。</span><br><span class="line">一个操作时间上的先发生，不代表这个操作会是先行发生。</span><br><span class="line">时间先后与先行发生原则没有太大关系。</span><br></pre></td></tr></table></figure>
<h2 id="25-Java线程调度"><a href="#25-Java线程调度" class="headerlink" title="25.Java线程调度"></a>25.Java线程调度</h2><p><code>协同式和抢占式</code></p>
<h3 id="25-1-协同式"><a href="#25-1-协同式" class="headerlink" title="25.1 协同式"></a>25.1 协同式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程自己工作执行完成以后，主动通知系统切换到另外一个线程，不存在同步问题。</span><br><span class="line">缺点：一个线程阻塞会导致整个系统崩溃。</span><br></pre></td></tr></table></figure>
<h3 id="25-2-抢占式"><a href="#25-2-抢占式" class="headerlink" title="25.2 抢占式"></a>25.2 抢占式</h3><p><code>每个线程由系统分配执行时间，切换不由线程本身决定，不会有一个线程导致系统崩溃的问题。</code></p>
<h2 id="26-线程的状态"><a href="#26-线程的状态" class="headerlink" title="26.线程的状态"></a>26.线程的状态</h2><p><code>新建，运行，无限期等待，限期等待，阻塞</code></p>
<h3 id="26-1-新建"><a href="#26-1-新建" class="headerlink" title="26.1 新建"></a>26.1 新建</h3><p><code>创建后未启动的线程。</code></p>
<h3 id="26-2-运行"><a href="#26-2-运行" class="headerlink" title="26.2 运行"></a>26.2 运行</h3><p><code>Running和Ready 可能在执行，也可能在等待CPU为他分配执行时间。</code></p>
<h3 id="26-3-无限期等待"><a href="#26-3-无限期等待" class="headerlink" title="26.3 无限期等待"></a>26.3 无限期等待</h3><p><code>不会被分配执行时间，需要等待显示的唤醒。</code></p>
<h3 id="26-4-限期等待"><a href="#26-4-限期等待" class="headerlink" title="26.4 限期等待"></a>26.4 限期等待</h3><p><code>不会被分配执行时间，一定时间后由系统自动唤醒。</code></p>
<h3 id="26-5-阻塞"><a href="#26-5-阻塞" class="headerlink" title="26.5 阻塞"></a>26.5 阻塞</h3><p><code>线程被阻塞，等待获取一个排他锁。</code></p>
<h3 id="26-6结束"><a href="#26-6结束" class="headerlink" title="26.6结束"></a>26.6结束</h3><p><code>已终止，结束执行。</code></p>
<h2 id="27-线程安全"><a href="#27-线程安全" class="headerlink" title="27.线程安全"></a>27.线程安全</h2><p><code>不可变，绝对线程安全，相对线程安全，线程兼容，线程对立</code></p>
<h3 id="27-1-不可变"><a href="#27-1-不可变" class="headerlink" title="27.1 不可变"></a>27.1 不可变</h3><p><code>final 关键字。</code></p>
<h3 id="27-2-绝对线程安全"><a href="#27-2-绝对线程安全" class="headerlink" title="27.2 绝对线程安全"></a>27.2 绝对线程安全</h3><p><code>不管运行时环境如何，调用者都不需要任何额外的同步措施。</code></p>
<h3 id="27-3-相对线程安全"><a href="#27-3-相对线程安全" class="headerlink" title="27.3 相对线程安全"></a>27.3 相对线程安全</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">常说的线程安全，保证对这个对象单独的操作是线程安全的。</span><br><span class="line">Vector,HashTable,Collections的synchronizedConllection()方法</span><br></pre></td></tr></table></figure>
<h3 id="27-4-线程兼容"><a href="#27-4-线程兼容" class="headerlink" title="27.4 线程兼容"></a>27.4 线程兼容</h3><p><code>常说的线程不安全，对象本身并不是线程安全，调用时使用同步手段来保证线程安全。</code></p>
<h3 id="27-5-线程对立"><a href="#27-5-线程对立" class="headerlink" title="27.5 线程对立"></a>27.5 线程对立</h3><p><code>无论是否采取了同步措施，都无法在多线程环境中使用。</code></p>
<h2 id="28-线程安全的实现方法"><a href="#28-线程安全的实现方法" class="headerlink" title="28.线程安全的实现方法"></a>28.线程安全的实现方法</h2><h3 id="28-1-互斥同步（阻塞）"><a href="#28-1-互斥同步（阻塞）" class="headerlink" title="28.1 互斥同步（阻塞）"></a>28.1 互斥同步（阻塞）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">共享数据在同一时刻只能被一个线程使用，如synchronized关键字和并发包中的ReentrantLock。</span><br><span class="line">会在同步块的前后分别形成monitorenter和monitorexit</span><br><span class="line">需要一个引用类型的参数来指明要锁定和解锁的对象。</span><br><span class="line">如果没有明确指定，去取对象的对象实例（实例方法）或者Class对象（类方法static）来作为锁对象。</span><br></pre></td></tr></table></figure>
<h3 id="28-2-非阻塞同步"><a href="#28-2-非阻塞同步" class="headerlink" title="28.2 非阻塞同步"></a>28.2 非阻塞同步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先进行操作，如果没有其他线程争用，则操作成功，如果有争用，则采取补偿措施（不断尝试，直到成功为止）。</span><br></pre></td></tr></table></figure>
<h3 id="28-3-无同步方案"><a href="#28-3-无同步方案" class="headerlink" title="28.3 无同步方案"></a>28.3 无同步方案</h3><h4 id="28-3-1-可重入代码"><a href="#28-3-1-可重入代码" class="headerlink" title="28.3.1 可重入代码"></a>28.3.1 可重入代码</h4><p><code>如果一个方法，只要输入了相同的参数，就能返回相同的结果，则满足可重入行的要求，为线程安全。</code></p>
<h4 id="28-3-2-线程本地存储"><a href="#28-3-2-线程本地存储" class="headerlink" title="28.3.2 线程本地存储"></a>28.3.2 线程本地存储</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">共享数据的代码能否在一个线程中执行，如果能则共享数据的可见范围限制在一个线程内。</span><br><span class="line">如 生成者—消费者模式。</span><br><span class="line">Web应用交互，一个请求对应一个线程。</span><br></pre></td></tr></table></figure>
<h2 id="29-锁优化"><a href="#29-锁优化" class="headerlink" title="29.锁优化"></a>29.锁优化</h2><h3 id="29-1-自旋锁与自适应自旋"><a href="#29-1-自旋锁与自适应自旋" class="headerlink" title="29.1 自旋锁与自适应自旋"></a>29.1 自旋锁与自适应自旋</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">互斥同步性能最大影响是阻塞，挂起线程和恢复线程都需要转入内核态来完成。</span><br><span class="line">自旋锁是让线程执行一个忙循环，而不是挂起。</span><br><span class="line">JDK1.6默认开始，并增加了自适应的自旋锁。</span><br><span class="line">根据每次自旋的效果，来判定获取该对象的锁是自旋还是挂起，如果自旋的话，循环的次数。</span><br><span class="line">因为自旋锁属于占用执行时间，所以不适宜等待时间过长，因此根据对象以往获取锁的状态来判定，如果自旋时间过长还得不到锁，则放弃自旋，直接选择挂起线程。</span><br></pre></td></tr></table></figure>
<h3 id="29-2-锁消除"><a href="#29-2-锁消除" class="headerlink" title="29.2 锁消除"></a>29.2 锁消除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一段代码中，堆上的所有数据都不会逃逸出去，被其他线程访问到，就可以把他们当做栈上的数据。无需同步加锁进行。</span><br></pre></td></tr></table></figure>
<h3 id="29-3-锁粗化"><a href="#29-3-锁粗化" class="headerlink" title="29.3 锁粗化"></a>29.3 锁粗化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，</span><br><span class="line">		  将会把锁范围扩展到操作序列外部。如：</span><br><span class="line">		  StringBuffer sb = new StringBuffer();</span><br><span class="line">		  sb.append(s1);</span><br><span class="line">		  …..</span><br><span class="line">		  sb.append(s5);</span><br><span class="line">		  sb.toString();</span><br><span class="line">		  则会将锁扩展到第一个append之前至最后一个append之后。</span><br></pre></td></tr></table></figure>
<h3 id="29-4-轻量级锁"><a href="#29-4-轻量级锁" class="headerlink" title="29.4 轻量级锁"></a>29.4 轻量级锁</h3><p><code>减少传统重量级锁使用操作系统互斥量产生的性能消耗。</code></p>
<h3 id="29-5-偏向锁"><a href="#29-5-偏向锁" class="headerlink" title="29.5 偏向锁"></a>29.5 偏向锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">无竞争的情况下无需同步线程。</span><br><span class="line">线程第一次获取对象锁，CAS操作把线程ID记录到对象头中，CAS成功则这个线程每次进入到这个锁相关的同步块时，无需任何同步操作。</span><br><span class="line">如果有另外一个线程尝试获取该锁时，偏向模式结束。</span><br></pre></td></tr></table></figure>
<h2 id="30-编译优化技术"><a href="#30-编译优化技术" class="headerlink" title="30.编译优化技术"></a>30.编译优化技术</h2><h3 id="30-1-公共子表达式消除"><a href="#30-1-公共子表达式消除" class="headerlink" title="30.1 公共子表达式消除"></a>30.1 公共子表达式消除</h3><p><code>如果一个表达式E已经经过计算，并且E中所有变量的值都没有发生变化，那么E为公共表达式。</code></p>
<h3 id="30-2-数组边界检查消除"><a href="#30-2-数组边界检查消除" class="headerlink" title="30.2 数组边界检查消除"></a>30.2 数组边界检查消除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编译期能判断变量的取值范围永远在[0,arr.length]之间，则无线检查。</span><br><span class="line">例如，在一个循环中进行数组的访问。</span><br></pre></td></tr></table></figure>
<h3 id="30-3-方法内联"><a href="#30-3-方法内联" class="headerlink" title="30.3 方法内联"></a>30.3 方法内联</h3><h3 id="30-4-逃逸分析"><a href="#30-4-逃逸分析" class="headerlink" title="30.4 逃逸分析"></a>30.4 逃逸分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">定义一个对象后，被外部方法调用，或当做参数传递，称为方法逃逸。被其他线程访问，称为线程逃逸。</span><br><span class="line">别的方法和线程无法访问到这个对象，则不会逃逸，可以优化。</span><br><span class="line">栈上分配：</span><br><span class="line">	不会逃逸的对象分配在栈上，方法结束，自动销毁。</span><br><span class="line">同步消除：</span><br><span class="line">	不会逃逸则同步措施可以消除。</span><br><span class="line">标量替换：</span><br><span class="line">	数据无法继续分解则成为标量，如基本类型。</span><br><span class="line">	可以分解成为聚合量，如Java对象。</span><br><span class="line">如果不会逃逸，创建一个Java对象时，不直接创建该对象，而是创建若干个标量代替</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/06/JSP-Servlet知识点/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王靖尧">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王靖尧的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/JSP-Servlet知识点/" itemprop="url">JSP+Servlet知识点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-06T18:14:43+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-1web应用服务器"><a href="#1-1web应用服务器" class="headerlink" title="1.1web应用服务器"></a>1.1web应用服务器</h3><p>目前较为主流的Web应用服务器<br>Tomcat  ——  Apache软件基金会<br>Jboss  ——-  JBOSS公司<br>Weblogic ——  BEA公司<br>Websphere —–  IBM公司<br>IIS  —— 微软  支持ASP语言<br>Web应用服务器的主要作用是让用户可以通过浏览器（HTTP/HTTPS）方式访问你的项目。</p>
<h3 id="1-2-Tomcat目录结构"><a href="#1-2-Tomcat目录结构" class="headerlink" title="1.2 Tomcat目录结构"></a>1.2 Tomcat目录结构</h3><p>bin目录：存放tomcat启动和关闭的脚本文件<br>conf目录：存放tomcat各种配置文件<br>lib目录：存放tomcat的jar文件<br>logs目录：存放tomcat日志文件<br>work目录：tomcat运行时产生的工作文件<br>temp目录：存放临时文件<br><strong>webapps目录：主要的发布目录，放置javaWeb程序</strong><br>发布：<br>Eclipse:右键项目，export，选定路径生成war包，放入Tomcat的webapps目录下<br>idea：maven-package</p>
<h3 id="1-3tomcat启动与停止"><a href="#1-3tomcat启动与停止" class="headerlink" title="1.3tomcat启动与停止"></a>1.3tomcat启动与停止</h3><p>启动服务：双击tomcat   bin目录下的startup.bat<br>最后一行显示：server startup in 1234 ms<br>证明启动成功<br>打开浏览器，输入localhost:8080，可以看到tomcat默认页面<br>停止服务：双击tomcat   bin目录下的shutdown.bat 或直接闭窗口</p>
<h3 id="1-4-Tomcat端口设置"><a href="#1-4-Tomcat端口设置" class="headerlink" title="1.4 Tomcat端口设置"></a>1.4 Tomcat端口设置</h3><p>conf目录下server.xml文件进行修改<br>在server.xml中找到<connector></connector>标签，修改port中的端口号<br>注：端口范围：0–65535，其中0–1023，这些端口，一般固定分配给一些服务，<br>21 – FTP服务(文件传输)<br>25 – SMTP(简单邮件传输协议)<br>80 – HTTP服务<br>135 – RPC(远程过程调用)</p>
<p>动态端口范围：1024 – 65535  ,尽量不要占用系统端口</p>
<h3 id="1-5-Tomcat启动失败常见问题"><a href="#1-5-Tomcat启动失败常见问题" class="headerlink" title="1.5 Tomcat启动失败常见问题"></a>1.5 Tomcat启动失败常见问题</h3><p>1.JAVA环境变量配置有问题为导致tomcat启动时一闪而过，启动不成功。<br>2.tomcat端口被其他程序占用，尝试关闭占用端口的程序或修改tomcat端口</p>
<h3 id="1-6-访问Tomcat中的项目"><a href="#1-6-访问Tomcat中的项目" class="headerlink" title="1.6 访问Tomcat中的项目"></a>1.6 访问Tomcat中的项目</h3><p>IP地址:端口号/项目名字</p>
<h3 id="1-7-Web项目结构"><a href="#1-7-Web项目结构" class="headerlink" title="1.7 Web项目结构"></a>1.7 Web项目结构</h3><p>在WEB-INF 之外，存放静态资源，可以通过浏览器访问<br>WEB-INF中的文件受保护，无法通过浏览器直接访问</p>
<h3 id="2-1JSP语法"><a href="#2-1JSP语法" class="headerlink" title="2.1JSP语法"></a>2.1JSP语法</h3><p>JSP中可以写JAVA代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;% </span><br><span class="line">System.out.print(&quot;Hello world&quot;);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>
<p>&lt;%  JAVA代码  %&gt;<br><strong>单个脚本片段可以是不完整的，但是多个脚本片段整合的结果必须是完整的JAVA语句</strong><br>JSP脚本表达式</p>
<p></p><h1>&lt;%=userName%&gt;</h1><br>&lt;%=  变量名 %&gt;<p></p>
<h3 id="2-2JSP对象作用域"><a href="#2-2JSP对象作用域" class="headerlink" title="2.2JSP对象作用域"></a>2.2JSP对象作用域</h3><p>作用域：即”信息共享的范围”，就是说一个信息能够在多大范围内有效。<br>从大到小排列<br>1.Application 在所有应用程序中有效<br>例：如将一个变量保存到application中，所有人通过浏览器都可以看到该变量的值（信息是共享的）。</p>
<p>2.Session 在当前会话有效<br>会话：打开浏览器访问某网站，等于跟目标网站开启了一个会话，将浏览器关闭，则此次会话结束。<br>例：现有一个用户如将一个变量保存到session中，当前用户打开浏览器可以看到该变量的值，其他用户看不到，关闭浏览器后则会话结束。</p>
<p>3.Request 在当前请求有效<br>请求：每一次操作网站，比如：查询，提交，购买 ……<br>请求查询，请求提交，请求购买……</p>
<p>4.Page 当前页面有效</p>
<h3 id="2-3JSP内置对象"><a href="#2-3JSP内置对象" class="headerlink" title="2.3JSP内置对象"></a>2.3JSP内置对象</h3><p>Web服务器(Tomcat)启动后创建的一组对象，不需要使用new关键字直接可以使用该对象。<br>内置对象只存在于JSP中<br>JSP九大内置对象<br>session,request,response,out,page,application,pageContext,exception,config</p>
<p>1.Session对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">类型：Javax.servlet.http.HttpSession</span><br><span class="line">作用域：Session</span><br><span class="line">表示一个会话，用来保存用户信息，以便跟踪每个用户的状态。</span><br><span class="line">常用方法：</span><br><span class="line">session.getId(); </span><br><span class="line">取得Session的ID号，ID由Tomcat自动分配。</span><br><span class="line">session.setAttribute(key,object); </span><br><span class="line">向Session中设置一个属性。</span><br><span class="line">参数 key---键、标识，可理解为该属性的名字，</span><br><span class="line">Session中相同的key所对应的值会覆盖。</span><br><span class="line">参数 object---该属性的值，可以是任意类型的JAVA对象。</span><br><span class="line">session.getAttribute(key);  </span><br><span class="line">获取Session中的一个属性。</span><br><span class="line">参数key --- 键、标识、可理解为属性名字。</span><br><span class="line">通过session.setAttribute方法所设置的key来获取对应的值。</span><br><span class="line">	  session.removeAttribute(key);</span><br><span class="line">			删除Session中的一个属性。</span><br><span class="line">参数key --- 键、标识、可理解为属性名字。</span><br><span class="line">通过session.setAttribute方法所设置的key来删除一个属性</span><br></pre></td></tr></table></figure></p>
<p>2.Request对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">类型：javax.servlet.http.HttpServletRequest</span><br><span class="line">作用域：Request</span><br><span class="line">request对象代表了客户端的请求信息，主要用于接受通过HTTP协议传送到服务器的数据。（包括头信息、系统信息、请求方式以及请求参数等）。request对 象的作用域为一次请求。</span><br><span class="line">常用方法：</span><br><span class="line">request.getParameter(key);</span><br><span class="line">		获取表单提交数据（参数）。</span><br><span class="line">		参数key --- 参数名字。</span><br><span class="line">通过key获取页面传递的参数，key与HTML标签的name对应，如想将页面的数据当做参数标题至后台，需要指定元素的name属性。</span><br><span class="line">request.getParameterValues(key);</span><br><span class="line">		与request.getParameter方法用法一致。</span><br><span class="line">		返回值是数组，一般用于获取复选框checkbox的值。</span><br><span class="line">	  request.setAttribute(key,object);</span><br><span class="line">			向Request中设置一个属性。</span><br><span class="line">			参数同session.setAttribute方法。</span><br><span class="line">request.gettAttribute(key);</span><br><span class="line">		获取Request中的一个属性。</span><br><span class="line">		参数同session.getAttribute方法。</span><br><span class="line">request.getRequestDispatcher(&quot;list.jsp&quot;).forward(request,response);</span><br><span class="line">	用转发方式跳转到目标路径。</span><br><span class="line">   参数---JSP页面或另一个Servlet。</span><br><span class="line">	固定参数request,response。</span><br><span class="line">request.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">	设置请求的编码方式。</span><br><span class="line">	参数---编码格式UTF-8/GBK/GB2312 ……</span><br></pre></td></tr></table></figure></p>
<p>3.Response对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">类型：Javax.servlet.http. HttpServletResponse</span><br><span class="line">作用域：Page</span><br><span class="line">response 代表的是对客户端的响应，主要是将JSP容器处理过的对象传回到客户端。</span><br><span class="line">常用方法：</span><br><span class="line">response.sendRedirect(&quot;页面&quot;);</span><br><span class="line">通过重定向方式跳转到目标路径。</span><br><span class="line">参数 --- JSP页面或另一个Servlet。</span><br><span class="line">response.setCharacterEncoding(&quot;gbk&quot;);</span><br><span class="line">设置响应编码格式。</span><br><span class="line">参数---编码格式UTF-8/GBK/GB2312 ……。</span><br></pre></td></tr></table></figure></p>
<p>4.Out对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">类型:javax.servlet.jsp.jspWriter</span><br><span class="line">作用域:Page</span><br><span class="line">Out对象是一个输出流，用来向客户端输出数据。</span><br><span class="line">常用方法：</span><br><span class="line">out.print();</span><br><span class="line">向浏览器输出各类型的数据。</span><br><span class="line">类似System.out.print()方法;</span><br><span class="line">out.close();</span><br><span class="line">关闭流。</span><br></pre></td></tr></table></figure></p>
<p>5.Page对象<br>类型:java.lang.Object<br>作用域：Page</p>
<p>6.Application对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类型：javax.servlet.ServletContext</span><br><span class="line">作用域：application</span><br><span class="line">application 对象可将信息保存在服务器中，直到服务器关闭，否则application对象中保存的信息会在整个应用中都有效。与session对象相比，application对象生命周期更长，类似于系统的“全局变量”。</span><br><span class="line">服务器启动后就产生了这个Application对象，当客户再所访问的网站的各个页面之间浏览时，这个Application对象都是同一个，直到服务器关闭。但是与Session对象不同的时，所有客户的Application对象都时同一个，即所有客户共享这个内置的Application对象。</span><br></pre></td></tr></table></figure></p>
<ol start="7">
<li>pageContext对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 类型: javax.servlet.jsp.PageContext</span><br><span class="line">作用域：Page</span><br><span class="line">本JSP的页面上下文。</span><br><span class="line">上下文的理解：上下文可以联系到当前页面所有的信息。</span><br><span class="line">通过PageContext上下文对象获取当前页面的其他内置对象。</span><br><span class="line">pageContext.getRequest();获取Request对象。</span><br><span class="line">pageContext.getResponse();获取Response对象。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>8.exception对象<br> 类型：java.lang.Exception<br>作用域：Page<br>本JSP页面的异常对象</p>
<p>9.config对象<br> 类型: javax.servlet.ServletConfig<br> 作用域：Page<br> 代表配置对象。</p>
<p>10.总结<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">request 请求对象   作用域 Request</span><br><span class="line">response 响应对象  作用域 Page</span><br><span class="line">pageContext 页面上下文对象  作用域 Page</span><br><span class="line">session  会话对象  作用域 Session</span><br><span class="line">application  应用程序对象  作用域 Application</span><br><span class="line">out  输出对象   作用域 Page</span><br><span class="line">config   配置对象  作用域 Page</span><br><span class="line">page 页面对象   作用域 Page</span><br><span class="line">exception  异常对象  作用域 page</span><br></pre></td></tr></table></figure></p>
<h3 id="2-4-JSP基本指令"><a href="#2-4-JSP基本指令" class="headerlink" title="2.4 JSP基本指令"></a>2.4 JSP基本指令</h3><p>1.指令用于对JSP一些设置<br><code>指令语法  &lt;%@  指令名  属性名 = 值  %&gt;</code><br>一个指令作用于整个JSP文件<br>1.1 page指令<br><code>&lt;%@ page import=&quot;jsp_test.deleteUser&quot;%&gt;</code><br>1.2 include指令<br>附加一个页面<br><code>&lt;%@ include file=&quot;doLogin.jsp&quot; %&gt;</code><br>1.3 tablib指令<br><code>&lt;%@ prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</code></p>
<h3 id="2-5JSP动作"><a href="#2-5JSP动作" class="headerlink" title="2.5JSP动作"></a>2.5JSP动作</h3><p>略<br>违反了前后端分离的思想</p>
<h3 id="2-6jsp-include与-lt-include-gt-区别"><a href="#2-6jsp-include与-lt-include-gt-区别" class="headerlink" title="2.6jsp:include与&lt;%@include%&gt;区别"></a>2.6<a href="jsp:include" target="_blank" rel="noopener">jsp:include</a>与&lt;%@include%&gt;区别</h3><p>1.&lt;%@include%&gt;嵌入代码，先合并后编译，把代码原封不动的附加过来<br>如页面a.jsp中 有变量 stuName，b.jsp 中同样存在变量 stuName<br>使用&lt;%@include%&gt; 将报错，变量名重复</p>
<p>2.<a href="jsp:include" target="_blank" rel="noopener">jsp:include</a>嵌入执行后的内容。<br>先编译后合并，合并的是编译后的结果。<br>上述情况如使用<a href="jsp:include" target="_blank" rel="noopener">jsp:include</a>则不会报错。</p>
<h3 id="3-1-Servlet生命周期"><a href="#3-1-Servlet生命周期" class="headerlink" title="3.1 Servlet生命周期"></a>3.1 Servlet生命周期</h3><p>1.装载并创建该Servlet的一个实例对象(实例化)<br>2.调用Servlet实例对象的init()方法(初始化)<br>3.创建了一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的<br>HttpServletResponse对象，然后调用servlet的service()方法，<br>并将请求和相应对象作为参数传递进去(服务)<br>4.Web应用程序在被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的<br>destroy()方法)  (销毁)</p>
<p>实例化 — 初始化 —  服务 —  销毁</p>
<h3 id="3-2-转发和重定向的区别"><a href="#3-2-转发和重定向的区别" class="headerlink" title="3.2 转发和重定向的区别"></a>3.2 转发和重定向的区别</h3><p>重定向(redirect)<br>1.发送请求<br>2.服务器响应请求，返回给浏览器一个新的地址和响应<br>3.浏览器根据响应码，判定该响应为重定向，自动发送一个新的请求给服务器，请求地址为之前返回的地址<br>4.服务器响应请求给浏览器</p>
<p>转发(forward):<br>1.发送请求<br>2.服务器进行请求的重新设置，例如通过request.setAttribute<br>3.浏览器根据转发的地址，获取该地址的网页<br>4.服务器响应请求给浏览器</p>
<p>区别：<br>1.redirect改变浏览器地址，forward浏览器网址不变<br>2.redirect产生了两次请求，forward只产生一次请求<br>3.redirect网址可以是任意网站，forward必须是本站的网址<br>4.redirect:之前request中的变量全部失效，并进入一个新的request作用域<br>forward:之前request中的变量不会失效，就像把两个页面拼到了一起</p>
<p>1.有值没值<br>2.本站外站<br>3.变不变址<br>4.一次两次</p>
<h3 id="3-3-JavaBean"><a href="#3-3-JavaBean" class="headerlink" title="3.3 JavaBean"></a>3.3 JavaBean</h3><p>特征：<br>1.提供了一个默认的无参构造函数<br>2.需要被序列化并且实现了Serializanle接口<br>3.可能有一系列可读写属性<br>4.可能有一系列的”getter”或”setter”方法。</p>
<p>简单来说，JavaBean也是一个普通的JAVA类。<br>项目中，每一张数据表对应一个JavaBean, JavaBean中的属性、属性类型与数据表的字段和数据类型对应。<br>可将一个JavaBean对象看成一条数据。<br>单条数据用一个JavaBean对象接收。<br>多条数据用List&lt; JavaBean &gt; 对象接收。<br>通过JavaBean可实现数据表之间的关系。<br>使用JavaBean可保证开发时的效率以及数据类型的检查。</p>
<h3 id="3-4-JSTL标签及EL表达式"><a href="#3-4-JSTL标签及EL表达式" class="headerlink" title="3.4  JSTL标签及EL表达式"></a>3.4  JSTL标签及EL表达式</h3><p>1.JSTL标签：<br>JSP标准标签库（JSTL）是一个JSP标签集合，它封装了JSP应用的通用核心功能。JSP标准标签库（JSTL）是一个JSP标签集合，它封装了JSP应用的通用核心功能。<br>使用方法：<br>1.导入JAR包，jstl-1.2.jar。<br>2.在JSP页面中导入标签库<br>&lt;% tablib  prefix=”c” uri=”<a href="http://java.sun.com/jsp/jstl/core&quot;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core&quot;</a> %&gt;</p>
<p>2.EL表达式<br>语法结构:${expression}<br>可获取Page,Request,Session,Application作用域中的对象。<br>根据setAttribute的key来获取。<br>获取request中的student对象：<br>${requestScope.student}<br>获取request中的student对象的name属性<br>${requestScope.student.name}</p>
<p><img src="https://github.com/ayanamiq/images/blob/master/images/%E5%B8%B8%E7%94%A8JSTL%E6%A0%87%E7%AD%BE.png?raw=true" alt=""></p>
<p>3.jstl实战<br><img src="https://github.com/ayanamiq/images/blob/master/images/jstl%E5%AE%9E%E6%88%98.png?raw=true" alt=""><br><img src="https://github.com/ayanamiq/images/blob/master/images/jstl%E5%AE%9E%E6%88%981.png?raw=true" alt=""></p>
<h3 id="3-6-MVC模式"><a href="#3-6-MVC模式" class="headerlink" title="3.6 MVC模式"></a>3.6 MVC模式</h3><p>MVC全名是Model View Controller<br>模型(model)－视图(view)－控制器(controller)<br>MVC是一个框架模式，它强制性的使应用程序的输入、处理和输出分开。使用MVC应用程序被分成三个核心部件：模型、视图、控制器。它们各自处理自己的任务。最典型的MVC就是JSP + servlet + javabean的模式。<br>MVC工作原理<br>用户发送一个请求到控制器，控制器处理业务逻辑，如需要与数据库交互会用到相应的模型，业务逻辑处理完毕后返回一个结果（视图）给用户。</p>
<h3 id="3-7-项目开发三层模式"><a href="#3-7-项目开发三层模式" class="headerlink" title="3.7 项目开发三层模式"></a>3.7 项目开发三层模式</h3><p>数据访问层（最下层）<br>        主要负责数据库的访问，与数据进行交互，增删改查代码。<br>    业务逻辑层（中间层）<br>        处理个性化业务逻辑代码。<br>    表现层（最上层）<br>离用户最近。用于显示数据和接收用户输入的数据，为用户提供一种交互式操作的界面。 　<br>    优点：<br>        1.开发人员可以只关注结构中的某一层。<br>        2.可以很容易的用新的实现来替换原有层次的实现。<br>        3.可以降低层与层之间的依赖。</p>
<pre><code>    4. 有利于标准化。
    5. 利于各层逻辑的复用。
缺点：
</code></pre><ol>
<li>降低了系统的性能。这是不言而喻的。如果不采用分层式结构，很多业务可以直接造访数据库，以此获取相应的数据，如今却必须通过中间层来完成。</li>
<li>有时会导致级联的修改。这种修改尤其体现在自上而下的方向。如果在表示层中需要增加一个功能，为保证其设计符合分层式结构，可能需要在相应的业务逻辑层和数据访问层中都增加相应的代码。<br><img src="https://github.com/ayanamiq/images/blob/master/images/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%89%E5%B1%82%E6%A8%A1%E5%BC%8F.png?raw=true" alt=""><br>注意：代码不可跨层调用。<br>与MVC模式不用,MVC属于程序语言的设计模式。<br>三层模式为实际开发模式。</li>
</ol>
<h3 id="3-8-分页"><a href="#3-8-分页" class="headerlink" title="3.8 分页"></a>3.8 分页</h3><p>分页所需条件<br>        1.每页显示数（自定义）<br>        2.当前页面，初识为1，第一页（通过页面JSP传递得到）<br>       3.总页数（计算得到）<br>            总页数 = 总条数/每页显示数<br>            如果总条数/每页显示数为整数 那么页数刚好<br>            如果不为整数 需要页数+1  如果总条数/每页显示 +1<br>        4.总条数（查询数据库得到）<br>        5.获取数据起始位置，用作LIMIT 关键字的第一个参数（计算得到）<br>        公式 ： （ 当前页数 - 1 ） *  每页显示数</p>
<h3 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h3><p>Servlet 文件上传<br>略</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/06/mysql技巧-知识点/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王靖尧">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王靖尧的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/mysql技巧-知识点/" itemprop="url">mysql技巧+知识点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-06T18:13:55+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h3><p>1.1NF<br>即第一范式,指同一列中不能有多个值,(即实体中的某个属性不能有多个值,或者不能有重复的属性),简而言之，第一范式就是无重复的列<br>2.2NF<br>第二范式,要求表中中的每一行(每一条数据),必须可以被唯一的区分(即唯一id,主键)<br>3.3NF<br>第三范式,要求一个表中,不包含,已在其他表中,已包含的,非主关键字信息</p>
<h3 id="1-left-join和-inner-join-区别"><a href="#1-left-join和-inner-join-区别" class="headerlink" title="1. left join和 inner join 区别"></a>1. left join和 inner join 区别</h3><p>left以 left join 左侧的表为主表<br>right 以 right join 右侧表为主表<br>inner join 查找的数据是左右两张表共有的</p>
<h3 id="2-查找一个表中存在而另一个表中不存在的记录"><a href="#2-查找一个表中存在而另一个表中不存在的记录" class="headerlink" title="2.查找一个表中存在而另一个表中不存在的记录"></a>2.查找一个表中存在而另一个表中不存在的记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select j.id,j.job_name,c.member_name as company_id,j.job_address,j.salary,j.flush_time</span><br><span class="line">from hr_job j</span><br><span class="line">left join HR_COMPANY c on c.id = j.company_id</span><br><span class="line">left join hr_job_apply ja on ja.job_id = j.id</span><br><span class="line">where not exists (select ja.id from HR_JOB_APPLY where ja.job_id = j.id)</span><br><span class="line"></span><br><span class="line">select * from t1</span><br><span class="line">where id not in(select id from t2)</span><br></pre></td></tr></table></figure>
<h3 id="3-时间相关"><a href="#3-时间相关" class="headerlink" title="3.时间相关"></a>3.时间相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">获取今天到明天的数据</span><br><span class="line">where date_format(create_date,&apos;%y-%m-%d&apos;) </span><br><span class="line">BETWEEN date_format(curdate(),&apos;%y-%m-%d&apos;) </span><br><span class="line">and DATE_SUB(curdate(),INTERVAL -1 DAY)</span><br><span class="line"></span><br><span class="line">当天数据1</span><br><span class="line">where date_format(create_date,&apos;%y-%m-%d&apos;) = date_format(curdate(),&apos;%y-%m-%d&apos;)</span><br><span class="line"></span><br><span class="line">当天数据2</span><br><span class="line">select * from 表名 where to_days(时间字段名) = to_days(now());</span><br><span class="line">注：to_days 是mysql的函数</span><br><span class="line"></span><br><span class="line">昨天数据</span><br><span class="line">SELECT * FROM 表名 WHERE TO_DAYS( NOW( ) ) - TO_DAYS( 时间字段名) &lt;= 1</span><br><span class="line"></span><br><span class="line">近7天</span><br><span class="line">SELECT * FROM 表名 where DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;= date(时间字段名)</span><br><span class="line"></span><br><span class="line">近30天</span><br><span class="line">SELECT * FROM 表名 where DATE_SUB(CURDATE(), INTERVAL 30 DAY) &lt;= date(时间字段名)</span><br><span class="line"></span><br><span class="line">本月</span><br><span class="line">SELECT * FROM 表名 WHERE DATE_FORMAT( 时间字段名, &apos;%Y%m&apos; ) = DATE_FORMAT( CURDATE( ) , &apos;%Y%m&apos; )</span><br><span class="line"></span><br><span class="line">上一月</span><br><span class="line">SELECT * FROM 表名 WHERE PERIOD_DIFF( date_format( now( ) , &apos;%Y%m&apos; ) , date_format( 时间字段名, &apos;%Y%m&apos; ) ) =1</span><br><span class="line"></span><br><span class="line">查询本季度数据</span><br><span class="line">select * from `ht_invoice_information` where QUARTER(create_date)=QUARTER(now());</span><br><span class="line"></span><br><span class="line">查询上季度数据</span><br><span class="line">select * from `ht_invoice_information` where QUARTER(create_date)=QUARTER(DATE_SUB(now(),interval 1 QUARTER));</span><br><span class="line"></span><br><span class="line">查询本年数据</span><br><span class="line">select * from `ht_invoice_information` where YEAR(create_date)=YEAR(NOW());</span><br><span class="line"></span><br><span class="line">查询上年数据</span><br><span class="line">select * from `ht_invoice_information` where year(create_date)=year(date_sub(now(),interval 1 year));</span><br><span class="line"></span><br><span class="line">查询当前这周的数据</span><br><span class="line">SELECT name,submittime FROM enterprise WHERE YEARWEEK(date_format(submittime,&apos;%Y-%m-%d&apos;)) = YEARWEEK(now());</span><br><span class="line"></span><br><span class="line">查询上周的数据</span><br><span class="line">SELECT name,submittime FROM enterprise WHERE YEARWEEK(date_format(submittime,&apos;%Y-%m-%d&apos;)) = YEARWEEK(now())-1;</span><br><span class="line"></span><br><span class="line">查询上个月的数据</span><br><span class="line">select name,submittime from enterprise where date_format(submittime,&apos;%Y-%m&apos;)=date_format(DATE_SUB(curdate(), INTERVAL 1 MONTH),&apos;%Y-%m&apos;)</span><br><span class="line"></span><br><span class="line">select * from user where DATE_FORMAT(pudate,&apos;%Y%m&apos;) = DATE_FORMAT(CURDATE(),&apos;%Y%m&apos;) ; </span><br><span class="line"></span><br><span class="line">select * from user where WEEKOFYEAR(FROM_UNIXTIME(pudate,&apos;%y-%m-%d&apos;)) = WEEKOFYEAR(now()) </span><br><span class="line"></span><br><span class="line">select * from user where MONTH(FROM_UNIXTIME(pudate,&apos;%y-%m-%d&apos;)) = MONTH(now()) </span><br><span class="line"></span><br><span class="line">select * from user where YEAR(FROM_UNIXTIME(pudate,&apos;%y-%m-%d&apos;)) = YEAR(now()) and MONTH(FROM_UNIXTIME(pudate,&apos;%y-%m-%d&apos;)) = MONTH(now()) </span><br><span class="line"></span><br><span class="line">select * from user where pudate between  上月最后一天  and 下月第一天</span><br><span class="line"></span><br><span class="line">查询当前月份的数据 </span><br><span class="line">select name,submittime from enterprise   where date_format(submittime,&apos;%Y-%m&apos;)=date_format(now(),&apos;%Y-%m&apos;)</span><br><span class="line"></span><br><span class="line">查询距离当前现在6个月的数据</span><br><span class="line">select name,submittime from enterprise where submittime between date_sub(now(),interval 6 month) and now();</span><br></pre></td></tr></table></figure>
<h3 id="4-几种case-when的形式"><a href="#4-几种case-when的形式" class="headerlink" title="4.几种case-when的形式"></a>4.几种case-when的形式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CASE b.check_type</span><br><span class="line">when &apos;1&apos; then b.real_name</span><br><span class="line">when &apos;2&apos; then b.association_name</span><br><span class="line">    else u2.name(有else)</span><br><span class="line">end AS &quot;user.name&quot;,</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>CASE a.exh_type<br>when ‘1’ then a.is_art<br>when ‘2’ then c.is_art<br>end AS “isArt”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">case (case后边没东西)</span><br><span class="line">when a.end_time &gt; now() then &apos;1&apos;</span><br><span class="line">when a.end_time &amp;lt; now() then &apos;2&apos;</span><br><span class="line">end AS &quot;isPass&quot;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">where a.is_home = &apos;1&apos;</span><br><span class="line">and a.publish_status = &apos;1&apos;</span><br><span class="line">and (</span><br><span class="line">case a.exh_type</span><br><span class="line">    when &apos;1&apos; then a.audit_status = &apos;2&apos;</span><br><span class="line">        else 1 = 1</span><br><span class="line">        end</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="5-rand"><a href="#5-rand" class="headerlink" title="5.rand()"></a>5.rand()</h3><pre><code>随机函数效率很低
order by RAND() ：随机返回结果
</code></pre><h3 id="6-REGEXP"><a href="#6-REGEXP" class="headerlink" title="6.REGEXP"></a>6.REGEXP</h3><pre><code>单字匹配多字，或反之
例如：木雕中，标签
活动,展讯,文化弘扬 为一条数据的标签，要求，可以匹配到标签为展讯的内容
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AND x.label REGEXP</span><br><span class="line">(</span><br><span class="line">    SELECT</span><br><span class="line">    replace(new_category,&apos;,&apos;,&apos;|&apos;)</span><br><span class="line">    FROM</span><br><span class="line">    wd_news a1</span><br><span class="line">    WHERE</span><br><span class="line">    a1.id = &apos;1a94c3168229403aa11ea136596e335a&apos;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="7-并发插入、存在不插入，存在更新操作"><a href="#7-并发插入、存在不插入，存在更新操作" class="headerlink" title="7.并发插入、存在不插入，存在更新操作"></a>7.并发插入、存在不插入，存在更新操作</h3><p>方法1：通常会，先查再插，但是这样无法避免并发问题，不用考虑了。</p>
<p>2.存在即更新，不存在即插入<br><code>REPLACE into table (c1,c2) values(1,5)</code><br>如果发现表中已经有此行数据（根据主键或者唯一索引判断），<br>则先删除此行数据，然后插入新的数据，否则，直接插入新数据。</p>
<p>所以，插入时如果不插入主键(逐渐默认递增)，就需要保证一列是唯一索引，保证唯一，才行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建唯一索引sql:(也可以通过navcat创建)</span><br><span class="line">	CREATE UNIQUE INDEX sub_id ON table_name(sub_id); </span><br><span class="line">删除唯一索引sql:</span><br><span class="line">	ALTER TABLE table_name DROP INDEX sub_id;</span><br></pre></td></tr></table></figure></p>
<p>3.存在不插入，不存在再插入(感觉这种方法是最好的)<br>mysql 不能在插入时带where条件，故用临时表处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO demo_in(a,b,c) </span><br><span class="line">SELECT 123, 2, 4 FROM DUAL </span><br><span class="line">WHERE NOT EXISTS(SELECT c FROM demo_in WHERE c = 4);</span><br></pre></td></tr></table></figure></p>
<p>用临时表DUAL来标记数据，然后插入到demo_in表中。<br>条件是c=4，并且not exists，也就是当c=4条件满足，则不插入。</p>
<h3 id="8-视哪张表为主表，哪张为子表"><a href="#8-视哪张表为主表，哪张为子表" class="headerlink" title="8.视哪张表为主表，哪张为子表"></a>8.视哪张表为主表，哪张为子表</h3><p>对比两条SQL</p>
<p>SQL 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	a.id,</span><br><span class="line">	b.type,</span><br><span class="line">	b.last_price,</span><br><span class="line">	b.order_content,</span><br><span class="line">	b.create_time</span><br><span class="line">	FROM</span><br><span class="line">	business a</span><br><span class="line">	LEFT JOIN wallet_checkinout b ON a.user_id = b.user_id</span><br><span class="line">	WHERE</span><br><span class="line">		a.id = 1000039</span><br><span class="line">		AND b.money_type = 3</span><br><span class="line">		AND b.biz_type = 6</span><br><span class="line">	ORDER BY</span><br><span class="line">	 b.create_time desc</span><br></pre></td></tr></table></figure></p>
<p>SQL 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">      a.id,</span><br><span class="line">      a.type,</span><br><span class="line">      a.last_price,</span><br><span class="line">      a.order_info,</span><br><span class="line">      a.order_content,</span><br><span class="line">      a.create_time,</span><br><span class="line">      a.close_status</span><br><span class="line">    FROM</span><br><span class="line">    wallet_checkinout a</span><br><span class="line">    LEFT JOIN business b ON b.user_id = a.user_id</span><br><span class="line">    WHERE</span><br><span class="line">      b.id = 1000039</span><br><span class="line">      AND a.type = 1</span><br><span class="line">      AND a.money_type = 3</span><br><span class="line">      AND a.biz_type = 6</span><br><span class="line">		order by a.create_time desc</span><br></pre></td></tr></table></figure></p>
<p>以上两条sql查出的结果是一样的。<br>目前，我认为：无论以哪张表为主表都可以。</p>
<h3 id="9-union和union-all-区别"><a href="#9-union和union-all-区别" class="headerlink" title="9.union和union all 区别"></a>9.union和union all 区别</h3><p>1.union 操作符会选取不同的值<br>   UNION ALL 允许重复的值(会将所有的值列出)</p>
<h3 id="10-union-union-all-和order-by"><a href="#10-union-union-all-和order-by" class="headerlink" title="10.union(union all)和order by"></a>10.union(union all)和order by</h3><p>1.每一个子句可以使用()包围，但是当第一个子句使用了()时，其它的子句都必须使用括号包围。</p>
<ol start="2">
<li>每一个字句可以包含WHERE，GROUP BY，HAVING，JOIN，LIMIT，但是不能使用ORDER BY，如果需要使用ORDER BY，必须使用()包围子句。</li>
</ol>
<h3 id="11-给查询记录添加自然序号"><a href="#11-给查询记录添加自然序号" class="headerlink" title="11.给查询记录添加自然序号"></a>11.给查询记录添加自然序号</h3><p>表a，数据：<br>id name<br>12 张三<br>13 李四<br>15 王五</p>
<p>通过一条sql获取这三条记录，并且给每行前面加上从1开始的序号</p>
<p>1 12 张三<br>2 13 李四<br>3 14 王五<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">@rownum := @rownum + 1 AS rownum,</span><br><span class="line">a.* </span><br><span class="line">FROM</span><br><span class="line">( SELECT @rownum := 0 ) r,</span><br><span class="line">table a;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">王靖尧</p>
              <p class="site-description motion-element" itemprop="description">一晃而过的时间，都做了些什么</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王靖尧</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
